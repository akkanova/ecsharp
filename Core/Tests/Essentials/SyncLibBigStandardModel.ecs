#ecs;
using System;
using System.Collections.Generic;
using System.Text;
using System.Numerics;

[Passive]
define (#type<$T>) { $T; }

macro standardTypeToName($type) {
	if (!type.HasSpecialName())
		return type;
	return LNode.Id(type.Name.Name[1].ToString().ToUpper() + type.Name.Name.Substring(2));
}

using Loyc.SyncLib;

namespace Loyc.Essentials.Tests
{
	define basicTypes => #splice(bool, sbyte, byte, short, ushort, int, uint, long, ulong, float, double, decimal, BigInteger, char);
	define standardTypes => #splice(bool, sbyte, byte, short, ushort, int, uint, long, ulong, float, double, decimal, BigInteger, char, string);
	define standardItemTypes => #splice(bool, sbyte, byte, short, ushort, int, uint, long, ulong, float, double, decimal, BigInteger, char, #type<string? >);

	internal class StandardFields
	{
		##unroll(($ListT, $Suffix) in (
			($T, ""),
			(#type<$T? >, "Nullable"),
		))
		{
			##unroll($T in standardTypes)
			{
				replace (varname => concatId(standardTypeToName($T), $Suffix))
				{
					public $ListT varname;
				}
			}
		}

		public this(int seed)
		{
			Bool = (seed & 1) != 0;
			BoolNullable = null;
			String = (seed++).ToString();
			##unroll($T in basicTypes) {
				static if (!($T `staticMatches` bool)) {
					#snippet varstem = standardTypeToName($T);
					$varstem = ($T) seed++;
					concatId($varstem, "Nullable") = ($T) seed++;
				}
			}
		}
	}

	/// This class uses all standard types, their nullable variants,
	/// and most of the supported collections of standard types, 
	/// notably excluding Memory<T> which is not supported by Newtonsoft
	/// (and so interferes with the Newtonsoft compatibility tests).
	/// There are no custom types here, just natively-supported types.
	internal class BigStandardModelNoMem : StandardFields
	{
		##unroll(($ListT, $Suffix) in (
			(#type<$T[]>, "Array"),
			(List<$T>, "List"),
			//(IList< $T? >, "NList"),
			//(IReadOnlyCollection< $T >, "Coll"),
		))
		{
			##unroll($T in standardTypes)
			{
				#snippet varname = concatId(standardTypeToName($T), $Suffix);
				public $ListT $varname;
			}
		}

		public this(int seed) : base(seed)
		{
			BoolArray = new bool[0];
			BoolList = new List<bool> { false, true };
			//BoolColl = BoolList;
			StringArray = new string[] { "Yarn", "Twine" };
			StringList = new List<string> { "Rope", "String" };
			//StringColl = StringList;

			##unroll($T in basicTypes) {
				static if (!($T `staticMatches` bool)) {
					#snippet varstem = standardTypeToName($T);
					$varstem = ($T) seed++;
					//concatId($varstem, "Coll") = 
					concatId($varstem, "List") = new List<$T> { 
						($T) seed++, ($T) seed++
					};
					concatId($varstem, "Array") = new $T[] { 
						($T) seed++, ($T) seed++, ($T) seed++
					};
				}
			}
		}
	}

	/// This class uses all standard types, their nullable variants,
	/// and most of the supported collections of standard types. 
	/// But there are no custom types.
	internal class BigStandardModel : BigStandardModelNoMem
	{
		##unroll(($ListT, $Suffix) in (
			(Memory<$T>, "Memory"),
		))
		{
			##unroll($T in standardTypes)
			{
				#snippet varname = concatId(standardTypeToName($T), $Suffix);
				public $ListT $varname;
			}
		}

		public this(int seed) : base(seed)
		{
			##unroll($T in basicTypes) {
				static if (!($T `staticMatches` bool)) {
					#snippet varstem = standardTypeToName($T);
					
					concatId($varstem, "Memory") = concatId($varstem, "Array").AsMemory();
				}
			}
		}
	}


	class BigStandardModelSync<S> where S: ISyncManager
	{
		public static readonly SyncObjectFunc<S, BigStandardModel> SyncBigModel = (sync, obj) =>
		{
			obj = (BigStandardModel) SyncBigModelNoMem(sync, obj);
			SyncMem(sync, obj);
			return obj;
		};

		public static readonly SyncObjectFunc<S, BigStandardModelNoMem> SyncBigModelNoMem = (sync, obj) =>
		{
			obj ??= new BigStandardModel(0);
			SyncLists(sync, obj);
			SyncBasics(sync, obj);
			return obj;
		};

		public static readonly SyncObjectFunc<S, StandardFields> SyncBasics = SyncBasics_;
		public static StandardFields SyncBasics_(S sync, StandardFields? obj)
		{
			obj ??= new BigStandardModel(0);

			##unroll(($ListT, $Suffix, $Sync) in (
				($T, "", Sync),
				(#type<$T? >, "Nullable", SyncNullable),
			))
			{
				##unroll($T in standardTypes)
				{
					#snippet varname = concatId(standardTypeToName($T), $Suffix);
					obj.$varname = sync.$Sync(concat($varname), obj.$varname);
				}
			}

			return obj;
		}

		public static BigStandardModelNoMem SyncLists(S sync, BigStandardModelNoMem obj)
		{
			obj ??= new BigStandardModel(0);

			##unroll(($ListT, $Suffix, $Sync) in (
				(#type<$T[]>, "Array", SyncList),
				(List<$T>, "List", SyncList),
				//(IList< $T? >, "NList", SyncList),
				//(IReadOnlyCollection<$T>, "Coll", SyncList),
			))
			{
				##unroll($T in standardTypes)
				{
					#snippet varname = concatId(standardTypeToName($T), $Suffix);
					obj.$varname = sync.$Sync(concat($varname), obj.$varname);
				}
			}
			
			return obj;
		}

		public static BigStandardModel SyncMem(S sync, BigStandardModel obj)
		{
			obj ??= new BigStandardModel(0);

			##unroll(($ListT, $Suffix, $Sync) in (
				(Memory<$T>, "Memory", SyncList),
			))
			{
				##unroll($T in standardTypes)
				{
					#snippet varname = concatId(standardTypeToName($T), $Suffix);
					obj.$varname = sync.$Sync(concat($varname), obj.$varname);
				}
			}
			
			return obj;
		}
	}
}
