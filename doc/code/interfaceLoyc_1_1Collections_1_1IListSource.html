<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Enhanced C#: Loyc.Collections.IListSource&lt; out out T &gt; Interface Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">IListSource</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interfaceLoyc_1_1Collections_1_1IListSource-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.IListSource&lt; out out T &gt; Interface Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A read-only list indexed by an integer. 
 <a href="interfaceLoyc_1_1Collections_1_1IListSource.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Interfaces/Collections/IListSource.cs'>/Core/Loyc.Interfaces/Collections/IListSource.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.IListSource&lt; out out T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interfaceLoyc_1_1Collections_1_1IListSource.png" usemap="#Loyc.Collections.IListSource_3C_20out_20out_20T_20_3E_map" alt=""/>
  <map id="Loyc.Collections.IListSource_3C_20out_20out_20T_20_3E_map" name="Loyc.Collections.IListSource&lt; out out T &gt;_map">
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>A read-only list indexed by an integer.</p>
<p>Member list: </p><div class="fragment"><div class="line"><span class="keyword">public</span> IEnumerator&lt;T&gt; GetEnumerator(); <span class="comment">// inherited</span></div><div class="line"><a class="code" href="namespaceSystem.html">System</a>.<a class="code" href="namespaceSystem_1_1Collections.html">Collections</a>.IEnumerator <a class="code" href="namespaceSystem.html">System</a>.<a class="code" href="namespaceSystem_1_1Collections.html">Collections</a>.IEnumerable.GetEnumerator();</div><div class="line"><span class="keyword">public</span> T <span class="keyword">this</span>[<span class="keywordtype">int</span> index] { <span class="keyword">get</span>; }         <span class="comment">// inherited</span></div><div class="line"><span class="keyword">public</span> <span class="keywordtype">int</span> Count { <span class="keyword">get</span>; }                 <span class="comment">// inherited</span></div><div class="line"><span class="keyword">public</span> T <a class="code" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a19a865ed54cfef48cd244d1343ff83b6">TryGet</a>(<span class="keywordtype">int</span> index, out <span class="keywordtype">bool</span> fail);</div><div class="line">IRange&lt;T&gt; <a class="code" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a52cf4d93658771ea9539ed905d2d91bf">Slice</a>(<span class="keywordtype">int</span> start, <span class="keywordtype">int</span> count = <span class="keywordtype">int</span>.MaxValue);</div></div><!-- fragment --><p> The term "source" means a read-only collection, as opposed to a "sink" which is a write-only collection. The purpose of <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html" title="A read-only list indexed by an integer.">IListSource</a> is to support slices, eliminate the need to call <code>Count</code> before reading from the list, and to make it easier to implement a read-only list, by lifting IList's requirement to write implementations for <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9" title="A new item will be added unconditionally, without affecting existing elements, in no particular order...">Add()</a>, <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eea1063e38cb53d94d386f21227fcd84717" title="Remove the item with the specified key if present.">Remove()</a>, etc. A secondary purpose is, of course, to guarantee users don't mistakenly call those methods on a read-only collection. </p>
<p>I have often wanted to access the "next" or "previous" item in a list, e.g. during parsing, but it inconvenient if you have to worry about whether the the current item is the first or last. In that case you must check whether the array index is valid, which is both inconvenient and wasteful, because the list class itself will check the array index a second time, and then the .NET runtime will check the index a third time when reading the internal array. The <code>TryGet(index, defaultValue)</code> extension method can be used to return a default value if the index is not valid, using only one interface call. </p>
<p>Design footnote: I would have preferred to define <code>TryGet</code> with one of these signatures: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a19a865ed54cfef48cd244d1343ff83b6">TryGet</a>(<span class="keywordtype">int</span> index, out T value);</div><div class="line">T? <a class="code" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a19a865ed54cfef48cd244d1343ff83b6">TryGet</a>(<span class="keywordtype">int</span> index);</div><div class="line">Maybe&lt;T&gt; <a class="code" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a19a865ed54cfef48cd244d1343ff83b6">TryGet</a>(<span class="keywordtype">int</span> index);</div></div><!-- fragment --><p> However, these signatures don't allow T to be covariant (<code>out T</code>). The first signature doesn't work because the .NET runtime doesn't distinguish between <code>ref</code> and <code>out</code>, so T could not be covariant. The second signature doesn't work if <code>T</code> is not a value type. The third signature doesn't work because, as a struct, <code><a class="el" href="structLoyc_1_1Maybe.html" title="Same as Nullable&lt;T&gt; except that it behaves like a normal type, i.e. (1) T is allowed to be a referenc...">Maybe</a>&lt;T&gt;</code> is not allowed to be covariant (even though the JIT could, theoretically, treat it covariantly). </p>
<p>Using Impl.ListSourceBase&lt;T&gt; as your base class can help you implement this interface more quickly. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a19a865ed54cfef48cd244d1343ff83b6"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a19a865ed54cfef48cd244d1343ff83b6">TryGet</a> (int index, out bool fail)</td></tr>
<tr class="memdesc:a19a865ed54cfef48cd244d1343ff83b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the item at the specified index, and does not throw an exception on failure. <a href="#a19a865ed54cfef48cd244d1343ff83b6">More...</a><br /></td></tr>
<tr class="separator:a19a865ed54cfef48cd244d1343ff83b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cf4d93658771ea9539ed905d2d91bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a52cf4d93658771ea9539ed905d2d91bf">Slice</a> (int start, int count=int.MaxValue)</td></tr>
<tr class="memdesc:a52cf4d93658771ea9539ed905d2d91bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub-range of this list. <a href="#a52cf4d93658771ea9539ed905d2d91bf">More...</a><br /></td></tr>
<tr class="separator:a52cf4d93658771ea9539ed905d2d91bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a52cf4d93658771ea9539ed905d2d91bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange</a>&lt;T&gt; <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">Loyc.Collections.IListSource</a>&lt; out out T &gt;.Slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em> = <code>int.MaxValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a sub-range of this list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The new range will start at this index in the current list (this location will be index [0] in the new range).</td></tr>
    <tr><td class="paramname">count</td><td>The desired number of elements in the new range, or int.MaxValue to get all elements until the end of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a sub-range of this range.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The start index was below zero.</td></tr>
  </table>
  </dd>
</dl>
<p>The (start, count) range is allowed to be invalid, as long as start is zero or above. </p><ul>
<li>
If count is below zero, or if start is above the original Count, the Count of the new slice is set to zero. </li>
<li>
if (start + count) is above the original Count, the Count of the new slice is reduced to <code>this.Count - start</code>. Implementation note: do not compute (start + count) because it may overflow. Instead, test whether (count &gt; this.Count - start). </li>
</ul>
<p>Most collections should use the following implementation: </p><pre>
<a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html" title="A random-access range, also known as a &quot;slice&quot;. Allows you to narrow down the range like IBRange&lt;T&gt; d...">IRange</a>&lt;T&gt; <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html" title="A read-only list indexed by an integer.">IListSource</a>&lt;T&gt;.<a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a52cf4d93658771ea9539ed905d2d91bf" title="Returns a sub-range of this list.">Slice(int start, int count)</a> { return Slice(start, count); }
public <a class="el" href="structLoyc_1_1Collections_1_1Slice__.html" title="Adapter: a random-access range for a slice of an IListSource&lt;T&gt;.">Slice_</a>&lt;T&gt; <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a52cf4d93658771ea9539ed905d2d91bf" title="Returns a sub-range of this list.">Slice(int start, int count)</a> { return new <a class="el" href="structLoyc_1_1Collections_1_1Slice__.html" title="Adapter: a random-access range for a slice of an IListSource&lt;T&gt;.">Slice_</a>&lt;T&gt;(this, start, count); }
</pre> 
<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalDList.html#abd001ac418a3f8c9a2d8d6009c1c0bc4">Loyc.Collections.Impl.InternalDList&lt; Loyc.Syntax.Lexing.Token &gt;.Add()</a>, <a class="el" href="structLoyc_1_1Collections_1_1ArraySlice.html#a4626fe837161ca320e33ca0d78aa5ea9">Loyc.Collections.ArraySlice&lt; T &gt;.ArraySlice()</a>, <a class="el" href="classLoyc_1_1Collections_1_1ListSourceAsList.html#afd9fb5feaf59db34685b506c5689d9d4">Loyc.Collections.ListSourceAsList&lt; T &gt;.CopyTo()</a>, <a class="el" href="structLoyc_1_1Collections_1_1ListSlice.html#aad31a3b6706c8e23dd5b49acf56ec4a5">Loyc.Collections.ListSlice&lt; LogMessage &gt;.CopyTo()</a>, <a class="el" href="classLoyc_1_1Collections_1_1DList.html#a824584150d60a8f00973769b72960797">Loyc.Collections.DList&lt; Pair&lt; LNode, int &gt; &gt;.CopyTo()</a>, <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a6f78f25d402edaaa1b351da576a0c506">Loyc.Collections.Impl.InternalList&lt; Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt; &gt;.CopyTo()</a>, <a class="el" href="classLoyc_1_1Collections_1_1WListBase.html#a83a225f91ad5480fc8bf65deccd92948">Loyc.Collections.WListBase&lt; T &gt;.CopyTo()</a>, <a class="el" href="structLoyc_1_1Syntax_1_1Lexing_1_1Token.html#aef5489c9124dca77e6b5d963ef08067c">Loyc.Syntax.Lexing.Token.Equals()</a>, <a class="el" href="structLoyc_1_1Collections_1_1ListSlice.html#a9e011514e069577f32dbc7f5cd37c187">Loyc.Collections.ListSlice&lt; LogMessage &gt;.ListSlice()</a>, <a class="el" href="structLoyc_1_1Collections_1_1NegListSlice.html#ae6576e6a2900ed4dbb3a4b070f6bc838">Loyc.Collections.NegListSlice&lt; T &gt;.NegListSlice()</a>, <a class="el" href="structLoyc_1_1Collections_1_1NegListSource.html#a5f56a428023d47bdf2529c81c62b7a06">Loyc.Collections.NegListSource&lt; T &gt;.Slice()</a>, <a class="el" href="structLoyc_1_1Collections_1_1Slice__.html#aec67458b1e7d07d9bd21f9cc261e76c5">Loyc.Collections.Slice_&lt; T &gt;.Slice_()</a>, and <a class="el" href="classLoyc_1_1Collections_1_1AListBase.html#a9501a60988ad7318e8a2a18e598be440">Loyc.Collections.AListBase&lt; K, T &gt;.SwapHelper()</a>.</p>

</div>
</div>
<a class="anchor" id="a19a865ed54cfef48cd244d1343ff83b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">Loyc.Collections.IListSource</a>&lt; out out T &gt;.TryGet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out bool&#160;</td>
          <td class="paramname"><em>fail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the item at the specified index, and does not throw an exception on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An index in the range 0 to Count-1.</td></tr>
    <tr><td class="paramname">fail</td><td>A flag that is set on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at the specified index, or default(T) if the index is not valid.</dd></dl>
<p>In my original design, the caller could provide a value to return on failure, but this would not allow T to be marked as "out" in C# 4. For the same reason, we cannot have a ref/out T parameter. Instead, the following extension methods are provided: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a19a865ed54cfef48cd244d1343ff83b6">TryGet</a>(<span class="keywordtype">int</span> index, ref T value);</div><div class="line">T <a class="code" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a19a865ed54cfef48cd244d1343ff83b6">TryGet</a>(<span class="keywordtype">int</span>, T defaultValue);</div></div><!-- fragment --> 
<p>Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1Les_1_1Les2LanguageService.html#af7d735bee5e606c80ab3db5f779b4291">Loyc.Syntax.Les.Les2LanguageService.Parse()</a>, <a class="el" href="classLoyc_1_1Syntax_1_1Les_1_1Les3LanguageService.html#a834d86bd19ca370868c824675d68fa4c">Loyc.Syntax.Les.Les3LanguageService.Parse()</a>, <a class="el" href="classLoyc_1_1Ecs_1_1EcsLanguageService.html#a3b08b0b1c5b36be49e5a89153bb2b5a9">Loyc.Ecs.EcsLanguageService.Parse()</a>, <a class="el" href="classLoyc_1_1Syntax_1_1ParsingService.html#a1a33fef8bbf5e901a89473b26ad91669">Loyc.Syntax.ParsingService.ParseSingle()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1NegListSource.html#a76cb3bbbf73d0f42c2a6ac3b3542fb0d">Loyc.Collections.NegListSource&lt; T &gt;.TryGet()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 17 2020 22:06:19 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
