<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Enhanced C#: Loyc.Collections.VListBlock&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected fields</a> &#124;
<a href="classLoyc_1_1Collections_1_1VListBlock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.VListBlock&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a> implements the core functionality of <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>, <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>, <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> and <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a>. It is not intended to be used directly.  
 <a href="classLoyc_1_1Collections_1_1VListBlock.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Collections/VLists/VListBlock.cs'>/Core/Loyc.Collections/VLists/VListBlock.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.VListBlock&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLoyc_1_1Collections_1_1VListBlock.png" usemap="#Loyc.Collections.VListBlock_3C_20T_20_3E_map" alt=""/>
  <map id="Loyc.Collections.VListBlock_3C_20T_20_3E_map" name="Loyc.Collections.VListBlock&lt; T &gt;_map">
<area href="classLoyc_1_1Collections_1_1VListBlockArray.html" title="Implementation of VListBlock(of T) that contains an array. It is always initialized with at least one..." alt="Loyc.Collections.VListBlockArray&lt; T &gt;" shape="rect" coords="0,56,237,80"/>
<area href="classLoyc_1_1Collections_1_1VListBlockOfTwo.html" title="The tail of a VList contains only one or two items. To improve efficiency slightly, these two-item lists are represented by a VListBlockOfTwo, which is more compact than VListBlockArray." alt="Loyc.Collections.VListBlockOfTwo&lt; T &gt;" shape="rect" coords="247,56,484,80"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a> implements the core functionality of <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>, <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>, <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> and <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a>. It is not intended to be used directly. </p>
<p><a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> is a persistent list data structure described in Phil Bagwell's 2002 paper "Fast Functional Lists, Hash-Lists, Deques and Variable Length
Arrays". I (David P) call the .NET equivalent "FVList" or "forward VList". In the forward <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>, the "beginning" of the list (index 0) is by far the fastest place to insert items. </p>
<p>This is unnatural in .NET, so I also created a second data structure, the "reverse" <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>, originally called RVList, in which the end of the list (index Count-1) is the natural location for adding items. To achieve this, the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> sees the same elements as a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>, but in reverse order. </p>
<p><a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> and <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a> are the names I picked for the mutable (Writable) variants of <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> and <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>. </p>
<p>A persistent list is a list that is normally considered immutable, so adding an item implies creating a new list rather than changing the one you've got. This is fast because persistent lists have a sort of copy-on-write semantics, so that "copying" a list is a trivial O(1) operation, but modifying a list is sometimes quite inefficient. My implementation of VLists presents a mutable IList(of T) interface, but this is only to adhere to .NET Framework conventions. <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> and <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> are value types that update their own references to the list when they are modified. Thus, "Copying" a list is done with a simple assignment statement. For example: </p><div class="fragment"><div class="line">VList&lt;int&gt; a = <span class="keyword">new</span> VList&lt;int&gt;(), b = <span class="keyword">new</span> VList&lt;int&gt;();</div><div class="line">a.Add(1);</div><div class="line">a.Add(2);</div><div class="line">b = a;             <span class="comment">// copy the list</span></div><div class="line">a.Add(3);          <span class="comment">// a[0] is 1, a[1] is 2, a[2] is 3</span></div><div class="line">b.Add(97);         <span class="comment">// b[0] is 1, b[1] is 2, b[2] is 97</span></div></div><!-- fragment --><p> Traditionally, this kind of behavior was accomplished with singly-linked lists, but <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> does it with (in essence) a singly-linked list of arrays and thereby saves memory while allowing some operations to be done faster than they were done with linked lists. In pathological cases, however, <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> can use much more memory than a linked list and degenerate so that its performance characteristics are almost as bad as a linked list. One major problem that comes to mind is if you keep changing the last item: </p><div class="fragment"><div class="line">VList&lt;int&gt; list = <span class="keyword">new</span> VList&lt;int&gt;();</div><div class="line">... add some items to list ...</div><div class="line">for(<span class="keywordtype">int</span> n;; n++)</div><div class="line">    list[list.Count-1] = n;</div></div><!-- fragment --><p> Unlike, for example, a C++-based <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> implementation, it is impossible for the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> or <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>, which are value types, to know if the list has been "copied" or not. In case the list has been copied, changing any element requires a copy to be made of the <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a> that contains that element, as well as any subsequent blocks (in this example, only the last block must be copied). Thus, the above example produces a lot of garbage very quickly; in fact the rate of garbage production is (very roughly) proportional to the list length. The performance will be equally bad if you repeatedly remove the last item and then re-add it. </p>
<p>Since this kind of problem tends to get worse as the list gets larger, Phil Bagwell proposed using a two- or three-dimentional list arrangement so that no single block could exceed a certain size. I have not implemented that suggestion due to lack of free time and because I did not understand the details of his suggested implementation, but I have placed a size limit of 1024 elements on any given block. Unfortunately, this means that some operations listed below degrade toward O(N) when the list is large, most notably including the indexer, which requires over 1000 iterations to look up element zero in a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> that has one million elements. </p>
<p>Due to the slow performance you get from operations like this, I decided to implement <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a>, a mutable version of the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>, which I'll discuss later. </p>
<p>Similarly to a persistent linked list, </p><ul>
<li>
Adding an item to the front of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> or the end of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> is always O(1) in time, and often O(1) in space (though, unlike a linked list, it may be much more) </li>
<li>
Removing an item from the front of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> or the end of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> is O(1) in time, although space not necessarily reclaimed. </li>
<li>
Adding or removing an item at the end of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> or the front of an <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> is O(N) and requires making a copy of the entire list. </li>
<li>
Inserting or removing a list of M items at the end of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> or the front of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> is O(N + M). </li>
<li>
Changing an item at an arbitrary position should be avoided, as it performs as poorly as inserting or removing an item at that position. </li>
</ul>
<p>VLists, however, offer some operations that singly-linked lists cannot provide efficiently: </p><ul>
<li>
Access by index averages O(1) in ideal conditions </li>
<li>
Getting the list length is typically O(log N), but O(1) in my version </li>
<li>
If a sublist points somewhere within a larger list, its index within the larger list can be obtained in between O(1) and O(log N) time. Consequently, reverse enumeration is possible without creating a temporary stack or list. </li>
</ul>
<p>Also, VLists can (in the best cases) store data almost as compactly as ordinary arrays. </p>
<p>I suspect FVList(of T) and VList(of T) almost always outperforms LinkedList(of T) in both time and space, if you are always adding and removing items at the correct end of the list. And it should perform as well as List(of T) in some situations while providing an illusion of immutability that List(of T) can't. For lists of 0 to 2 items, <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> and <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> use less space than List(of T) (in fact, no object is allocated for an empty <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> or <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>.) </p>
<p>The <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> is built on the same foundation as the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> (a linked list of <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a> objects whose size increases exponentially), but it allows you to modify the list just like List&lt;T&gt;. <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> is a hybrid mutable-immutable data structure: a single list can be partly mutable and partly immutable. More specifically, a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> is conceptually divided into two "halves": the front half is mutable, and the tail half is immutable. The two halves need not be the same size (in fact, very often one half is zero-size). </p>
<p>Because some or all of a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> can be immutable, a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> can be converted to a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a>, or vice versa, in typically O(log N) time. If you modify a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> after calling its ToFVList() method, a portion of the list is first copied into a mutable block and then modified, and this copy operation typically takes O(N) time. </p>
<p><a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a> is like <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> except that new items are added at index Count instead of index zero. The head of a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> is at index 0 and is returned from the First property; the head of an <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a> is at index Count-1 and is returned from the Last property. </p>
<p><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a> implements a single "node" or "sub-array" within a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>. It contains a fixed-size array. When adding a new item to a <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a> that is already full, a new empty <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a> is created (with a larger array), whose _prior reference points to the old <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a>. See Phil Bagwell's paper (or Wikipedia) for details. </p>
<p><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a> adds one new member to the structure Phil Bagwell described, PriorCount, a count of elements in other (smaller) lists to which this list is linked. This makes TotalCount an O(1) operation instead of O(log N), which is necessary so that <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>[i] and <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a>[i] are O(1) on average. </p>
<p>Independent instances of <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>, <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>, <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> and <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a> can be accessed from independent threads even though they may share some of the same memory. Individual instances of these objects, however, are not synchronized. </p>
<p>A few LINQ-style methods like Select and Where are implemented on the four data structures. These are provided to optimize functional code that takes an input list and produces an output list, but might not actually change the list. If all, or the tail, of the output is the same as the output, then the output list will share memory with the input list. </p>
<p>Note that unlike LINQ methods, these methods are greedy. They perform the requested operation immediately, not as-needed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements in the list</td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a2d0e20dd071804020979bbf9f391f494"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a2d0e20dd071804020979bbf9f391f494">IsMutable</a><code> [get]</code></td></tr>
<tr class="memdesc:a2d0e20dd071804020979bbf9f391f494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if part or all of the block is mutable. <a href="#a2d0e20dd071804020979bbf9f391f494">More...</a><br /></td></tr>
<tr class="separator:a2d0e20dd071804020979bbf9f391f494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb4d8a9e1a8956c2a7e2787c2c9d51b"><td class="memItemLeft" align="right" valign="top">abstract int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a8fb4d8a9e1a8956c2a7e2787c2c9d51b">PriorCount</a><code> [get]</code></td></tr>
<tr class="memdesc:a8fb4d8a9e1a8956c2a7e2787c2c9d51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of immutable items in all previous blocks. <a href="#a8fb4d8a9e1a8956c2a7e2787c2c9d51b">More...</a><br /></td></tr>
<tr class="separator:a8fb4d8a9e1a8956c2a7e2787c2c9d51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d182adfa580c9bad2a83ff7f283f638"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a2d182adfa580c9bad2a83ff7f283f638">Prior</a><code> [get]</code></td></tr>
<tr class="memdesc:a2d182adfa580c9bad2a83ff7f283f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> representing the tail of the chain of VListBlocks. <a href="#a2d182adfa580c9bad2a83ff7f283f638">More...</a><br /></td></tr>
<tr class="separator:a2d182adfa580c9bad2a83ff7f283f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addccb8008354ac5f384a5aeeb4292aae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addccb8008354ac5f384a5aeeb4292aae"></a>
<a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PriorBlock</b><code> [get]</code></td></tr>
<tr class="separator:addccb8008354ac5f384a5aeeb4292aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af463776794eda5255e20c7c2fafe1d1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#af463776794eda5255e20c7c2fafe1d1b">PriorIsOwned</a><code> [get]</code></td></tr>
<tr class="memdesc:af463776794eda5255e20c7c2fafe1d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this block has exclusive ownership of mutable items in the prior block. Returns false if the prior block is entirely immutable, if we don't have ownership, or if there is no prior block. <a href="#af463776794eda5255e20c7c2fafe1d1b">More...</a><br /></td></tr>
<tr class="separator:af463776794eda5255e20c7c2fafe1d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bc940741d25d07658612451c536999"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#ab0bc940741d25d07658612451c536999">ImmCount</a><code> [get]</code></td></tr>
<tr class="memdesc:ab0bc940741d25d07658612451c536999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of immutable elements in-use in our local array. <a href="#ab0bc940741d25d07658612451c536999">More...</a><br /></td></tr>
<tr class="separator:ab0bc940741d25d07658612451c536999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b1b97c42810868da1509858ba1b6f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a67b1b97c42810868da1509858ba1b6f1">TotalCount</a><code> [get]</code></td></tr>
<tr class="memdesc:a67b1b97c42810868da1509858ba1b6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of immutable elements in-use in the entire chain <a href="#a67b1b97c42810868da1509858ba1b6f1">More...</a><br /></td></tr>
<tr class="separator:a67b1b97c42810868da1509858ba1b6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdf1a2c6f51876cfece605688c7350f"><td class="memItemLeft" align="right" valign="top">abstract int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a1bdf1a2c6f51876cfece605688c7350f">Capacity</a><code> [get]</code></td></tr>
<tr class="memdesc:a1bdf1a2c6f51876cfece605688c7350f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements in this block <a href="#a1bdf1a2c6f51876cfece605688c7350f">More...</a><br /></td></tr>
<tr class="separator:a1bdf1a2c6f51876cfece605688c7350f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dba15afaf79204759b1d66bc1df1302"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a5dba15afaf79204759b1d66bc1df1302">this[int localIndex]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a5dba15afaf79204759b1d66bc1df1302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets/sets the specified value at the specified index of this block's array, or, if localIndex is negative, searches recursively in previous blocks for the desired index. <a href="#a5dba15afaf79204759b1d66bc1df1302">More...</a><br /></td></tr>
<tr class="separator:a5dba15afaf79204759b1d66bc1df1302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbb65c85d15521452fe85788c172b16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadbb65c85d15521452fe85788c172b16"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ChainLength</b><code> [get]</code></td></tr>
<tr class="separator:aadbb65c85d15521452fe85788c172b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab262e8194c472063d7c5676d50b43f53"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#ab262e8194c472063d7c5676d50b43f53">FGet</a> (int index, int localCount)</td></tr>
<tr class="memdesc:ab262e8194c472063d7c5676d50b43f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an item at distance 'index' from the front (beginning of an <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>) <a href="#ab262e8194c472063d7c5676d50b43f53">More...</a><br /></td></tr>
<tr class="separator:ab262e8194c472063d7c5676d50b43f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6baf3395a1bc8dc07b68a24675862eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6baf3395a1bc8dc07b68a24675862eb"></a>
abstract bool&#160;</td><td class="memItemRight" valign="bottom"><b>FGet</b> (int index, int localCount, ref T value)</td></tr>
<tr class="separator:af6baf3395a1bc8dc07b68a24675862eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17c5164b37d0b8ddeacb8433b07ae78"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#ad17c5164b37d0b8ddeacb8433b07ae78">RGet</a> (int index, int localCount)</td></tr>
<tr class="memdesc:ad17c5164b37d0b8ddeacb8433b07ae78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an item at distance 'index' from the back (beginning of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>) <a href="#ad17c5164b37d0b8ddeacb8433b07ae78">More...</a><br /></td></tr>
<tr class="separator:ad17c5164b37d0b8ddeacb8433b07ae78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8000708f5618a4d1478ac30a5c75b63c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8000708f5618a4d1478ac30a5c75b63c"></a>
abstract bool&#160;</td><td class="memItemRight" valign="bottom"><b>RGet</b> (int index, int localCount, ref T value)</td></tr>
<tr class="separator:a8000708f5618a4d1478ac30a5c75b63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0064a76e0a690cb2e44d4592c40115c7"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a0064a76e0a690cb2e44d4592c40115c7">Add</a> (int localCount, T item)</td></tr>
<tr class="memdesc:a0064a76e0a690cb2e44d4592c40115c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new item at the "front" of a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> where localCount is the number of items currently in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block.  <a href="#a0064a76e0a690cb2e44d4592c40115c7">More...</a><br /></td></tr>
<tr class="separator:a0064a76e0a690cb2e44d4592c40115c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a6add3e90d18153d660b51b77da6c6"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#ad3a6add3e90d18153d660b51b77da6c6">SubList</a> (int localIndex)</td></tr>
<tr class="memdesc:ad3a6add3e90d18153d660b51b77da6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list in which this[localIndex-1] is the first item. Nonpositive indexes are allowed and refer to prior lists; SubList returns an empty list if localIndex is so low that it goes past the back of the list.  <a href="#ad3a6add3e90d18153d660b51b77da6c6">More...</a><br /></td></tr>
<tr class="separator:ad3a6add3e90d18153d660b51b77da6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa341816e5757a142512bccc887c1a80d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#aa341816e5757a142512bccc887c1a80d">ReplaceAt</a> (int localCount, T item, int distanceFromFront)</td></tr>
<tr class="memdesc:aa341816e5757a142512bccc887c1a80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces an item in a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> with another, where localCount is the number of items in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block and distanceFromFront is the element index to replace (0=front).  <a href="#aa341816e5757a142512bccc887c1a80d">More...</a><br /></td></tr>
<tr class="separator:aa341816e5757a142512bccc887c1a80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728ab5ddd32c58fd51272e1f018b3b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a728ab5ddd32c58fd51272e1f018b3b91">RemoveAt</a> (int localCount, int distanceFromFront)</td></tr>
<tr class="memdesc:a728ab5ddd32c58fd51272e1f018b3b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified number of items from a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> where localCount is the number of items in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block, distanceFromFront is the first removal position (minimum 0) and count is the number of items to remove. Of course, the terminology used here is to be understood in the context of a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> (in which items are inserted at the front of the list).  <a href="#a728ab5ddd32c58fd51272e1f018b3b91">More...</a><br /></td></tr>
<tr class="separator:a728ab5ddd32c58fd51272e1f018b3b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17c0d5f329010962f4b9087a48ecbc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae17c0d5f329010962f4b9087a48ecbc6"></a>
<a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveRange</b> (int localCount, int distanceFromFront, int count)</td></tr>
<tr class="separator:ae17c0d5f329010962f4b9087a48ecbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786c68e77ff95b433c00a470612cea29"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a786c68e77ff95b433c00a470612cea29">MuClear</a> (int localCountWithMutables)</td></tr>
<tr class="memdesc:a786c68e77ff95b433c00a470612cea29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all mutable items in this chain, and clears the mutable flag. If this block owns mutable items in prior blocks, they are cleared too. <a href="#a786c68e77ff95b433c00a470612cea29">More...</a><br /></td></tr>
<tr class="separator:a786c68e77ff95b433c00a470612cea29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8058c3c6e74a5ddeb0de9a170cf3cc16"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a8058c3c6e74a5ddeb0de9a170cf3cc16">Front</a> (int localCount)</td></tr>
<tr class="memdesc:a8058c3c6e74a5ddeb0de9a170cf3cc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "front" item in a FVList/FWList associated with this block (or back item of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>) where localCount is the number of items in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block.  <a href="#a8058c3c6e74a5ddeb0de9a170cf3cc16">More...</a><br /></td></tr>
<tr class="separator:a8058c3c6e74a5ddeb0de9a170cf3cc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c283e724357c3ded5ddba8160f3d7dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c283e724357c3ded5ddba8160f3d7dd"></a>
virtual <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Where</b> (int _localCount, Func&lt; T, bool &gt; filter, <a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; forWList)</td></tr>
<tr class="separator:a5c283e724357c3ded5ddba8160f3d7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f45d0c4e28cfabee3bef45177de504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4f45d0c4e28cfabee3bef45177de504"></a>
virtual <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SelectMany</b> (int _localCount, Func&lt; T, IList&lt; T &gt;&gt; map, bool isRList, <a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; forWList)</td></tr>
<tr class="separator:ab4f45d0c4e28cfabee3bef45177de504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14bc17ad3c7666912d996616c12bacd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af14bc17ad3c7666912d996616c12bacd"></a>
virtual <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SmartSelect</b> (int _localCount, Func&lt; T, T &gt; map, <a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; forWList)</td></tr>
<tr class="separator:af14bc17ad3c7666912d996616c12bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6b98aa7b684188d87eb159a487c99a65"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a6b98aa7b684188d87eb159a487c99a65">Add</a> (<a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt; self, int localCount, T item)</td></tr>
<tr class="memdesc:a6b98aa7b684188d87eb159a487c99a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the "front" of an immutable <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>. <a href="#a6b98aa7b684188d87eb159a487c99a65">More...</a><br /></td></tr>
<tr class="separator:a6b98aa7b684188d87eb159a487c99a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c21771a402d6e06fa0c70fd4e5761f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c21771a402d6e06fa0c70fd4e5761f9"></a>
static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SubList</b> (<a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt; self, int localCount, int offset)</td></tr>
<tr class="separator:a6c21771a402d6e06fa0c70fd4e5761f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecf16157cd6b0ac57389200b3d4ddc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ecf16157cd6b0ac57389200b3d4ddc9"></a>
static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TailOf</b> (<a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt; list)</td></tr>
<tr class="separator:a7ecf16157cd6b0ac57389200b3d4ddc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d8bb74c5651e4ccf82fbedafca35f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a25d8bb74c5651e4ccf82fbedafca35f3">Insert</a> (<a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt; self, int localCount, T item, int distanceFromFront)</td></tr>
<tr class="memdesc:a25d8bb74c5651e4ccf82fbedafca35f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new item in a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> where localCount is the number of items in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block and distanceFromFront is the insertion position (0=front).  <a href="#a25d8bb74c5651e4ccf82fbedafca35f3">More...</a><br /></td></tr>
<tr class="separator:a25d8bb74c5651e4ccf82fbedafca35f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5cc060806dd8ad69f7bd678137de4d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#abd5cc060806dd8ad69f7bd678137de4d">InsertRange</a> (<a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt; self, int localCount, IList&lt; T &gt; items, int distanceFromFront, bool isRVList)</td></tr>
<tr class="memdesc:abd5cc060806dd8ad69f7bd678137de4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a list of items in the middle of a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>, where localCount is the number of items in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block and distanceFromFront is the insertion position (0=front).  <a href="#abd5cc060806dd8ad69f7bd678137de4d">More...</a><br /></td></tr>
<tr class="separator:abd5cc060806dd8ad69f7bd678137de4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d70df73f23e8695e5b0810368e8073a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a7d70df73f23e8695e5b0810368e8073a">AddRange</a> (<a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt; self, int localCount, IEnumerator&lt; T &gt; items)</td></tr>
<tr class="memdesc:a7d70df73f23e8695e5b0810368e8073a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a list of items to an immutable <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> (not a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>). <a href="#a7d70df73f23e8695e5b0810368e8073a">More...</a><br /></td></tr>
<tr class="separator:a7d70df73f23e8695e5b0810368e8073a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4defe27114f0c15484817b4afac04e72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a4defe27114f0c15484817b4afac04e72">AddRange</a> (<a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt; self, int localCount, IList&lt; T &gt; items, bool isRVList)</td></tr>
<tr class="memdesc:a4defe27114f0c15484817b4afac04e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a list of items to an immutable <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>. <a href="#a4defe27114f0c15484817b4afac04e72">More...</a><br /></td></tr>
<tr class="separator:a4defe27114f0c15484817b4afac04e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7e8a64c57b78e58573a0e5ec0b3c2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#aef7e8a64c57b78e58573a0e5ec0b3c2e">AddRange</a> (<a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt; self, int localCount, <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt; front, <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt; back)</td></tr>
<tr class="memdesc:aef7e8a64c57b78e58573a0e5ec0b3c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a range of items to a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> where localCount is the number of items in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block, front points to the beginning of the range to add and back points to the end of the range.  <a href="#aef7e8a64c57b78e58573a0e5ec0b3c2e">More...</a><br /></td></tr>
<tr class="separator:aef7e8a64c57b78e58573a0e5ec0b3c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f289aee67d4b75a35b10e5d8a14ef1a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a8f289aee67d4b75a35b10e5d8a14ef1a">FindNextBlock</a> (ref <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt; subList, <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt; list, out int localCountOfSubList)</td></tr>
<tr class="memdesc:a8f289aee67d4b75a35b10e5d8a14ef1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the block that comes before 'subList' in the direction of the larger list, 'list'.  <a href="#a8f289aee67d4b75a35b10e5d8a14ef1a">More...</a><br /></td></tr>
<tr class="separator:a8f289aee67d4b75a35b10e5d8a14ef1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d27060b917570a5bba5f85b437ed50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70d27060b917570a5bba5f85b437ed50"></a>
static <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FindNextBlock</b> (ref <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; subList, <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list, out int localCountOfSubList)</td></tr>
<tr class="separator:a70d27060b917570a5bba5f85b437ed50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7617036d10a5eb9bfcf2aa0bc98add"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a7617036d10a5eb9bfcf2aa0bc98add"></a>
static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BackUpOnce</b> (<a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt; subList, <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt; list)</td></tr>
<tr class="separator:a6a7617036d10a5eb9bfcf2aa0bc98add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af045098188b8f54e070ec458aba3d6b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af045098188b8f54e070ec458aba3d6b0"></a>
static <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BackUpOnce</b> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; subList, <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list)</td></tr>
<tr class="separator:af045098188b8f54e070ec458aba3d6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c51be7a71c9b0ce5afe1d23005ba43"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a70c51be7a71c9b0ce5afe1d23005ba43">EnsureImmutable</a> (<a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt; self, int localCount)</td></tr>
<tr class="memdesc:a70c51be7a71c9b0ce5afe1d23005ba43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an immutable <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> with the specified parameters, modifying blocks if necessary. <a href="#a70c51be7a71c9b0ce5afe1d23005ba43">More...</a><br /></td></tr>
<tr class="separator:a70c51be7a71c9b0ce5afe1d23005ba43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332d4f58527a64091468f82d86503152"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a332d4f58527a64091468f82d86503152">EnsureMutable</a> (<a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; w, int mutablesNeeded)</td></tr>
<tr class="memdesc:a332d4f58527a64091468f82d86503152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that at least the specified number of items at the front of a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> or <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a> are mutable and owned by the list. <a href="#a332d4f58527a64091468f82d86503152">More...</a><br /></td></tr>
<tr class="separator:a332d4f58527a64091468f82d86503152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a01a84b7d5f2b0d84969b6314430ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4a01a84b7d5f2b0d84969b6314430ff"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>MutableCount</b> (<a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; w)</td></tr>
<tr class="separator:aa4a01a84b7d5f2b0d84969b6314430ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b1428ea18a01cca173578cd20621db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09b1428ea18a01cca173578cd20621db"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MuAdd</b> (<a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; w, T item)</td></tr>
<tr class="separator:a09b1428ea18a01cca173578cd20621db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27617d8659a3a8f4242913819cf60d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae27617d8659a3a8f4242913819cf60d0"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MuAddEmpty</b> (<a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; w, int count)</td></tr>
<tr class="separator:ae27617d8659a3a8f4242913819cf60d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af727c41569808c2e6d6d7da56587d923"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#af727c41569808c2e6d6d7da56587d923">MuAddEmpty</a> (<a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; w, int count, int newBlockSizeLimit)</td></tr>
<tr class="memdesc:af727c41569808c2e6d6d7da56587d923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds empty item(s) to the front of the list. <a href="#af727c41569808c2e6d6d7da56587d923">More...</a><br /></td></tr>
<tr class="separator:af727c41569808c2e6d6d7da56587d923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1c7846171aa7fdf4581c5de7b55c00"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#afb1c7846171aa7fdf4581c5de7b55c00">MuMove</a> (<a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; w, int dffFrom, int dffTo, int count)</td></tr>
<tr class="memdesc:afb1c7846171aa7fdf4581c5de7b55c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a series of elements from one location to another in a mutable block. <a href="#afb1c7846171aa7fdf4581c5de7b55c00">More...</a><br /></td></tr>
<tr class="separator:afb1c7846171aa7fdf4581c5de7b55c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba35553b64ed290b3f3a518b4e259378"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba35553b64ed290b3f3a518b4e259378"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MuRemoveFront</b> (<a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; w, int count)</td></tr>
<tr class="separator:aba35553b64ed290b3f3a518b4e259378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23667ab1b986e42c8b12829562dd001f"><td class="memItemLeft" align="right" valign="top">static T[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a23667ab1b986e42c8b12829562dd001f">ToArray</a> (<a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt; self, int localCount, bool isRList)</td></tr>
<tr class="memdesc:a23667ab1b986e42c8b12829562dd001f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any kind of <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> to an array, quickly. <a href="#a23667ab1b986e42c8b12829562dd001f">More...</a><br /></td></tr>
<tr class="separator:a23667ab1b986e42c8b12829562dd001f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af613016ac9ecb1f638d1acbc00d40e83"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#af613016ac9ecb1f638d1acbc00d40e83">Transform</a> (<a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt; _block, int _localCount, VListTransformer&lt; T &gt; x, bool isRList, <a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; forWList)</td></tr>
<tr class="memdesc:af613016ac9ecb1f638d1acbc00d40e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a list (combines filtering with selection and more). <a href="#af613016ac9ecb1f638d1acbc00d40e83">More...</a><br /></td></tr>
<tr class="separator:af613016ac9ecb1f638d1acbc00d40e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4f4bb9dbe2d76b70a4e6664f2098884c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a4f4bb9dbe2d76b70a4e6664f2098884c">AddRange</a> (<a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt; front, <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt; back)</td></tr>
<tr class="memdesc:a4f4bb9dbe2d76b70a4e6664f2098884c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a range of items to the "front" of this block. <a href="#a4f4bb9dbe2d76b70a4e6664f2098884c">More...</a><br /></td></tr>
<tr class="separator:a4f4bb9dbe2d76b70a4e6664f2098884c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96c677619f18ac86c59e94b7dce64a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad96c677619f18ac86c59e94b7dce64a2"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MuAddEmpty2</b> (<a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; w, int count, int newBlockSizeLimit)</td></tr>
<tr class="separator:ad96c677619f18ac86c59e94b7dce64a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a3d92a31f38467cd3daa1d1abb17a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5a3d92a31f38467cd3daa1d1abb17a8"></a>
abstract <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BlockToArray</b> (T[] array, int arrayOffset, int localCount, bool isRList)</td></tr>
<tr class="separator:ac5a3d92a31f38467cd3daa1d1abb17a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326e6ed1962c60c1ac3560152f525f12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a326e6ed1962c60c1ac3560152f525f12"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSame</b> (T old, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt; @new)</td></tr>
<tr class="separator:a326e6ed1962c60c1ac3560152f525f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a464cc680d8526766e657ee993c44831c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a464cc680d8526766e657ee993c44831c">MuAllocBlock</a> (<a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; w, int newBlockSizeLimit)</td></tr>
<tr class="memdesc:a464cc680d8526766e657ee993c44831c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by MuAddEmpty to allocate an empty mutable block. <a href="#a464cc680d8526766e657ee993c44831c">More...</a><br /></td></tr>
<tr class="separator:a464cc680d8526766e657ee993c44831c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2dbc252ab5c74bea89307859d2ae0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b2dbc252ab5c74bea89307859d2ae0c"></a>
static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MakeResult</b> (<a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt; _block, int _localCount, <a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; forWList)</td></tr>
<tr class="separator:a6b2dbc252ab5c74bea89307859d2ae0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82be44eec5c846f912770608641aa94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad82be44eec5c846f912770608641aa94"></a>
static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MakeResult</b> (T item, <a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; forWList)</td></tr>
<tr class="separator:ad82be44eec5c846f912770608641aa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57878eb8afa01780b02f323469a2543"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab57878eb8afa01780b02f323469a2543"></a>
static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MakeResult</b> (T _1, T _2, <a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt; forWList)</td></tr>
<tr class="separator:ab57878eb8afa01780b02f323469a2543"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected fields</h2></td></tr>
<tr class="memitem:a959e141487361548360e7b6be59957d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a959e141487361548360e7b6be59957d5">_immCount</a></td></tr>
<tr class="memdesc:a959e141487361548360e7b6be59957d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of immutable elements in our local array, plus a "mutable" flag in bit 30. <a href="#a959e141487361548360e7b6be59957d5">More...</a><br /></td></tr>
<tr class="separator:a959e141487361548360e7b6be59957d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd1bb9e3735b60d076eaa1e619797a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bd1bb9e3735b60d076eaa1e619797a7"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MutableFlag</b> = 0x40000000</td></tr>
<tr class="separator:a2bd1bb9e3735b60d076eaa1e619797a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af67ffa4ad7db603eb3b7790679e658"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5af67ffa4ad7db603eb3b7790679e658"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>ImmCountMask</b> = MutableFlag - 1</td></tr>
<tr class="separator:a5af67ffa4ad7db603eb3b7790679e658"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0064a76e0a690cb2e44d4592c40115c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new item at the "front" of a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> where localCount is the number of items currently in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block. </p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray.html#a59687daadeb64fa757f61f7e67c72fa5">Loyc.Collections.VListBlockArray&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo.html#a70bd823a0e491fc52b8c3b35322b6335">Loyc.Collections.VListBlockOfTwo&lt; T &gt;</a>.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a1fdd1ee9e7d7ab4ebac20749a046f5f9">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Add()</a>, <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#aba55150453b13d7bd2e262bf2fac248c">Loyc.Collections.FVList&lt; T &gt;.Add()</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a4f4bb9dbe2d76b70a4e6664f2098884c">Loyc.Collections.VListBlock&lt; T &gt;.AddRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b98aa7b684188d87eb159a487c99a65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an item to the "front" of an immutable <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>.</p>

</div>
</div>
<a class="anchor" id="a7d70df73f23e8695e5b0810368e8073a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.AddRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerator&lt; T &gt;&#160;</td>
          <td class="paramname"><em>items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a list of items to an immutable <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> (not a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>).</p>
<p>This method is for use by immutable RVLists only.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#aef7e8a64c57b78e58573a0e5ec0b3c2e">Loyc.Collections.VListBlock&lt; T &gt;.AddRange()</a>, <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a060d6f48ababe01b2e32c455c2e25dab">Loyc.Collections.FVList&lt; T &gt;.Equals()</a>, <a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab03b31527812c8eff3e9b2cd8187734b">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Equals()</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a25d8bb74c5651e4ccf82fbedafca35f3">Loyc.Collections.VListBlock&lt; T &gt;.Insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a4defe27114f0c15484817b4afac04e72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.AddRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRVList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a list of items to an immutable <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>.</p>
<p>This method is for use by immutable VLists only.</p>

</div>
</div>
<a class="anchor" id="aef7e8a64c57b78e58573a0e5ec0b3c2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.AddRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>back</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a range of items to a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> where localCount is the number of items in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block, front points to the beginning of the range to add and back points to the end of the range. </p>
<dl class="section return"><dt>Returns</dt><dd>A new list with the specified range added to it.</dd></dl>
<p>back.Front is NOT included in the range (in fact back can be an empty list) but front.Front is included unless front is also empty.</p>
<p>The elements of the range are inserted in "reverse" (from back to front) so that the order of the elements in the range is preserved (adding them front-first to our front would reverse their order). </p>
<p>This method is for use by immutable VLists only.</p>

<p>References <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a7d70df73f23e8695e5b0810368e8073a">Loyc.Collections.VListBlock&lt; T &gt;.AddRange()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a6399dc2254a262ef444a9512cfe11e19">Loyc.Collections.FVList&lt; T &gt;.First</a>.</p>

</div>
</div>
<a class="anchor" id="a4f4bb9dbe2d76b70a4e6664f2098884c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.AddRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>back</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a range of items to the "front" of this block.</p>
<dl class="section return"><dt>Returns</dt><dd>This block, or a new block if a new block had to be allocated.</dd></dl>
<p>This method is for use by immutable VLists only.</p>

<p>References <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a959e141487361548360e7b6be59957d5">Loyc.Collections.VListBlock&lt; T &gt;._immCount</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a0064a76e0a690cb2e44d4592c40115c7">Loyc.Collections.VListBlock&lt; T &gt;.Add()</a>.</p>

</div>
</div>
<a class="anchor" id="a70c51be7a71c9b0ce5afe1d23005ba43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.EnsureImmutable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an immutable <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> with the specified parameters, modifying blocks if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localCount</td><td>Number of items in 'self' that belong to the list that you want to make immutable. Nonpositive values of localCount are allowed and refer to blocks prior to 'self'.</td></tr>
  </table>
  </dd>
</dl>
<p>This method may change self and/or other blocks in the chain so that the returned <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> contains no mutable items.</p>

<p>References <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a959e141487361548360e7b6be59957d5">Loyc.Collections.VListBlock&lt; T &gt;._immCount</a>, <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a2d182adfa580c9bad2a83ff7f283f638">Loyc.Collections.VListBlock&lt; T &gt;.Prior</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#af463776794eda5255e20c7c2fafe1d1b">Loyc.Collections.VListBlock&lt; T &gt;.PriorIsOwned</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1FWList.html#abefded6837658b16ea565fe84baad0c1">Loyc.Collections.FWList&lt; T &gt;.Pop()</a>, <a class="el" href="classLoyc_1_1Collections_1_1WList.html#a962381836b8032710339fc637ab9b79c">Loyc.Collections.WList&lt; Loyc.Syntax.LNode &gt;.Pop()</a>, <a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html#af9aaf453d3bf4af6967cc446fd6e587b">Loyc.Collections.WListProtected&lt; T &gt;.ToFVList()</a>, <a class="el" href="classLoyc_1_1Collections_1_1WList.html#a92943f9ba322f378d55a0f5efb4341a2">Loyc.Collections.WList&lt; Loyc.Syntax.LNode &gt;.ToFWList()</a>, <a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html#a309d2aab8c65f04f866c6bb6e0215931">Loyc.Collections.WListProtected&lt; T &gt;.ToVList()</a>, and <a class="el" href="classLoyc_1_1Collections_1_1FWList.html#a53afb970a3ce5d3f01e23a33aa70efd7">Loyc.Collections.FWList&lt; T &gt;.ToWList()</a>.</p>

</div>
</div>
<a class="anchor" id="a332d4f58527a64091468f82d86503152"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.EnsureMutable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mutablesNeeded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that at least the specified number of items at the front of a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> or <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a> are mutable and owned by the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutablesNeeded</td><td>Number of mutable items required.</td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1FWList.html#a19c26d6f4e9bd3efaec2f428c32bd05c">Loyc.Collections.FWList&lt; T &gt;.AdjustWListIndex()</a>, <a class="el" href="classLoyc_1_1Collections_1_1WList.html#a5950b17f56a2ed2abb65003cb4cf9398">Loyc.Collections.WList&lt; Loyc.Syntax.LNode &gt;.AdjustWListIndex()</a>, <a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html#af5a085654b654cc8ccaa547f9edcae18">Loyc.Collections.WListProtected&lt; T &gt;.IndexOf()</a>, and <a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html#ab5c1e348730258e87324a96592fbb608">Loyc.Collections.WListProtected&lt; T &gt;.SetAt()</a>.</p>

</div>
</div>
<a class="anchor" id="ab262e8194c472063d7c5676d50b43f53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract T <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.FGet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an item at distance 'index' from the front (beginning of an <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>)</p>
<p>FGet and RGet were added as an optimization, to reduce the minimum number of virtual calls from 2 to 1 and to decrease the number of calculations involved in looking up an item.</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray.html#ae3f97e2200b6c1b0cbd88f8b746efe9b">Loyc.Collections.VListBlockArray&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo.html#ab7fce363bba8185746d1878fad018c69">Loyc.Collections.VListBlockOfTwo&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8f289aee67d4b75a35b10e5d8a14ef1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.FindNextBlock </td>
          <td>(</td>
          <td class="paramtype">ref <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>subList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out int&#160;</td>
          <td class="paramname"><em>localCountOfSubList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the block that comes before 'subList' in the direction of the larger list, 'list'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subList</td><td>Sublist of list, or an empty list.</td></tr>
    <tr><td class="paramname">list</td><td>The larger, outer list. Can be an empty list if subList is empty.</td></tr>
    <tr><td class="paramname">localCountOfSubList</td><td>The value of r._block.Prior._localCount where r is the return value, or, if r is empty, the value of list._localCount.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list prior to subList, or an empty block if (1) list and subList are in the same block (2) list._localCount==0 and list._block.Prior is in the same block as subList</dd></dl>
<p>Because of the copy-causing-sharing-failure problem (described in a comment in RVListTests.TestSublistProblem()), FindNextBlock may have to change subList in certain cases so that it really is a sublist of list. Therefore it is a ref argument. </p>

<p>References <a class="el" href="classLoyc_1_1Localize.html#a43de4c76abc8352800a789b371e15a8e">Loyc.Localize.Localized()</a>.</p>

</div>
</div>
<a class="anchor" id="a8058c3c6e74a5ddeb0de9a170cf3cc16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract T <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.Front </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "front" item in a FVList/FWList associated with this block (or back item of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>) where localCount is the number of items in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block. </p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray.html#a9a7a7fd40578adf30d019cf4f90c0533">Loyc.Collections.VListBlockArray&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo.html#a52edeceb732a0b3ed8ee776ae6bdc4ab">Loyc.Collections.VListBlockOfTwo&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a25d8bb74c5651e4ccf82fbedafca35f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.Insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distanceFromFront</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new item in a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> where localCount is the number of items in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block and distanceFromFront is the insertion position (0=front). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>distanceFromFront was out of range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The block resulting from the insert (may or may not be 'this')</dd></dl>
<p>This method is for use by immutable VLists only.</p>

<p>References <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo.html#a70bd823a0e491fc52b8c3b35322b6335">Loyc.Collections.VListBlockOfTwo&lt; T &gt;.Add()</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a7d70df73f23e8695e5b0810368e8073a">Loyc.Collections.VListBlock&lt; T &gt;.AddRange()</a>.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList.html#ac9c80ebfc94685daacd87c4c483aff72">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.IndexOf()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a685d01d82768d13c6b739d6395a883c0">Loyc.Collections.FVList&lt; T &gt;.IndexOf()</a>.</p>

</div>
</div>
<a class="anchor" id="abd5cc060806dd8ad69f7bd678137de4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.InsertRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distanceFromFront</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRVList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a list of items in the middle of a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>, where localCount is the number of items in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block and distanceFromFront is the insertion position (0=front). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isRVList</td><td>Indicates the insertion order. If isRVList==true, the items[0] is inserted first (which is appropriate for a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>), otherwise it is inserted last (which is appropriate for a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>distanceFromFront was out of range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> containing the inserted items.</dd></dl>
<p>This method is for use by immutable VLists only.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a060d6f48ababe01b2e32c455c2e25dab">Loyc.Collections.FVList&lt; T &gt;.Equals()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab03b31527812c8eff3e9b2cd8187734b">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Equals()</a>.</p>

</div>
</div>
<a class="anchor" id="af727c41569808c2e6d6d7da56587d923"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.MuAddEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newBlockSizeLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds empty item(s) to the front of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>List that needs items</td></tr>
    <tr><td class="paramname">count</td><td>Number of items to add</td></tr>
    <tr><td class="paramname">newBlockSizeLimit</td><td>Limit on size of new block(s); normally VListBlockArray.MAX_BLOCK_LEN (this parameter is used by <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a332d4f58527a64091468f82d86503152" title="Ensures that at least the specified number of items at the front of a FWList or WList are mutable and...">EnsureMutable()</a>).</td></tr>
  </table>
  </dd>
</dl>
<p>This method doesn't actually clear the items, because all items that are not in use should already have been set to default(T). </p>

</div>
</div>
<a class="anchor" id="a464cc680d8526766e657ee993c44831c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.MuAllocBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newBlockSizeLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used by MuAddEmpty to allocate an empty mutable block.</p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the new block</dd></dl>
<p>w is changed to point to the new block (w._localCount is set to 0)</p>

</div>
</div>
<a class="anchor" id="a786c68e77ff95b433c00a470612cea29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.MuClear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCountWithMutables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all mutable items in this chain, and clears the mutable flag. If this block owns mutable items in prior blocks, they are cleared too.</p>
<p>Clearing items is unnecessary if ImmCount is zero, as there there are no shared copies and the caller is going to discard the block, so it'll be garbage anyway.</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray.html#af9b352cf90601ad178a7079e801b0b68">Loyc.Collections.VListBlockArray&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo.html#a96d824cfedf7b153d81f87207ee2be43">Loyc.Collections.VListBlockOfTwo&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afb1c7846171aa7fdf4581c5de7b55c00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.MuMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dffFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dffTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves a series of elements from one location to another in a mutable block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>List to modify</td></tr>
    <tr><td class="paramname">dffFrom</td><td>Distance from front of the beginning of the block to move</td></tr>
    <tr><td class="paramname">dffTo</td><td>Distance from front of destination location</td></tr>
    <tr><td class="paramname">count</td><td>Number of elements to copy</td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#ab7eb2243f167627d926419681db9d5cb">Loyc.Collections.FVList&lt; T &gt;.Tail</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html#af5a085654b654cc8ccaa547f9edcae18">Loyc.Collections.WListProtected&lt; T &gt;.IndexOf()</a>.</p>

</div>
</div>
<a class="anchor" id="a728ab5ddd32c58fd51272e1f018b3b91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.RemoveAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distanceFromFront</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the specified number of items from a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> where localCount is the number of items in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block, distanceFromFront is the first removal position (minimum 0) and count is the number of items to remove. Of course, the terminology used here is to be understood in the context of a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> (in which items are inserted at the front of the list). </p>
<dl class="section return"><dt>Returns</dt><dd>The modified list.</dd></dl>
<p>This method is for use by immutable VLists only.</p>

</div>
</div>
<a class="anchor" id="aa341816e5757a142512bccc887c1a80d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.ReplaceAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distanceFromFront</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces an item in a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> with another, where localCount is the number of items in the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>'s first block and distanceFromFront is the element index to replace (0=front). </p>
<dl class="section return"><dt>Returns</dt><dd>The list resulting from the change. Note that this operation is inefficient; it aways allocates a new block.</dd></dl>
<p>This method is for use by immutable VLists only.</p>

<p>References <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a9060ebd876553a443e2ab3f893eb2c47">Loyc.Collections.FVList&lt; T &gt;.Add()</a>.</p>

</div>
</div>
<a class="anchor" id="ad17c5164b37d0b8ddeacb8433b07ae78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract T <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.RGet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an item at distance 'index' from the back (beginning of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>)</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray.html#a830a93478fffed54fcc9d2675866eb4d">Loyc.Collections.VListBlockArray&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo.html#a06aaca8297b68f39815940aadcef1cc8">Loyc.Collections.VListBlockOfTwo&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad3a6add3e90d18153d660b51b77da6c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.SubList </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list in which this[localIndex-1] is the first item. Nonpositive indexes are allowed and refer to prior lists; SubList returns an empty list if localIndex is so low that it goes past the back of the list. </p>
<p>Warning: Normally <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> can only contain a reference to an immutable list, but this method can return a reference that includes mutable items.</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray.html#a8d6c62c2e04ed7cf963f5431c3934220">Loyc.Collections.VListBlockArray&lt; T &gt;</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo.html#a87c0667477f065757d52dbf1535f18a9">Loyc.Collections.VListBlockOfTwo&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a23667ab1b986e42c8b12829562dd001f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T [] <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.ToArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts any kind of <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> to an array, quickly.</p>

<p>References <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a9060ebd876553a443e2ab3f893eb2c47">Loyc.Collections.FVList&lt; T &gt;.Add()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a060d6f48ababe01b2e32c455c2e25dab">Loyc.Collections.FVList&lt; T &gt;.Equals()</a>.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a32c32c209034d4bd151898ad0e89a985">Loyc.Collections.FVList&lt; T &gt;.ToArray()</a>, <a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab1afb6082c7800d527b48570c2b37389">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.ToArray()</a>, <a class="el" href="classLoyc_1_1Collections_1_1FWList.html#a1ebb2435b419e0801adff54da9dd5272">Loyc.Collections.FWList&lt; T &gt;.ToArray()</a>, and <a class="el" href="classLoyc_1_1Collections_1_1WList.html#acf2bc7f2925e73b822de90c2d0e7aafa">Loyc.Collections.WList&lt; Loyc.Syntax.LNode &gt;.ToArray()</a>.</p>

</div>
</div>
<a class="anchor" id="af613016ac9ecb1f638d1acbc00d40e83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.Transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">VListBlock</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_localCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VListTransformer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1WListProtected.html">WListProtected</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>forWList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a list (combines filtering with selection and more).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Method to apply to each item in the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list formed from transforming all items in the list</dd></dl>
<p>See the documentation of <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a00aaff73e8bd2e48b545a53d9dbc8047" title="Transforms a list (combines filtering with selection and more).">FVList.Transform()</a> for more information.</p>

<p>References <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a959e141487361548360e7b6be59957d5">Loyc.Collections.VListBlock&lt; T &gt;._immCount</a>, <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a9060ebd876553a443e2ab3f893eb2c47">Loyc.Collections.FVList&lt; T &gt;.Add()</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a8fb4d8a9e1a8956c2a7e2787c2c9d51b">Loyc.Collections.VListBlock&lt; T &gt;.PriorCount</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1WList.html#a760bbeaaa3e8f0ea14d5c4ae34bfae7c">Loyc.Collections.WList&lt; Loyc.Syntax.LNode &gt;.Transform()</a>, <a class="el" href="classLoyc_1_1Collections_1_1FWList.html#a936b47473d81f06a7d49ee1e53da1f5b">Loyc.Collections.FWList&lt; T &gt;.Transform()</a>, <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Transform()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a00aaff73e8bd2e48b545a53d9dbc8047">Loyc.Collections.FVList&lt; T &gt;.Transform()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a959e141487361548360e7b6be59957d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;._immCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of immutable elements in our local array, plus a "mutable" flag in bit 30.</p>
<p>Aside from the mutable flag, this value only increases, never decreases. </p>
<p>If the some or all of the block is mutable, _immCount bit 30 is set (0x40000000), and the low bits contain the number of immutable items. In that case the total number of items in use, including mutable items, is only known by the <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> or <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a> that encapsulates the block. </p>
<p>The mutable flag is part of this field instead of being a separate flag for two reasons: (1) Saving space. A separate boolean would enlarge the object 4 bytes. (2) High-performance thread safety. Instead of using locks, I use interlocked changes to obtain thread safety. </p>
<p>I don't know how fast or slow .NET locking is, but I assume you can't get faster than a single Interlocked.CompareExchange, so I have designed thread safety around _immCount. </p>
<p>I hate trying to guarantee thread safety because I don't know how to prove correctness. I know that thread safety must be considered for at least the following operations: </p><ul>
<li>
Adding an item at the end of an immutable <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a>: two VLists on different threads may try to add an item to the "front" of the same block at the same time. </li>
<li>
Reserving mutable items in a list: two threads may do this at once, or an immutable <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> may add an item at the same instant. </li>
</ul>
<p>Interlocked.CompareExchange() is used in both cases, which ensures that only one thread succeeds and any threads that fail do not alter the value of the field. </p>
<p>A mutable block can be made immutable again by clearing bit 30. No interlocked exchange is required for this, since any thread that notices bit 30 is set will not attempt to modify this field in the first place. </p>
<p>We need not worry about thread safety in order to obtain the immutable tail of a list (or equivalently, to remove items from the "front") because that operation doesn't make use of this field (Remember, each instance of <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> has its own private _localCount.) Nor do we need to worry about enumerating or modifying an immutable list (the latter is just an illusion, after all). </p>
<p>I have not concerned myself with thread safety when a single <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> instance (whether mutable or immutable) is accessed from multiple threads, because doing so is not supported. It occurs to me, however, that there could be security concerns if untrusted code is given access to any kind of <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a>; e.g. perhaps malicious code could corrupt a <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a> somehow by exploiting lack of thread safety. </p>
<p>Theoretically you shouldn't modify an FWList/WList while it is being enumerated, but the danger is limited to an incorrect sequence of items being returned from the enumerator; a "subList is not within 
list" exception is also possible. </p>
<p>Important things to note: (1) once items are switched from mutable to immutable, they can never be made mutable again, since there is no way to know if any immutable <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> references still exist. (2) mutable items always belong to exactly one <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> or one <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a>, but a <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a> doesn't know what <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> it belongs to. A <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure. ">FWList</a> or <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a> is detached from its <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a> when Clear() is called, making the block immutable again. (3) if not all the items in a <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html" title="VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended t...">VListBlock</a> are mutable, then the Prior list is guaranteed to be immutable. In other words, mutable and immutable items are not interleaved; mutable items are always at the "front" and immutable items are always at the "back" (which is the beginning of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList. ">VList</a> or end of an <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a>). (4) When the mutable flag is set, _immCount appears to be a very large number. Code that uses _immCount directly instead of calling ImmCount is taking advantage of that fact. </p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray.html#a59687daadeb64fa757f61f7e67c72fa5">Loyc.Collections.VListBlockArray&lt; T &gt;.Add()</a>, <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a4f4bb9dbe2d76b70a4e6664f2098884c">Loyc.Collections.VListBlock&lt; T &gt;.AddRange()</a>, <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a70c51be7a71c9b0ce5afe1d23005ba43">Loyc.Collections.VListBlock&lt; T &gt;.EnsureImmutable()</a>, and <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#af613016ac9ecb1f638d1acbc00d40e83">Loyc.Collections.VListBlock&lt; T &gt;.Transform()</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a1bdf1a2c6f51876cfece605688c7350f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract int <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.Capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements in this block</p>

</div>
</div>
<a class="anchor" id="ab0bc940741d25d07658612451c536999"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.ImmCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of immutable elements in-use in our local array.</p>
<p>Mutable items are not included in the count.</p>

</div>
</div>
<a class="anchor" id="a2d0e20dd071804020979bbf9f391f494"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.IsMutable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if part or all of the block is mutable.</p>

</div>
</div>
<a class="anchor" id="a2d182adfa580c9bad2a83ff7f283f638"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt;T&gt; <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.Prior</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> representing the tail of the chain of VListBlocks.</p>
<p>Warning: Normally <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> can only contain a reference to an immutable list, but this property may return a reference to a mutable block if the current block is 100% mutable. Be careful with this value, as <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> is not designed to handle mutable contents!</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a70c51be7a71c9b0ce5afe1d23005ba43">Loyc.Collections.VListBlock&lt; T &gt;.EnsureImmutable()</a>.</p>

</div>
</div>
<a class="anchor" id="a8fb4d8a9e1a8956c2a7e2787c2c9d51b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract int <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.PriorCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of immutable items in all previous blocks.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#af613016ac9ecb1f638d1acbc00d40e83">Loyc.Collections.VListBlock&lt; T &gt;.Transform()</a>.</p>

</div>
</div>
<a class="anchor" id="af463776794eda5255e20c7c2fafe1d1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.PriorIsOwned</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this block has exclusive ownership of mutable items in the prior block. Returns false if the prior block is entirely immutable, if we don't have ownership, or if there is no prior block.</p>
<p>This one's hard to explain without a diagram. Note: since there is no independent flag to indicate ownership, the logic in this property relies on the fact that a new mutable block is never created until the prior block is full; if one creates a new mutable block when there is free space but no mutable items allocated in the prior block, this property returns false because it assumes the free space was reserved by some other <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure. ">WList</a> than the list that owns this block.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html#a70c51be7a71c9b0ce5afe1d23005ba43">Loyc.Collections.VListBlock&lt; T &gt;.EnsureImmutable()</a>.</p>

</div>
</div>
<a class="anchor" id="a5dba15afaf79204759b1d66bc1df1302"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract T <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.this[int localIndex]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets/sets the specified value at the specified index of this block's array, or, if localIndex is negative, searches recursively in previous blocks for the desired index.</p>
<p>A <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure. ">FVList</a> computes localIndex as FVList._localCount-1-index. </p>
<p>FVList/VList is responsible for checking that the user's index is valid and throwing IndexOutOfRangeException if not. </p>
<p>The setter can only be called on mutable indices! </p>

</div>
</div>
<a class="anchor" id="a67b1b97c42810868da1509858ba1b6f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLoyc_1_1Collections_1_1VListBlock.html">Loyc.Collections.VListBlock</a>&lt; T &gt;.TotalCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of immutable elements in-use in the entire chain</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 17 2020 22:06:21 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
