<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Enhanced C#: Loyc.Collections.VList&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Nested classes</a> &#124;
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structLoyc_1_1Collections_1_1VList-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.VList&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a> represents a reference to a reverse-order <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure.">FVList</a>.  
 <a href="structLoyc_1_1Collections_1_1VList.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Collections/VLists/VList.cs'>/Core/Loyc.Collections/VLists/VList.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.VList&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structLoyc_1_1Collections_1_1VList.png" usemap="#Loyc.Collections.VList_3C_20T_20_3E_map" alt=""/>
  <map id="Loyc.Collections.VList_3C_20T_20_3E_map" name="Loyc.Collections.VList_3C_20T_20_3E_map">
<area href="interfaceLoyc_1_1Collections_1_1IListAndListSource.html" title="This interface is to be used by read-only sequences that nevertheless wish to be compatible with APIs..." alt="Loyc.Collections.IListAndListSource&lt; T &gt;" shape="rect" coords="879,168,1162,192"/>
<area href="interfaceLoyc_1_1ICloneable.html" title="Interface for types that can duplicate themselves." alt="Loyc.ICloneable&lt; out out T &gt;" shape="rect" coords="1465,168,1748,192"/>
<area href="interfaceLoyc_1_1Collections_1_1IListAndReadOnly.html" title="This interface is meant to be implemented by read-only sequence classes that originally implemented I..." alt="Loyc.Collections.IListAndReadOnly&lt; T &gt;" shape="rect" coords="439,112,722,136"/>
<area href="interfaceLoyc_1_1Collections_1_1IListSource.html" alt="Loyc.Collections.IListSource&lt; T &gt;" shape="rect" coords="732,112,1015,136"/>
<area href="interfaceLoyc_1_1Collections_1_1ICollectionAndSource.html" title="This interface is to be implemented by read-only sequence types that still want to be compatible with..." alt="Loyc.Collections.ICollectionAndSource&lt; T &gt;" shape="rect" coords="1465,112,1748,136"/>
<area href="interfaceLoyc_1_1Collections_1_1ICollectionAndReadOnly.html" title="This interface is meant to be implemented by read-only sequence types that originally implemented ICo..." alt="Loyc.Collections.ICollectionAndReadOnly&lt; T &gt;" shape="rect" coords="146,56,429,80"/>
<area href="interfaceLoyc_1_1Collections_1_1ICollectionSource.html" title="A variation of IReadOnlyCollection that provides the Contains() and CopyTo() methods from ICollection..." alt="Loyc.Collections.ICollectionSource&lt; T &gt;" shape="rect" coords="1172,56,1455,80"/>
<area href="interfaceLoyc_1_1Collections_1_1ICollectionAndReadOnly.html" title="This interface is meant to be implemented by read-only sequence types that originally implemented ICo..." alt="Loyc.Collections.ICollectionAndReadOnly&lt; T &gt;" shape="rect" coords="1758,56,2041,80"/>
<area href="interfaceLoyc_1_1Collections_1_1IContains.html" alt="Loyc.Collections.IContains&lt; T &gt;" shape="rect" coords="1025,0,1308,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p><a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a> represents a reference to a reverse-order <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure.">FVList</a>. </p>
<p>An <a href="http://www.codeproject.com/Articles/26171/VList-data-structures-in-C">article</a> is available online about the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a> data types. </p>
<p>The <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a> is a persistent list data structure described in Phil Bagwell's 2002 paper "Fast Functional Lists, Hash-Lists, Deques and Variable Length
Arrays". Originally, this type was called RVList because it works in the reverse order to the original <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a> type: new items are normally added at the <em>beginning</em> of a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a>, which is normal in functional languages, but <em>this</em> <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a> acts like a normal .NET list, so it is optimized for new items to be added at the end. The name "RVList" is ugly, though, since it misleadingly appears to be related to Recreational Vehicles. So as of <a class="el" href="namespaceLeMP.html" title="The lexical macro processor. Main classes: LeMP.Compiler and LeMP.MacroProcessor.">LeMP</a> 1.5, it's called simply <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a>. </p>
<p>In contrast, the FVList&lt;T&gt; type acts like the original <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a>; its Add method puts new items at the beginning (index 0). </p>
<p>See the remarks of VListBlock&lt;T&gt; for a more detailed description. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Nested classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_1_1Enumerator.html">Enumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates through a <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a> from index 0 up to index Count-1.  <a href="structLoyc_1_1Collections_1_1VList_1_1Enumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:abc7f0c354f5dd93a19544fb2789457c1"><td class="memItemLeft" align="right" valign="top"><a id="abc7f0c354f5dd93a19544fb2789457c1"></a>
static readonly <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Empty</b> = new <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt;()</td></tr>
<tr class="separator:abc7f0c354f5dd93a19544fb2789457c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a9c25e96b43013e9eee3ac4cf0b974abf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a9c25e96b43013e9eee3ac4cf0b974abf">Tail</a><code> [get]</code></td></tr>
<tr class="memdesc:a9c25e96b43013e9eee3ac4cf0b974abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list without the last item. If the list is empty, an empty list is retured.  <a href="structLoyc_1_1Collections_1_1VList.html#a9c25e96b43013e9eee3ac4cf0b974abf">More...</a><br /></td></tr>
<tr class="separator:a9c25e96b43013e9eee3ac4cf0b974abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab429ef27c6d66520883bc8402d8e7653"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab429ef27c6d66520883bc8402d8e7653">Last</a><code> [get]</code></td></tr>
<tr class="memdesc:ab429ef27c6d66520883bc8402d8e7653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last item of the list (at index Count-1), which is the head of the list.  <a href="structLoyc_1_1Collections_1_1VList.html#ab429ef27c6d66520883bc8402d8e7653">More...</a><br /></td></tr>
<tr class="separator:ab429ef27c6d66520883bc8402d8e7653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9956cbc7b7e2f3a61a8c79f426c7fd16"><td class="memItemLeft" align="right" valign="top"><a id="a9956cbc7b7e2f3a61a8c79f426c7fd16"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsEmpty</b><code> [get]</code></td></tr>
<tr class="separator:a9956cbc7b7e2f3a61a8c79f426c7fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0787076a488ad33cf4b74da25cfebb57"><td class="memItemLeft" align="right" valign="top">int?&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a0787076a488ad33cf4b74da25cfebb57">BlockChainLength</a><code> [get]</code></td></tr>
<tr class="memdesc:a0787076a488ad33cf4b74da25cfebb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of blocks used by this list.  <a href="structLoyc_1_1Collections_1_1VList.html#a0787076a488ad33cf4b74da25cfebb57">More...</a><br /></td></tr>
<tr class="separator:a0787076a488ad33cf4b74da25cfebb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2509357ad130fd1ff4d68ff29dee0e02"><td class="memItemLeft" align="right" valign="top"><a id="a2509357ad130fd1ff4d68ff29dee0e02"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>this[int index]</b><code> [get, set]</code></td></tr>
<tr class="separator:a2509357ad130fd1ff4d68ff29dee0e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55e9bfa5eef58ad18ed164a699a2826"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab55e9bfa5eef58ad18ed164a699a2826">this[int index, T defaultValue]</a><code> [get]</code></td></tr>
<tr class="memdesc:ab55e9bfa5eef58ad18ed164a699a2826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an item from the list at the specified index; returns defaultValue if the index is not valid.  <a href="structLoyc_1_1Collections_1_1VList.html#ab55e9bfa5eef58ad18ed164a699a2826">More...</a><br /></td></tr>
<tr class="separator:ab55e9bfa5eef58ad18ed164a699a2826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006234308f4535503c6967b8c5c854f2"><td class="memItemLeft" align="right" valign="top"><a id="a006234308f4535503c6967b8c5c854f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Count</b><code> [get]</code></td></tr>
<tr class="separator:a006234308f4535503c6967b8c5c854f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50502d8f75972a9293cd6dbff7161e3"><td class="memItemLeft" align="right" valign="top"><a id="ac50502d8f75972a9293cd6dbff7161e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsReadOnly</b><code> [get]</code></td></tr>
<tr class="separator:ac50502d8f75972a9293cd6dbff7161e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5693af4d4b3bd0e56ca7c7f32ce1c306"><td class="memItemLeft" align="right" valign="top"><a id="a5693af4d4b3bd0e56ca7c7f32ce1c306"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (T firstItem)</td></tr>
<tr class="separator:a5693af4d4b3bd0e56ca7c7f32ce1c306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6287c4d9f68723fe1956096accf082ff"><td class="memItemLeft" align="right" valign="top"><a id="a6287c4d9f68723fe1956096accf082ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (T itemZero, T itemOne)</td></tr>
<tr class="separator:a6287c4d9f68723fe1956096accf082ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc48194e27d26b1b5ae4be9eb24449a"><td class="memItemLeft" align="right" valign="top"><a id="a8bc48194e27d26b1b5ae4be9eb24449a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (T[] array)</td></tr>
<tr class="separator:a8bc48194e27d26b1b5ae4be9eb24449a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af0454542f853c16d4232c0b6c5fe76"><td class="memItemLeft" align="right" valign="top"><a id="a1af0454542f853c16d4232c0b6c5fe76"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (IEnumerable&lt; T &gt; list)</td></tr>
<tr class="separator:a1af0454542f853c16d4232c0b6c5fe76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea59126e5d402d669787636120328a2"><td class="memItemLeft" align="right" valign="top"><a id="a5ea59126e5d402d669787636120328a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list)</td></tr>
<tr class="separator:a5ea59126e5d402d669787636120328a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0899349e78497c6ddb833ebad4d1bd08"><td class="memItemLeft" align="right" valign="top"><a id="a0899349e78497c6ddb833ebad4d1bd08"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WithoutLast</b> (int offset)</td></tr>
<tr class="separator:a0899349e78497c6ddb833ebad4d1bd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96940de9beecfbbcab6623faffbb020"><td class="memItemLeft" align="right" valign="top"><a id="ad96940de9beecfbbcab6623faffbb020"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NextIn</b> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; largerList)</td></tr>
<tr class="separator:ad96940de9beecfbbcab6623faffbb020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1dedb0ba93cd276ad45a793b5b1e39"><td class="memItemLeft" align="right" valign="top"><a id="a0f1dedb0ba93cd276ad45a793b5b1e39"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>First</b> (int count)</td></tr>
<tr class="separator:a0f1dedb0ba93cd276ad45a793b5b1e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03b31527812c8eff3e9b2cd8187734b"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab03b31527812c8eff3e9b2cd8187734b">Equals</a> (object rhs_)</td></tr>
<tr class="memdesc:ab03b31527812c8eff3e9b2cd8187734b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two list references are the same. Does not compare the contents of the lists.  <a href="structLoyc_1_1Collections_1_1VList.html#ab03b31527812c8eff3e9b2cd8187734b">More...</a><br /></td></tr>
<tr class="separator:ab03b31527812c8eff3e9b2cd8187734b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3030763f880cb7812641c6f672c0279"><td class="memItemLeft" align="right" valign="top"><a id="ab3030763f880cb7812641c6f672c0279"></a>
override int&#160;</td><td class="memItemRight" valign="bottom"><b>GetHashCode</b> ()</td></tr>
<tr class="separator:ab3030763f880cb7812641c6f672c0279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bf480c11b01b35a8e4794aa1be143f"><td class="memItemLeft" align="right" valign="top"><a id="aa7bf480c11b01b35a8e4794aa1be143f"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list)</td></tr>
<tr class="separator:aa7bf480c11b01b35a8e4794aa1be143f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1e3987e527c215cbb0d00191d79253"><td class="memItemLeft" align="right" valign="top"><a id="afb1e3987e527c215cbb0d00191d79253"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list, <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; excludeSubList)</td></tr>
<tr class="separator:afb1e3987e527c215cbb0d00191d79253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84491e016b4280fadb21a6f194451c7"><td class="memItemLeft" align="right" valign="top"><a id="ae84491e016b4280fadb21a6f194451c7"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (IList&lt; T &gt; list)</td></tr>
<tr class="separator:ae84491e016b4280fadb21a6f194451c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab535df73b58a212cbdd98de0fbbd7d2f"><td class="memItemLeft" align="right" valign="top"><a id="ab535df73b58a212cbdd98de0fbbd7d2f"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (IEnumerable&lt; T &gt; list)</td></tr>
<tr class="separator:ab535df73b58a212cbdd98de0fbbd7d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d36690c919cc215921ab8a26122ff41"><td class="memItemLeft" align="right" valign="top"><a id="a3d36690c919cc215921ab8a26122ff41"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange</b> (int index, IList&lt; T &gt; list)</td></tr>
<tr class="separator:a3d36690c919cc215921ab8a26122ff41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5973a0a7f688b8711bcbb1641f1ff96"><td class="memItemLeft" align="right" valign="top"><a id="ae5973a0a7f688b8711bcbb1641f1ff96"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveRange</b> (int index, int count)</td></tr>
<tr class="separator:ae5973a0a7f688b8711bcbb1641f1ff96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436ad98f6f524870b45ece96733ffcf8"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a436ad98f6f524870b45ece96733ffcf8">Pop</a> ()</td></tr>
<tr class="memdesc:a436ad98f6f524870b45ece96733ffcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last item (at index Count-1) from the list and returns it.  <a href="structLoyc_1_1Collections_1_1VList.html#a436ad98f6f524870b45ece96733ffcf8">More...</a><br /></td></tr>
<tr class="separator:a436ad98f6f524870b45ece96733ffcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb01b7f5cdbb7f1b933fe8a051c19318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#adb01b7f5cdbb7f1b933fe8a051c19318">Push</a> (T item)</td></tr>
<tr class="memdesc:adb01b7f5cdbb7f1b933fe8a051c19318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a2899333f96298ded3387aab12021b349" title="Inserts an item at the back (index Count) of the VList.">Add()</a>; adds an item to the front of the list.  <a href="structLoyc_1_1Collections_1_1VList.html#adb01b7f5cdbb7f1b933fe8a051c19318">More...</a><br /></td></tr>
<tr class="separator:adb01b7f5cdbb7f1b933fe8a051c19318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dbf9520695ec0b6cf4d90993c668c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a95dbf9520695ec0b6cf4d90993c668c1">ToFVList</a> ()</td></tr>
<tr class="memdesc:a95dbf9520695ec0b6cf4d90993c668c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure.">FVList</a>, which effectively reverses the order of the elements.  <a href="structLoyc_1_1Collections_1_1VList.html#a95dbf9520695ec0b6cf4d90993c668c1">More...</a><br /></td></tr>
<tr class="separator:a95dbf9520695ec0b6cf4d90993c668c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4385955fa9d1be7981ddc252d6f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLoyc_1_1Collections_1_1FWList.html">FWList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a49d4385955fa9d1be7981ddc252d6f8e">ToFWList</a> ()</td></tr>
<tr class="memdesc:a49d4385955fa9d1be7981ddc252d6f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure.">FWList</a>, which effectively reverses the order of the elements.  <a href="structLoyc_1_1Collections_1_1VList.html#a49d4385955fa9d1be7981ddc252d6f8e">More...</a><br /></td></tr>
<tr class="separator:a49d4385955fa9d1be7981ddc252d6f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66059b968b4840ebd52c7fb53fd6b1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLoyc_1_1Collections_1_1WList.html">WList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ad66059b968b4840ebd52c7fb53fd6b1e">ToWList</a> ()</td></tr>
<tr class="memdesc:ad66059b968b4840ebd52c7fb53fd6b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as an <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure.">WList</a>.  <a href="structLoyc_1_1Collections_1_1VList.html#ad66059b968b4840ebd52c7fb53fd6b1e">More...</a><br /></td></tr>
<tr class="separator:ad66059b968b4840ebd52c7fb53fd6b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1afb6082c7800d527b48570c2b37389"><td class="memItemLeft" align="right" valign="top">T[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab1afb6082c7800d527b48570c2b37389">ToArray</a> ()</td></tr>
<tr class="memdesc:ab1afb6082c7800d527b48570c2b37389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a> converted to an array.  <a href="structLoyc_1_1Collections_1_1VList.html#ab1afb6082c7800d527b48570c2b37389">More...</a><br /></td></tr>
<tr class="separator:ab1afb6082c7800d527b48570c2b37389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c80ebfc94685daacd87c4c483aff72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ac9c80ebfc94685daacd87c4c483aff72">IndexOf</a> (T item)</td></tr>
<tr class="memdesc:ac9c80ebfc94685daacd87c4c483aff72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the specified object and returns the zero-based index of the first occurrence (lowest index) within the entire <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a>.  <a href="structLoyc_1_1Collections_1_1VList.html#ac9c80ebfc94685daacd87c4c483aff72">More...</a><br /></td></tr>
<tr class="separator:ac9c80ebfc94685daacd87c4c483aff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4290cc3bc5b8af2cb2a017b60879fa2c"><td class="memItemLeft" align="right" valign="top"><a id="a4290cc3bc5b8af2cb2a017b60879fa2c"></a>
<a class="el" href="structLoyc_1_1void.html">void</a> IList&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>Insert</b> (int index, T item)</td></tr>
<tr class="separator:a4290cc3bc5b8af2cb2a017b60879fa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d0f5fc125aa70a87a5a51500f77a52"><td class="memItemLeft" align="right" valign="top"><a id="a14d0f5fc125aa70a87a5a51500f77a52"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Insert</b> (int index, T item)</td></tr>
<tr class="separator:a14d0f5fc125aa70a87a5a51500f77a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19115167d1db0e6e97887e4b55377def"><td class="memItemLeft" align="right" valign="top"><a id="a19115167d1db0e6e97887e4b55377def"></a>
<a class="el" href="structLoyc_1_1void.html">void</a> IList&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt</b> (int index)</td></tr>
<tr class="separator:a19115167d1db0e6e97887e4b55377def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5414401fdf86784dfb8b43d8cf7e4af1"><td class="memItemLeft" align="right" valign="top"><a id="a5414401fdf86784dfb8b43d8cf7e4af1"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt</b> (int index)</td></tr>
<tr class="separator:a5414401fdf86784dfb8b43d8cf7e4af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2899333f96298ded3387aab12021b349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a> ICollection&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a2899333f96298ded3387aab12021b349">Add</a> (T item)</td></tr>
<tr class="memdesc:a2899333f96298ded3387aab12021b349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item at the back (index Count) of the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a>.  <a href="structLoyc_1_1Collections_1_1VList.html#a2899333f96298ded3387aab12021b349">More...</a><br /></td></tr>
<tr class="separator:a2899333f96298ded3387aab12021b349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdd1ee9e7d7ab4ebac20749a046f5f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a1fdd1ee9e7d7ab4ebac20749a046f5f9">Add</a> (T item)</td></tr>
<tr class="memdesc:a1fdd1ee9e7d7ab4ebac20749a046f5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item at the back (index Count) of the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a>.  <a href="structLoyc_1_1Collections_1_1VList.html#a1fdd1ee9e7d7ab4ebac20749a046f5f9">More...</a><br /></td></tr>
<tr class="separator:a1fdd1ee9e7d7ab4ebac20749a046f5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0676836fa05195947074c6e887fdcf"><td class="memItemLeft" align="right" valign="top"><a id="a6e0676836fa05195947074c6e887fdcf"></a>
<a class="el" href="structLoyc_1_1void.html">void</a> ICollection&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>Clear</b> ()</td></tr>
<tr class="separator:a6e0676836fa05195947074c6e887fdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dc2d69cd93de24d0e548622684578a"><td class="memItemLeft" align="right" valign="top"><a id="a56dc2d69cd93de24d0e548622684578a"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Clear</b> ()</td></tr>
<tr class="separator:a56dc2d69cd93de24d0e548622684578a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664b39c0a7a4a4aafb61a0a24e1e45a9"><td class="memItemLeft" align="right" valign="top"><a id="a664b39c0a7a4a4aafb61a0a24e1e45a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Contains</b> (T item)</td></tr>
<tr class="separator:a664b39c0a7a4a4aafb61a0a24e1e45a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8364d8d0aa2632224c542d63f1a75ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a8364d8d0aa2632224c542d63f1a75ad8">CopyTo</a> (T[] array, int arrayIndex)</td></tr>
<tr class="memdesc:a8364d8d0aa2632224c542d63f1a75ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements of the collection to an Array, starting at a particular array index.  <a href="structLoyc_1_1Collections_1_1VList.html#a8364d8d0aa2632224c542d63f1a75ad8">More...</a><br /></td></tr>
<tr class="separator:a8364d8d0aa2632224c542d63f1a75ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6bdb8ef56811f23148a205597402c1"><td class="memItemLeft" align="right" valign="top"><a id="a2c6bdb8ef56811f23148a205597402c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Remove</b> (T item)</td></tr>
<tr class="separator:a2c6bdb8ef56811f23148a205597402c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dfe871f006cd1e207666a48b5a8539"><td class="memItemLeft" align="right" valign="top"><a id="a02dfe871f006cd1e207666a48b5a8539"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList_1_1Enumerator.html">Enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a02dfe871f006cd1e207666a48b5a8539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa5901c96c9e13a2ffcca24862c3294"><td class="memItemLeft" align="right" valign="top"><a id="a9fa5901c96c9e13a2ffcca24862c3294"></a>
IEnumerator&lt; T &gt; IEnumerable&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a9fa5901c96c9e13a2ffcca24862c3294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2882c1acee7b83d59e53425194038761"><td class="memItemLeft" align="right" valign="top"><a id="a2882c1acee7b83d59e53425194038761"></a>
System.Collections.IEnumerator System.Collections.IEnumerable.&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a2882c1acee7b83d59e53425194038761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d397c93e83cadbc2b4a9b63838bff3"><td class="memItemLeft" align="right" valign="top"><a id="a43d397c93e83cadbc2b4a9b63838bff3"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>TryGet</b> (int index, out bool fail)</td></tr>
<tr class="separator:a43d397c93e83cadbc2b4a9b63838bff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b073e9a68a581e95ef5214558a96eb4"><td class="memItemLeft" align="right" valign="top"><a id="a3b073e9a68a581e95ef5214558a96eb4"></a>
<a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange</a>&lt; T &gt; <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">IListSource</a>&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>Slice</b> (int start, int count)</td></tr>
<tr class="separator:a3b073e9a68a581e95ef5214558a96eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f7386cfc2ca334af863b0a4144db35"><td class="memItemLeft" align="right" valign="top"><a id="aa1f7386cfc2ca334af863b0a4144db35"></a>
<a class="el" href="structLoyc_1_1Collections_1_1Slice__.html">Slice_</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Slice</b> (int start, int count=int.MaxValue)</td></tr>
<tr class="separator:aa1f7386cfc2ca334af863b0a4144db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f8a9a57799a100c0f92d765b047175"><td class="memItemLeft" align="right" valign="top"><a id="a94f8a9a57799a100c0f92d765b047175"></a>
<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Clone</b> ()</td></tr>
<tr class="separator:a94f8a9a57799a100c0f92d765b047175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3da7a26a9b10f031b9c5f27f34bf3c"><td class="memItemLeft" align="right" valign="top"><a id="a2b3da7a26a9b10f031b9c5f27f34bf3c"></a>
object ICloneable.&#160;</td><td class="memItemRight" valign="bottom"><b>Clone</b> ()</td></tr>
<tr class="separator:a2b3da7a26a9b10f031b9c5f27f34bf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866e9f0ea9f9c84da69cd5b567aa78a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a866e9f0ea9f9c84da69cd5b567aa78a4">SmartWhere</a> (Func&lt; T, bool &gt; keep)</td></tr>
<tr class="memdesc:a866e9f0ea9f9c84da69cd5b567aa78a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a filter to a list, to exclude zero or more items.  <a href="structLoyc_1_1Collections_1_1VList.html#a866e9f0ea9f9c84da69cd5b567aa78a4">More...</a><br /></td></tr>
<tr class="separator:a866e9f0ea9f9c84da69cd5b567aa78a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3751829c3359ff56319fe6d93b6be40a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a3751829c3359ff56319fe6d93b6be40a">WhereSelect</a> (Func&lt; T, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt;&gt; filter)</td></tr>
<tr class="memdesc:a3751829c3359ff56319fe6d93b6be40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters and maps a list with a user-defined function.  <a href="structLoyc_1_1Collections_1_1VList.html#a3751829c3359ff56319fe6d93b6be40a">More...</a><br /></td></tr>
<tr class="separator:a3751829c3359ff56319fe6d93b6be40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67946c8c8878afaa9f282b37849a0769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a67946c8c8878afaa9f282b37849a0769">SmartSelect</a> (Func&lt; T, T &gt; map)</td></tr>
<tr class="memdesc:a67946c8c8878afaa9f282b37849a0769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list to another list of the same length.  <a href="structLoyc_1_1Collections_1_1VList.html#a67946c8c8878afaa9f282b37849a0769">More...</a><br /></td></tr>
<tr class="separator:a67946c8c8878afaa9f282b37849a0769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2e8766cb1c2ceeab21158402330c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#acd2e8766cb1c2ceeab21158402330c57">SmartSelectMany</a> (Func&lt; T, IList&lt; T &gt;&gt; map)</td></tr>
<tr class="memdesc:acd2e8766cb1c2ceeab21158402330c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list to another list by concatenating the outputs of a mapping function.  <a href="structLoyc_1_1Collections_1_1VList.html#acd2e8766cb1c2ceeab21158402330c57">More...</a><br /></td></tr>
<tr class="separator:acd2e8766cb1c2ceeab21158402330c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ff56cf4b4c97f4449e1ccb4bfcd1c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Transform</a> (VListTransformer&lt; T &gt; x)</td></tr>
<tr class="memdesc:a97ff56cf4b4c97f4449e1ccb4bfcd1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a list (combines filtering with selection and more).  <a href="structLoyc_1_1Collections_1_1VList.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">More...</a><br /></td></tr>
<tr class="separator:a97ff56cf4b4c97f4449e1ccb4bfcd1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interfaceLoyc_1_1Collections_1_1IListSource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">Loyc.Collections.IListSource&lt; T &gt;</a></td></tr>
<tr class="memitem:a19a865ed54cfef48cd244d1343ff83b6 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a19a865ed54cfef48cd244d1343ff83b6">TryGet</a> (int index, out bool fail)</td></tr>
<tr class="memdesc:a19a865ed54cfef48cd244d1343ff83b6 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the item at the specified index, and does not throw an exception on failure.  <a href="interfaceLoyc_1_1Collections_1_1IListSource.html#a19a865ed54cfef48cd244d1343ff83b6">More...</a><br /></td></tr>
<tr class="separator:a19a865ed54cfef48cd244d1343ff83b6 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cf4d93658771ea9539ed905d2d91bf inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a52cf4d93658771ea9539ed905d2d91bf">Slice</a> (int start, int count=int.MaxValue)</td></tr>
<tr class="memdesc:a52cf4d93658771ea9539ed905d2d91bf inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub-range of this list.  <a href="interfaceLoyc_1_1Collections_1_1IListSource.html#a52cf4d93658771ea9539ed905d2d91bf">More...</a><br /></td></tr>
<tr class="separator:a52cf4d93658771ea9539ed905d2d91bf inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interfaceLoyc_1_1Collections_1_1IContains"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interfaceLoyc_1_1Collections_1_1IContains')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interfaceLoyc_1_1Collections_1_1IContains.html">Loyc.Collections.IContains&lt; T &gt;</a></td></tr>
<tr class="memitem:af18fb028bdd55ed86fdebf069622e491 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IContains"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IContains.html#af18fb028bdd55ed86fdebf069622e491">Contains</a> (T item)</td></tr>
<tr class="memdesc:af18fb028bdd55ed86fdebf069622e491 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IContains"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the collection contains the specified item.  <a href="interfaceLoyc_1_1Collections_1_1IContains.html#af18fb028bdd55ed86fdebf069622e491">More...</a><br /></td></tr>
<tr class="separator:af18fb028bdd55ed86fdebf069622e491 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IContains"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a629e2c08d382f795462be991062f2709"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a629e2c08d382f795462be991062f2709">operator==</a> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; lhs, <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; rhs)</td></tr>
<tr class="memdesc:a629e2c08d382f795462be991062f2709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two list references are the same. Does not compare the contents of the lists.  <a href="structLoyc_1_1Collections_1_1VList.html#a629e2c08d382f795462be991062f2709">More...</a><br /></td></tr>
<tr class="separator:a629e2c08d382f795462be991062f2709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c3c67c05c68deaf8f9f80243bcd494"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#aa9c3c67c05c68deaf8f9f80243bcd494">operator!=</a> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; lhs, <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; rhs)</td></tr>
<tr class="memdesc:aa9c3c67c05c68deaf8f9f80243bcd494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two list references are different. Does not compare the contents of the lists.  <a href="structLoyc_1_1Collections_1_1VList.html#aa9c3c67c05c68deaf8f9f80243bcd494">More...</a><br /></td></tr>
<tr class="separator:aa9c3c67c05c68deaf8f9f80243bcd494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7bf6afcf7052a323ca885cde5aebc9"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#aae7bf6afcf7052a323ca885cde5aebc9">operator FVList&lt; T &gt;</a> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list)</td></tr>
<tr class="memdesc:aae7bf6afcf7052a323ca885cde5aebc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure.">FVList</a>, which effectively reverses the order of the elements.  <a href="structLoyc_1_1Collections_1_1VList.html#aae7bf6afcf7052a323ca885cde5aebc9">More...</a><br /></td></tr>
<tr class="separator:aae7bf6afcf7052a323ca885cde5aebc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bcc8c1a69531930fa7edbe17c7ca59"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#ad7bcc8c1a69531930fa7edbe17c7ca59">operator FWList&lt; T &gt;</a> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list)</td></tr>
<tr class="memdesc:ad7bcc8c1a69531930fa7edbe17c7ca59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure.">FWList</a>, which effectively reverses the order of the elements.  <a href="structLoyc_1_1Collections_1_1VList.html#ad7bcc8c1a69531930fa7edbe17c7ca59">More...</a><br /></td></tr>
<tr class="separator:ad7bcc8c1a69531930fa7edbe17c7ca59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5456c2d4ea6fd3409f700d5891b32b97"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList.html#a5456c2d4ea6fd3409f700d5891b32b97">operator WList&lt; T &gt;</a> (<a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt; list)</td></tr>
<tr class="memdesc:a5456c2d4ea6fd3409f700d5891b32b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as an <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure.">WList</a>.  <a href="structLoyc_1_1Collections_1_1VList.html#a5456c2d4ea6fd3409f700d5891b32b97">More...</a><br /></td></tr>
<tr class="separator:a5456c2d4ea6fd3409f700d5891b32b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2899333f96298ded3387aab12021b349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2899333f96298ded3387aab12021b349">&#9670;&nbsp;</a></span>Add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> ICollection&lt;T&gt;. <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an item at the back (index Count) of the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a>. </p>

<p class="reference">Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a2899333f96298ded3387aab12021b349">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Add()</a>, <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Rule.html#a4ada4acb7780613d399da5fa1b250429">Loyc.LLParserGenerator.Rule.CreateMethod()</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNodeExt.html#a456c49cb9517ebf9c61c8c0d0da95ce6">Loyc.Syntax.LNodeExt.PlusTrailingTrivia()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1VList.html#adb01b7f5cdbb7f1b933fe8a051c19318">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Push()</a>.</p>

</div>
</div>
<a id="a1fdd1ee9e7d7ab4ebac20749a046f5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdd1ee9e7d7ab4ebac20749a046f5f9">&#9670;&nbsp;</a></span>Add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an item at the back (index Count) of the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a>. </p>

</div>
</div>
<a id="a8364d8d0aa2632224c542d63f1a75ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8364d8d0aa2632224c542d63f1a75ad8">&#9670;&nbsp;</a></span>CopyTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements of the collection to an Array, starting at a particular array index. </p>
<p>It's usually more convenient to call the <a class="el" href="structLoyc_1_1Collections_1_1VList.html#ab1afb6082c7800d527b48570c2b37389" title="Returns the VList converted to an array.">ToArray()</a> extension method, which calls this method for you. </p>
<p>This method exists for performance reasons (the collection itself can often copy data out faster than an enumerator can). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>array is null.</td></tr>
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>arrayIndex is negative.</td></tr>
    <tr><td class="paramname">ArgumentException</td><td>The number of elements in the source collection is greater than the available space from arrayIndex to the end of the destination array.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1ICollectionSource.html#a5b39bfe772dce668223b14f6f838a2dc">Loyc.Collections.ICollectionSource&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ab03b31527812c8eff3e9b2cd8187734b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03b31527812c8eff3e9b2cd8187734b">&#9670;&nbsp;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override bool <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Equals </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>rhs_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two list references are the same. Does not compare the contents of the lists. </p>

</div>
</div>
<a id="ac9c80ebfc94685daacd87c4c483aff72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c80ebfc94685daacd87c4c483aff72">&#9670;&nbsp;</a></span>IndexOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.IndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the specified object and returns the zero-based index of the first occurrence (lowest index) within the entire <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item to locate (can be null if T can be null)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the item, or -1 if it was not found.</dd></dl>
<p>This method determines equality using the default equality comparer EqualityComparer.Default for T, the type of values in the list.</p>
<p>This method performs a linear search, and is typically an O(n) operation, where n is Count. However, because the list is searched upward from index 0 to Count-1, if the list's blocks do not increase in size exponentially (due to the way that the list has been modified in the past), the search can have worse performance; the (unlikely) worst case is O(n^2). FVList(of T).<a class="el" href="structLoyc_1_1Collections_1_1VList.html#ac9c80ebfc94685daacd87c4c483aff72" title="Searches for the specified object and returns the zero-based index of the first occurrence (lowest in...">IndexOf()</a> doesn't have this problem. </p>

</div>
</div>
<a id="aae7bf6afcf7052a323ca885cde5aebc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7bf6afcf7052a323ca885cde5aebc9">&#9670;&nbsp;</a></span>operator FVList&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.operator <a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure.">FVList</a>, which effectively reverses the order of the elements. </p>
<p>This is a trivial operation; the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure.">FVList</a> shares the same memory.</p>

</div>
</div>
<a id="ad7bcc8c1a69531930fa7edbe17c7ca59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bcc8c1a69531930fa7edbe17c7ca59">&#9670;&nbsp;</a></span>operator FWList&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.operator <a class="el" href="classLoyc_1_1Collections_1_1FWList.html">FWList</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure.">FWList</a>, which effectively reverses the order of the elements. </p>
<p>The list contents are not copied until you modify the <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure.">FWList</a>.</p>

</div>
</div>
<a id="a5456c2d4ea6fd3409f700d5891b32b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5456c2d4ea6fd3409f700d5891b32b97">&#9670;&nbsp;</a></span>operator WList&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.operator <a class="el" href="classLoyc_1_1Collections_1_1WList.html">WList</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as an <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure.">WList</a>. </p>
<p>The list contents are not copied until you modify the <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure.">WList</a>.</p>

</div>
</div>
<a id="aa9c3c67c05c68deaf8f9f80243bcd494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c3c67c05c68deaf8f9f80243bcd494">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two list references are different. Does not compare the contents of the lists. </p>

</div>
</div>
<a id="a629e2c08d382f795462be991062f2709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629e2c08d382f795462be991062f2709">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two list references are the same. Does not compare the contents of the lists. </p>

</div>
</div>
<a id="a436ad98f6f524870b45ece96733ffcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436ad98f6f524870b45ece96733ffcf8">&#9670;&nbsp;</a></span>Pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last item (at index Count-1) from the list and returns it. </p>

<p class="reference">Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ac252d624be0aed0ef05145f9a7df984c">Loyc.Syntax.LNode.Equals()</a>.</p>

</div>
</div>
<a id="adb01b7f5cdbb7f1b933fe8a051c19318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb01b7f5cdbb7f1b933fe8a051c19318">&#9670;&nbsp;</a></span>Push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Push </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonym for <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a2899333f96298ded3387aab12021b349" title="Inserts an item at the back (index Count) of the VList.">Add()</a>; adds an item to the front of the list. </p>

</div>
</div>
<a id="a67946c8c8878afaa9f282b37849a0769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67946c8c8878afaa9f282b37849a0769">&#9670;&nbsp;</a></span>SmartSelect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.SmartSelect </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, T &gt;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list to another list of the same length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A function that transforms each item in the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after the map function is applied to each item. The original <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a> structure is not modified.</dd></dl>
<p>This method is called "Smart" because of what happens if the map doesn't do anything. If the map function returns the first N items unmodified, those N items are typically not copied, but shared between the existing list and the new one. This is useful for functional code that often processes a list without modifying it at all. </p>

</div>
</div>
<a id="acd2e8766cb1c2ceeab21158402330c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2e8766cb1c2ceeab21158402330c57">&#9670;&nbsp;</a></span>SmartSelectMany()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.SmartSelectMany </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, IList&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list to another list by concatenating the outputs of a mapping function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A function that transforms each item in the list to a list of items.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list that contains all the items returned from <code>map</code>.</dd></dl>
<p>This method is called "Smart" because of what happens if the map doesn't do anything. If, for the first N items, the <code>map</code> returns a list of length 1, and that one item is the same item that was passed in, then those N items are typically not copied, but shared between the existing list and the new one. This is useful for functional code that often processes a list without modifying it at all. </p>

</div>
</div>
<a id="a866e9f0ea9f9c84da69cd5b567aa78a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866e9f0ea9f9c84da69cd5b567aa78a4">&#9670;&nbsp;</a></span>SmartWhere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.SmartWhere </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, bool &gt;&#160;</td>
          <td class="paramname"><em>keep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a filter to a list, to exclude zero or more items. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keep</td><td>A function that chooses which items to include (exclude items by returning false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after filtering has been applied. The original list structure is not modified.</dd></dl>
<p>If the predicate keeps the first N items it is passed, those N items are typically not copied, but shared between the existing list and the new one. </p>

</div>
</div>
<a id="ab1afb6082c7800d527b48570c2b37389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1afb6082c7800d527b48570c2b37389">&#9670;&nbsp;</a></span>ToArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T [] <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.ToArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a> converted to an array. </p>

</div>
</div>
<a id="a95dbf9520695ec0b6cf4d90993c668c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95dbf9520695ec0b6cf4d90993c668c1">&#9670;&nbsp;</a></span>ToFVList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1FVList.html">FVList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.ToFVList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure.">FVList</a>, which effectively reverses the order of the elements. </p>
<dl class="section return"><dt>Returns</dt><dd>This is a trivial operation; the <a class="el" href="structLoyc_1_1Collections_1_1FVList.html" title="A reference to a FVList, a so-called persistent list data structure.">FVList</a> shares the same memory.</dd></dl>

</div>
</div>
<a id="a49d4385955fa9d1be7981ddc252d6f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d4385955fa9d1be7981ddc252d6f8e">&#9670;&nbsp;</a></span>ToFWList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoyc_1_1Collections_1_1FWList.html">FWList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.ToFWList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure.">FWList</a>, which effectively reverses the order of the elements. </p>
<p>The list contents are not copied until you modify the <a class="el" href="classLoyc_1_1Collections_1_1FWList.html" title="FWList is the mutable variant of the FVList data structure.">FWList</a>.</p>

<p class="reference">Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList.html#ad7bcc8c1a69531930fa7edbe17c7ca59">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.operator FWList&lt; T &gt;()</a>.</p>

</div>
</div>
<a id="ad66059b968b4840ebd52c7fb53fd6b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66059b968b4840ebd52c7fb53fd6b1e">&#9670;&nbsp;</a></span>ToWList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoyc_1_1Collections_1_1WList.html">WList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.ToWList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as an <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure.">WList</a>. </p>
<p>The list contents are not copied until you modify the <a class="el" href="classLoyc_1_1Collections_1_1WList.html" title="WList is the mutable variant of the VList data structure.">WList</a>.</p>

<p class="reference">Referenced by <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Rule.html#a4ada4acb7780613d399da5fa1b250429">Loyc.LLParserGenerator.Rule.CreateMethod()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a5456c2d4ea6fd3409f700d5891b32b97">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.operator WList&lt; T &gt;()</a>.</p>

</div>
</div>
<a id="a97ff56cf4b4c97f4449e1ccb4bfcd1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Transform </td>
          <td>(</td>
          <td class="paramtype">VListTransformer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a list (combines filtering with selection and more). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Method to apply to each item in the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list formed from transforming all items in the list</dd></dl>
<p>See the documentation of <a class="el" href="structLoyc_1_1Collections_1_1FVList.html#a00aaff73e8bd2e48b545a53d9dbc8047" title="Transforms a list (combines filtering with selection and more).">FVList.Transform()</a> for more information.</p>

<p class="reference">Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a3751829c3359ff56319fe6d93b6be40a">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.WhereSelect()</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1LNodeExt.html#ae1fea90241f2f61df1be4fd98017eb9f">Loyc.Syntax.LNodeExt.WithoutTrailingTrivia()</a>.</p>

</div>
</div>
<a id="a3751829c3359ff56319fe6d93b6be40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3751829c3359ff56319fe6d93b6be40a">&#9670;&nbsp;</a></span>WhereSelect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.WhereSelect </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters and maps a list with a user-defined function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>A function that chooses which items to include in a new list, and what to change them to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after filtering has been applied. The original list structure is not modified.</dd></dl>
<p>This is a smart function. If the filter keeps the first N items it is passed, those N items are typically not copied, but shared between the existing list and the new one. </p>

<p class="reference">Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#afbd1c05ec418a4df7eed80ae53d43d0a">Loyc.Syntax.CallNode.Select()</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="a0787076a488ad33cf4b74da25cfebb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0787076a488ad33cf4b74da25cfebb57">&#9670;&nbsp;</a></span>BlockChainLength</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int? <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.BlockChainLength</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of blocks used by this list. </p>
<p>You might look at this property when optimizing your program, because the runtime of some operations increases as the chain length increases. This property runs in O(BlockChainLength) time. Ideally, BlockChainLength is proportional to log_2(Count), but certain <a class="el" href="structLoyc_1_1Collections_1_1VList.html" title="VList represents a reference to a reverse-order FVList.">VList</a> usage patterns can produce long chains.</p>

</div>
</div>
<a id="ab429ef27c6d66520883bc8402d8e7653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab429ef27c6d66520883bc8402d8e7653">&#9670;&nbsp;</a></span>Last</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Last</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last item of the list (at index Count-1), which is the head of the list. </p>

<p class="reference">Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1LNodeExt.html#a12a4590905ffa883fd102e47f9b2bf2a">Loyc.Syntax.LNodeExt.AsLNode()</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNodeExt.html#a64e2f62371be0b603619419195bdea63">Loyc.Syntax.LNodeExt.GetCaptureIdentifier()</a>, <a class="el" href="classLeMP_1_1MacroContext.html#a915338924777f68be1a3c34f5519a958">LeMP.MacroContext.GetOptions()</a>, <a class="el" href="classLoyc_1_1Ecs_1_1EcsValidators.html#a26006ff95c953dff4e4e9768eb5c5863">Loyc.Ecs.EcsValidators.KeyNameComponentOf()</a>, <a class="el" href="classLoyc_1_1LLPG_1_1Macros.html#ab27ccc42e5eaa88f4bed8f10a87e4e2a">Loyc.LLPG.Macros.LllpgMacro()</a>, and <a class="el" href="structLoyc_1_1Collections_1_1VList.html#a436ad98f6f524870b45ece96733ffcf8">Loyc.Collections.VList&lt; Loyc.Syntax.LNode &gt;.Pop()</a>.</p>

</div>
</div>
<a id="a9c25e96b43013e9eee3ac4cf0b974abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c25e96b43013e9eee3ac4cf0b974abf">&#9670;&nbsp;</a></span>Tail</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.Tail</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list without the last item. If the list is empty, an empty list is retured. </p>

</div>
</div>
<a id="ab55e9bfa5eef58ad18ed164a699a2826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55e9bfa5eef58ad18ed164a699a2826">&#9670;&nbsp;</a></span>this[int index, T defaultValue]</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structLoyc_1_1Collections_1_1VList.html">Loyc.Collections.VList</a>&lt; T &gt;.this[int index, T defaultValue]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an item from the list at the specified index; returns defaultValue if the index is not valid. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 5 2020 09:07:38 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
