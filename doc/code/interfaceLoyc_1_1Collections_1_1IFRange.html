<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Enhanced C#: Loyc.Collections.IFRange&lt; out out T &gt; Interface Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html">IFRange</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interfaceLoyc_1_1Collections_1_1IFRange-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.IFRange&lt; out out T &gt; Interface Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A forward range. Allows you to read the first element from the range or skip it. The forward range lays the foundation for <a class="el" href="interfaceLoyc_1_1Collections_1_1IBRange.html">IBRange&lt;T&gt;</a> and <a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange&lt;T&gt;</a>. 
 <a href="interfaceLoyc_1_1Collections_1_1IFRange.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Interfaces/Collections/IRanges.cs'>/Core/Loyc.Interfaces/Collections/IRanges.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.IFRange&lt; out out T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interfaceLoyc_1_1Collections_1_1IFRange.png" usemap="#Loyc.Collections.IFRange_3C_20out_20out_20T_20_3E_map" alt=""/>
  <map id="Loyc.Collections.IFRange_3C_20out_20out_20T_20_3E_map" name="Loyc.Collections.IFRange&lt; out out T &gt;_map">
<area href="interfaceLoyc_1_1Collections_1_1IIsEmpty.html" title="Holds the IsEmpty property that tells you if a collection is empty." alt="Loyc.Collections.IIsEmpty" shape="rect" coords="484,0,716,24"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>A forward range. Allows you to read the first element from the range or skip it. The forward range lays the foundation for <a class="el" href="interfaceLoyc_1_1Collections_1_1IBRange.html">IBRange&lt;T&gt;</a> and <a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange&lt;T&gt;</a>.</p>
<p>Ranges are a concept I first saw formalized in the D programming language. They are generally more useful than .NET enumerators because there are more kinds of them: </p><ul>
<li>
A forward range (<a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html">IFRange&lt;T&gt;</a>) is a sequence of values accessed starting with the first, like IEnumerator&lt;T&gt;. A forward range is like IEnumerator, except that it can be cloned, so you can restart from the same place later. This is more powerful than IEnumerable&lt;T&gt;, which can only restart from the beginning. </li>
<li>
A bidirectional range inherits from the forward range, and provides access to the back of the sequence as well as the front. A bidirectional iterators may, for example, represent a linked list, or a UTF-8 string that provides access to the first and last 32-bit code point (note that random access by character index is not really possible in UTF-8 data, since the size of N characters is unknown). </li>
<li>
A random-access range is a sequence that provides array-like access to a section of a list. A section of a list is called a "slice". </li>
</ul>
<p>A range is read-only by default, but has a writable variant marked with the letter M, meaning "Mutable": IMFRange&lt;T&gt;, IMBRange&lt;T&gt;, IMRange&lt;T&gt;. </p>
<p>It is fair to ask why <a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html" title="A forward range. Allows you to read the first element from the range or skip it. The forward range la...">IFRange</a> exists&ndash;since it behaves like an enumerator, why not simply use IEnumerator directly? Well, this interface serves as the base interface for the other ranges, so its interface needs to make sense in that context. IEnumerator has "Current" and "MoveNext" methods, but in a bidirectional or random-access range, there is no single "Current" or "Next" item. </p>
<p>Also, when used through an interface, <a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html" title="A forward range. Allows you to read the first element from the range or skip it. The forward range la...">IFRange</a> is potentially more efficient than IEnumerator: you only need to call a single method, <a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html#ad80d39323c4514531ffd7b3818ddb5c7" title="Removes the first item from the range and returns it.">PopFirst()</a>, to get the next item, unlike IEnumerator which requires two interface calls per iteration. That can improve performance, since interface calls cannot be inlined. It is a bit inconvenient to use <a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html#ad80d39323c4514531ffd7b3818ddb5c7" title="Removes the first item from the range and returns it.">PopFirst(out bool)</a> because of its "out" argument, and more convenient extension methods would have been provided if C# supported "ref Type this", which would be needed since ranges are often value types. </p>
<p>Ranges are useful for implementing algorithms; they are comparable to the concept of "iterators" in C++, except that a range represents a pair of iterators instead of a single iterator. And like C++ iterators, they are a useful starting point for writing generic algorithms. </p>
<p>When using a range that is not typed <a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html">IFRange&lt;T&gt;</a>, you need to be careful how you use it because the range could be a struct type. Much like an enumerator, a range is often a small wrapper around a larger data structure; therefore, it often makes sense to implement a range as a struct. When a range is a struct, normally you are making a copy of it whenever you assign it to a different variable, or pass it to another method: </p><div class="fragment"><div class="line">Range b = a;</div><div class="line">a.PopFirst(); <span class="comment">// may not affect b if Range is a struct</span></div></div><!-- fragment --><p> In fact, a range should not be copied this way because assignment may or may not create a copy. You should avoid simple assignment, and use Clone() to copy a range instead: </p><div class="fragment"><div class="line">Range b = a.Clone();</div><div class="line">a.PopFirst(); <span class="comment">// will not affect b, and you can be sure of it</span></div></div><!-- fragment --><p> However, if a range is a reference type or a reference to <a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html" title="A forward range. Allows you to read the first element from the range or skip it. The forward range la...">IFRange</a>, you are not making a copy of it when you assign it or pass it to another method: </p><div class="fragment"><div class="line">IFRange&lt;T&gt; a = ...;</div><div class="line">IFRange&lt;T&gt; b = a;</div><div class="line">a.PopFirst(); <span class="comment">// The item was popped from b also</span></div></div><!-- fragment --><p> When writing generic code, you may want to use range types directly, as in: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> DoSomethingWithRange&lt;R,T&gt;(R range) where R : IRange&lt;T&gt; {...}</div></div><!-- fragment --><p> Using a range type directly can improve performance if R happens to be a struct type, since there is no need to box the range when passing it to this method. However, it is very important to keep in mind that "R" may be a struct or a class. If this method is not intended to modify the range from the perspective of the caller, the method must start by cloning the range, in case R is a class or interface type: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> DoSomethingWithRange&lt;R,T&gt;(R range) where R : IBRange&lt;T&gt; {</div><div class="line">    range = range.Clone();</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p> On the other hand, if this method <em>wants</em> the caller to see the changes to the range, R must be passed by reference, in case it is a struct type: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> DoSomethingWithRange&lt;R,T&gt;(ref R range) where R : IBRange&lt;T&gt; {</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p> To avoid these subtle difficulties, you can access the range through the <a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html">IFRange&lt;T&gt;</a> interface; just remember to Clone() the range when necessary. </p>
<p>Remember that a range is an alias for some underlying data structure. If the original data structure is modified, a range will "see" those changes. For instance, suppose that a range provides a slice from indexes 5 to 12 inclusive within an IList&lt;T&gt; object that contains 15 items: </p><pre>
    IList  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 
           a  b  c  d  e  f  g  h  i  j  k  l  m  n  o 
    <a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html" title="A random-access range, also known as a &quot;slice&quot;. Allows you to narrow down the range like IBRange&lt;T&gt; d...">IRange</a>                0  1  2  3  4  5  6  7
</pre><p> Thus, [0] in the range corresponds to item [5] in the list, "f". Now, if the first three items in the list are removed, then [0] in the range will still correspond to item [5] in the list, but the item at this location, marked "i", used to be at index [8]: </p><pre>
    IList  0  1  2  3  4  5  6  7  8  9 10 11
           d  e  f  g  h  i  j  k  l  m  n  o
    <a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html" title="A random-access range, also known as a &quot;slice&quot;. Allows you to narrow down the range like IBRange&lt;T&gt; d...">IRange</a>                0  1  2  3  4  5  6  7
</pre><p> The exact behavior of the range at this point is implementation-dependent. The <code>Count</code> property may remain at 8, or it may drop to 7; perhaps the range will return default(T) when you read index [7], or perhaps it will throw IndexOutOfRangeException. Because of this lack of predictability, you should avoid keeping a range that points to a list whose size is decreasing. If individual elements are modified but not the list size, the range is safe to use and will see the changes. If new elements are added to the end of the list, the range may or may not continue working as expected, depending on how the collection works and how the range works. In most cases the range will be unaffected, in contrast to common C++ containers such as <code>std::vector</code>, in which iterators are "invalidated" by any size change, and when an invalid iterator is accessed, it may return bad data or crash the program. </p>
<p>Currently there are no interfaces in Loyc.Essentials that return forward or bidirectional ranges; the only notable method that returns a range is <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a52cf4d93658771ea9539ed905d2d91bf" title="Returns a sub-range of this list.">IListSource&lt;T&gt;.Slice</a>, which returns a random-access range. Since a random-access range is also a bidirectional range, you can begin writing algorithms that accept forward and bidirectional ranges (for read access). Any collection that implements <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">IListSource&lt;T&gt;</a> can be treated as a range using the ListExt.AsRange&lt;T&gt;(IListSource&lt;T&gt;) extension method, which is like calling <code>Slice(0)</code>. </p>
<p>The design philosophy of Loyc.Essentials is that potentially useful interfaces should be included even if there are no implementations of the interface. That's why there are interfaces like IMFRange&lt;T&gt; that are not implemented by any classes. Why offer unused interfaces? Because this library is designed to be extended by third parties, who might want to implement the interface, e.g. if someone else creates mutable data structures such as the B+ tree, the doubly-linked list or the trie, they should offer implementations of IMBRange&lt;T&gt; and/or IMBinumerator&lt;T&gt;. </p>
<p>Implementors note: <a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html">IFRange&lt;T&gt;</a> includes IEnumerable&lt;T&gt;, and you can use the following implementation of IEnumerable provided that your range type <code>R</code> implements ICloneable&lt;R&gt;: </p><div class="fragment"><div class="line">IEnumerator <a class="code" href="namespaceSystem.html">System</a>.<a class="code" href="namespaceSystem_1_1Collections.html">Collections</a>.IEnumerable.GetEnumerator() { <span class="keywordflow">return</span> GetEnumerator(); }</div><div class="line">IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator() { <span class="keywordflow">return</span> GetEnumerator(); }</div><div class="line"><span class="keyword">public</span> RangeEnumerator&lt;R,T&gt; GetEnumerator()</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> RangeEnumerator&lt;R,T&gt;(<span class="keyword">this</span>);</div><div class="line">}</div></div><!-- fragment --><p> TODO: write RangeBinumerator for <a class="el" href="interfaceLoyc_1_1Collections_1_1IBRange.html" title="A bidirectional range. Allows you to read or remove the first or last element in a range...">IBRange</a>{T}, RangeMBinumerator for <a class="el" href="interfaceLoyc_1_1Collections_1_1IMBRange.html" title="A mutable bidirectional range.">IMBRange</a>{T}, and RangeMEnumerator for <a class="el" href="interfaceLoyc_1_1Collections_1_1IMEnumerator.html" title="A mutable enumerator interface. Provides a &quot;Remove&quot; method like Java iterators have, and allows you to modify the current item.">IMEnumerator</a>{T}. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:af95c7d95e8b82f0f3642776a8d544ec5"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html#af95c7d95e8b82f0f3642776a8d544ec5">First</a><code> [get]</code></td></tr>
<tr class="memdesc:af95c7d95e8b82f0f3642776a8d544ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first value in the range, without popping it. <a href="#af95c7d95e8b82f0f3642776a8d544ec5">More...</a><br /></td></tr>
<tr class="separator:af95c7d95e8b82f0f3642776a8d544ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interfaceLoyc_1_1Collections_1_1IIsEmpty"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceLoyc_1_1Collections_1_1IIsEmpty')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceLoyc_1_1Collections_1_1IIsEmpty.html">Loyc.Collections.IIsEmpty</a></td></tr>
<tr class="memitem:a88d17ca119f721011bac0a30b666192c inherit properties_interfaceLoyc_1_1Collections_1_1IIsEmpty"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88d17ca119f721011bac0a30b666192c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsEmpty</b><code> [get]</code></td></tr>
<tr class="separator:a88d17ca119f721011bac0a30b666192c inherit properties_interfaceLoyc_1_1Collections_1_1IIsEmpty"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad80d39323c4514531ffd7b3818ddb5c7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html#ad80d39323c4514531ffd7b3818ddb5c7">PopFirst</a> (out bool fail)</td></tr>
<tr class="memdesc:ad80d39323c4514531ffd7b3818ddb5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first item from the range and returns it. <a href="#ad80d39323c4514531ffd7b3818ddb5c7">More...</a><br /></td></tr>
<tr class="separator:ad80d39323c4514531ffd7b3818ddb5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad80d39323c4514531ffd7b3818ddb5c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html">Loyc.Collections.IFRange</a>&lt; out out T &gt;.PopFirst </td>
          <td>(</td>
          <td class="paramtype">out bool&#160;</td>
          <td class="paramname"><em>fail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the first item from the range and returns it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fail</td><td>Receives the current value of IIsEmpty.IsEmpty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first item of the range, or default(T) if IsEmpty.</dd></dl>
<p>This method is a little unweildy in plain C#, but in EC# it will be a bit more convenient to use via extension methods like <code>T PopFirst(ref this Range range, T defaultValue)</code> and <code>T? PopFirst(ref this Range range)</code>, which are illegal in plain C#. </p>
<p>I wanted to give this method the signature "bool PopFirst(out T first)" but the generic parameter "T" is covariant, i.e. it is marked "out T" which, ironically, is not compatible with "out T" parameters, only with return values. </p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1RangeExt.html#aa826b226ee88bb0d592f0c3ad4e08dc4">Loyc.Collections.RangeExt.Skip&lt; R, T &gt;()</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="af95c7d95e8b82f0f3642776a8d544ec5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange.html">Loyc.Collections.IFRange</a>&lt; out out T &gt;.First</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first value in the range, without popping it.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classLoyc_1_1Collections_1_1EmptySequenceException.html" title="An exception thrown by methods or properties that require a non-empty sequence but were provided with...">EmptySequenceException</a></td><td>The sequence is empty.</td></tr>
  </table>
  </dd>
</dl>
<p>A possible default implementation: </p><pre>
T First { get { return Range.PopFirst(Clone()); } }
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 17 2020 22:06:19 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
