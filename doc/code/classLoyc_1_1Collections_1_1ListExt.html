<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Enhanced C#: Loyc.Collections.ListExt Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html">ListExt</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classLoyc_1_1Collections_1_1ListExt-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.ListExt Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Extension methods and helper methods for List&lt;T&gt;, IList&lt;T&gt;, IReadOnlyList&lt;T&gt;, arrays, <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">IListSource&lt;T&gt;</a>, and for related mutable interfaces such as IArray&lt;T&gt;.  
 <a href="classLoyc_1_1Collections_1_1ListExt.html#details">More...</a></p>
<hr/><b>Source file</b>s:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Essentials/Collections/Adapters/Slice.cs'>/Core/Loyc.Essentials/Collections/Adapters/Slice.cs</a></li>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Essentials/Collections/ExtensionMethods/ListExt.cs'>/Core/Loyc.Essentials/Collections/ExtensionMethods/ListExt.cs</a></li>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Essentials/Collections/HelperClasses/Repeated.cs'>/Core/Loyc.Essentials/Collections/HelperClasses/Repeated.cs</a></li>
</ul>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>Extension methods and helper methods for List&lt;T&gt;, IList&lt;T&gt;, IReadOnlyList&lt;T&gt;, arrays, <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">IListSource&lt;T&gt;</a>, and for related mutable interfaces such as IArray&lt;T&gt;. </p>
<p>Extension methods that only apply to <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a>'s new interfaces, or adapt a list to those interfaces, will go in <a class="el" href="classLoyc_1_1Collections_1_1LCExt.html" title="Extension methods for Loyc Collection interfaces (such as IListSource&lt;T&gt;).">LCExt</a> instead. </p>
<p>The source code for adapter extension methods such as the Slice() method for arrays, which returns an ArraySlice&lt;T&gt; adapter, is now placed in the source file for each adapter class (e.g. ArraySlice.cs) to make it easier to create custom versions of Loyc.Essentials with parts removed. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aee6af912cff8a608922ece4565b1e70f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee6af912cff8a608922ece4565b1e70f"></a>
static <a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AsRange&lt; T &gt;</b> (this <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">IListSource</a>&lt; T &gt; list)</td></tr>
<tr class="separator:aee6af912cff8a608922ece4565b1e70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c01aff7b2084551ffda1331b0387c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88c01aff7b2084551ffda1331b0387c3"></a>
static <a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AsRange&lt; T &gt;</b> (this <a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange</a>&lt; T &gt; list)</td></tr>
<tr class="separator:a88c01aff7b2084551ffda1331b0387c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9a1fc0630c98a2dab2b495533977d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb9a1fc0630c98a2dab2b495533977d5"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch&lt; T &gt;</b> (this IReadOnlyList&lt; T &gt; list, T value)</td></tr>
<tr class="separator:acb9a1fc0630c98a2dab2b495533977d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ae2dc720c1449d2663ef59ebe410e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79ae2dc720c1449d2663ef59ebe410e9"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch&lt; T &gt;</b> (this IReadOnlyList&lt; T &gt; list, T value, IComparer&lt; T &gt; comparer)</td></tr>
<tr class="separator:a79ae2dc720c1449d2663ef59ebe410e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d65f5c681be875a1f41e5011b45314c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d65f5c681be875a1f41e5011b45314c"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch&lt; T &gt;</b> (this IReadOnlyList&lt; T &gt; list, T find, Comparison&lt; T &gt; compare)</td></tr>
<tr class="separator:a3d65f5c681be875a1f41e5011b45314c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413581011488285abaa6e21a164c3f0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a413581011488285abaa6e21a164c3f0a"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch2&lt; T, K &gt;</b> (this IReadOnlyList&lt; T &gt; list, K find, Func&lt; T, K, int &gt; compare, bool lowerBound=true)</td></tr>
<tr class="separator:a413581011488285abaa6e21a164c3f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa22ba8d4f0611480f05fd7752b655e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa22ba8d4f0611480f05fd7752b655e5"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch&lt; T &gt;</b> (this <a class="el" href="interfaceLoyc_1_1Collections_1_1IListAndListSource.html">IListAndListSource</a>&lt; T &gt; list, T value)</td></tr>
<tr class="separator:afa22ba8d4f0611480f05fd7752b655e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2f57be27c140b6a352d156efcfa676"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e2f57be27c140b6a352d156efcfa676"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch&lt; T &gt;</b> (this <a class="el" href="interfaceLoyc_1_1Collections_1_1IListAndListSource.html">IListAndListSource</a>&lt; T &gt; list, T value, IComparer&lt; T &gt; comparer)</td></tr>
<tr class="separator:a5e2f57be27c140b6a352d156efcfa676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234feab9cddaf1b6220c7a84b0f343ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a234feab9cddaf1b6220c7a84b0f343ce"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch&lt; T &gt;</b> (this <a class="el" href="interfaceLoyc_1_1Collections_1_1IListAndListSource.html">IListAndListSource</a>&lt; T &gt; list, T value, Comparison&lt; T &gt; compare)</td></tr>
<tr class="separator:a234feab9cddaf1b6220c7a84b0f343ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c3da577757289aa913743de4b7f107"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0c3da577757289aa913743de4b7f107"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch2&lt; T, K &gt;</b> (this <a class="el" href="interfaceLoyc_1_1Collections_1_1IListAndListSource.html">IListAndListSource</a>&lt; T &gt; list, K value, Func&lt; T, K, int &gt; compare, bool lowerBound=true)</td></tr>
<tr class="separator:ae0c3da577757289aa913743de4b7f107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad598b0a74278dd7de052b5b28ce7f371"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad598b0a74278dd7de052b5b28ce7f371"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CopyTo&lt; T &gt;</b> (this IReadOnlyCollection&lt; T &gt; c, T[] array, int arrayIndex)</td></tr>
<tr class="separator:ad598b0a74278dd7de052b5b28ce7f371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef79adea9faea5d4b062b96c0bf96d16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef79adea9faea5d4b062b96c0bf96d16"></a>
static T&#160;</td><td class="memItemRight" valign="bottom"><b>TryGet&lt; T &gt;</b> (this T[] list, int index, T defaultValue)</td></tr>
<tr class="separator:aef79adea9faea5d4b062b96c0bf96d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bdf0ecf4cb8f92187e985fa714b38d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70bdf0ecf4cb8f92187e985fa714b38d"></a>
static <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TryGet&lt; T &gt;</b> (this T[] list, int index)</td></tr>
<tr class="separator:a70bdf0ecf4cb8f92187e985fa714b38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca972c6f72b9a3844a23ea3612b38f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afca972c6f72b9a3844a23ea3612b38f8"></a>
static T&#160;</td><td class="memItemRight" valign="bottom"><b>TryGet&lt; T &gt;</b> (this List&lt; T &gt; list, int index, T defaultValue)</td></tr>
<tr class="separator:afca972c6f72b9a3844a23ea3612b38f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64596274cee315bf005831da1112cc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab64596274cee315bf005831da1112cc8"></a>
static <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TryGet&lt; T &gt;</b> (this List&lt; T &gt; list, int index)</td></tr>
<tr class="separator:ab64596274cee315bf005831da1112cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed17f663ab4ae38f4a4c1c85a14f2257"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed17f663ab4ae38f4a4c1c85a14f2257"></a>
static T&#160;</td><td class="memItemRight" valign="bottom"><b>TryGet&lt; T &gt;</b> (this <a class="el" href="interfaceLoyc_1_1Collections_1_1IListAndListSource.html">IListAndListSource</a>&lt; T &gt; list, int index, T defaultValue)</td></tr>
<tr class="separator:aed17f663ab4ae38f4a4c1c85a14f2257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50236545ec0f2dc26405692e3405208d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50236545ec0f2dc26405692e3405208d"></a>
static <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TryGet&lt; T &gt;</b> (this <a class="el" href="interfaceLoyc_1_1Collections_1_1IListAndListSource.html">IListAndListSource</a>&lt; T &gt; list, int index)</td></tr>
<tr class="separator:a50236545ec0f2dc26405692e3405208d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6baa904451b78727db8d4354c3df94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb6baa904451b78727db8d4354c3df94"></a>
static T&#160;</td><td class="memItemRight" valign="bottom"><b>TryGet&lt; T &gt;</b> (this IReadOnlyList&lt; T &gt; list, int index, T defaultValue)</td></tr>
<tr class="separator:acb6baa904451b78727db8d4354c3df94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa231e31bd9e82fe46ccdeb6d2d0cb2a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa231e31bd9e82fe46ccdeb6d2d0cb2a0"></a>
static <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TryGet&lt; T &gt;</b> (this IReadOnlyList&lt; T &gt; list, int index)</td></tr>
<tr class="separator:aa231e31bd9e82fe46ccdeb6d2d0cb2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e41b63e568e0d11c5a4d93b9ae95598"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a5e41b63e568e0d11c5a4d93b9ae95598">RemoveRange&lt; T &gt;</a> (this IList&lt; T &gt; list, int index, int count)</td></tr>
<tr class="memdesc:a5e41b63e568e0d11c5a4d93b9ae95598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code>count</code> items from <code>list</code> starting at the specified <code>index</code>. <a href="#a5e41b63e568e0d11c5a4d93b9ae95598">More...</a><br /></td></tr>
<tr class="separator:a5e41b63e568e0d11c5a4d93b9ae95598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4a70edc0a116a3c37914b1716195b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a9f4a70edc0a116a3c37914b1716195b8">Resize&lt; T &gt;</a> (this List&lt; T &gt; list, int newSize)</td></tr>
<tr class="memdesc:a9f4a70edc0a116a3c37914b1716195b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes a list by removing items from the list (if it is too long) or adding <code>default(T)</code> values to the end (if it is too short). <a href="#a9f4a70edc0a116a3c37914b1716195b8">More...</a><br /></td></tr>
<tr class="separator:a9f4a70edc0a116a3c37914b1716195b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196b24b319bc544a44d9325c2bc8827c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a196b24b319bc544a44d9325c2bc8827c">Resize&lt; T &gt;</a> (this IList&lt; T &gt; list, int newSize)</td></tr>
<tr class="memdesc:a196b24b319bc544a44d9325c2bc8827c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes a list by removing items from the list (if it is too long) or adding <code>default(T)</code> values to the end (if it is too short). <a href="#a196b24b319bc544a44d9325c2bc8827c">More...</a><br /></td></tr>
<tr class="separator:a196b24b319bc544a44d9325c2bc8827c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4000f7b34fbd829ff0618e80db0db7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d4000f7b34fbd829ff0618e80db0db7"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MaybeEnlarge&lt; T &gt;</b> (this List&lt; T &gt; list, int minSize)</td></tr>
<tr class="separator:a9d4000f7b34fbd829ff0618e80db0db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130ea1155cd7c970e20b1b3718db7831"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a130ea1155cd7c970e20b1b3718db7831"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MaybeEnlarge&lt; T &gt;</b> (this IList&lt; T &gt; list, int minSize)</td></tr>
<tr class="separator:a130ea1155cd7c970e20b1b3718db7831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce31146d9c144d48eccae6c2135acec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acce31146d9c144d48eccae6c2135acec"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>AddIfNotPresent&lt; TList, T &gt;</b> (this TList list, T item)</td></tr>
<tr class="separator:acce31146d9c144d48eccae6c2135acec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac126b64fa61fd78133d7ff9943aded4c"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt; A, B &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#ac126b64fa61fd78133d7ff9943aded4c">Zip&lt; A, B &gt;</a> (this IEnumerable&lt; A &gt; a, IEnumerable&lt; B &gt; b)</td></tr>
<tr class="memdesc:ac126b64fa61fd78133d7ff9943aded4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sequence of length <code>Min(a.Count(), b.Count())</code> of items from <code>a</code> and <code>b</code> paired together. The output is produced lazily, so infinite input sequences are supported. <a href="#ac126b64fa61fd78133d7ff9943aded4c">More...</a><br /></td></tr>
<tr class="separator:ac126b64fa61fd78133d7ff9943aded4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ceb39a2537063d2a71a7ec9807e7552"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt; A, B &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a9ceb39a2537063d2a71a7ec9807e7552">ZipLeft&lt; A, B &gt;</a> (this IEnumerable&lt; A &gt; a, IEnumerable&lt; B &gt; b, B defaultB)</td></tr>
<tr class="memdesc:a9ceb39a2537063d2a71a7ec9807e7552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sequence that has the same length as the first sequence, with items from the first and second sequence paired together. <a href="#a9ceb39a2537063d2a71a7ec9807e7552">More...</a><br /></td></tr>
<tr class="separator:a9ceb39a2537063d2a71a7ec9807e7552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d968377b9c352d0c215923ee6fcee1"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; C &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a01d968377b9c352d0c215923ee6fcee1">ZipLeft&lt; A, B, C &gt;</a> (this IEnumerable&lt; A &gt; a, IEnumerable&lt; B &gt; b, B defaultB, Func&lt; A, B, C &gt; resultSelector)</td></tr>
<tr class="memdesc:a01d968377b9c352d0c215923ee6fcee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternate version of ZipLeft&lt;A, B&gt;(IEnumerable&lt;A&gt;, IEnumerable&lt;B&gt;, B) in which a user-defined function is used to combine the items from the two lists. <a href="#a01d968377b9c352d0c215923ee6fcee1">More...</a><br /></td></tr>
<tr class="separator:a01d968377b9c352d0c215923ee6fcee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a05ad8d7cf390774d03e3910da7b49"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt; A, B &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a98a05ad8d7cf390774d03e3910da7b49">ZipLonger&lt; A, B &gt;</a> (this IEnumerable&lt; A &gt; a, IEnumerable&lt; B &gt; b)</td></tr>
<tr class="memdesc:a98a05ad8d7cf390774d03e3910da7b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sequence as long as the longer of two sequences. Items from the first and second sequence are initially paired together, and when one sequence ends, the other sequence's remaining values are paired with a default value. <a href="#a98a05ad8d7cf390774d03e3910da7b49">More...</a><br /></td></tr>
<tr class="separator:a98a05ad8d7cf390774d03e3910da7b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682aba93ad405a19a4957b0a6c5487ce"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt; A, B &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a682aba93ad405a19a4957b0a6c5487ce">ZipLonger&lt; A, B &gt;</a> (this IEnumerable&lt; A &gt; a, IEnumerable&lt; B &gt; b, A defaultA, B defaultB)</td></tr>
<tr class="memdesc:a682aba93ad405a19a4957b0a6c5487ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sequence as long as the longer of two sequences. Items from the first and second sequence are initially paired together, and when one sequence ends, the other sequence's remaining values are paired with a default value provided as a parameter. <a href="#a682aba93ad405a19a4957b0a6c5487ce">More...</a><br /></td></tr>
<tr class="separator:a682aba93ad405a19a4957b0a6c5487ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7711a3f1659aa33aaa19aac6b3ad202"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; C &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#ae7711a3f1659aa33aaa19aac6b3ad202">ZipLonger&lt; A, B, C &gt;</a> (this IEnumerable&lt; A &gt; a, IEnumerable&lt; B &gt; b, A defaultA, B defaultB, Func&lt; A, B, C &gt; resultSelector)</td></tr>
<tr class="memdesc:ae7711a3f1659aa33aaa19aac6b3ad202"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternate version of ZipLonger&lt;A, B&gt;(IEnumerable&lt;A&gt;, IEnumerable&lt;B&gt;, A, B) in which a user-defined function is used to combine the items from the two lists. <a href="#ae7711a3f1659aa33aaa19aac6b3ad202">More...</a><br /></td></tr>
<tr class="separator:ae7711a3f1659aa33aaa19aac6b3ad202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222092fa78ef95be6c705e5887be371e"><td class="memItemLeft" align="right" valign="top">static int[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a222092fa78ef95be6c705e5887be371e">RangeArray</a> (int count)</td></tr>
<tr class="memdesc:a222092fa78ef95be6c705e5887be371e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of Length <code>count</code> containing the numbers 0 through <code>count-1</code>. <a href="#a222092fa78ef95be6c705e5887be371e">More...</a><br /></td></tr>
<tr class="separator:a222092fa78ef95be6c705e5887be371e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f697008c11b02bb9906a6925661dce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33f697008c11b02bb9906a6925661dce"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a33f697008c11b02bb9906a6925661dce">Sort&lt; T &gt;</a> (this IList&lt; T &gt; list)</td></tr>
<tr class="separator:a33f697008c11b02bb9906a6925661dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6854e53258e6fdf9e60c8929d2a3abea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6854e53258e6fdf9e60c8929d2a3abea"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a6854e53258e6fdf9e60c8929d2a3abea">Sort&lt; T &gt;</a> (this IList&lt; T &gt; list, Comparison&lt; T &gt; comp)</td></tr>
<tr class="separator:a6854e53258e6fdf9e60c8929d2a3abea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaef02e1c644b899b354e3ae730b51ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#afaef02e1c644b899b354e3ae730b51ff">Sort&lt; T &gt;</a> (this IList&lt; T &gt; list, int index, int count, Comparison&lt; T &gt; comp)</td></tr>
<tr class="memdesc:afaef02e1c644b899b354e3ae730b51ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a quicksort using a Comparison function. <a href="#afaef02e1c644b899b354e3ae730b51ff">More...</a><br /></td></tr>
<tr class="separator:afaef02e1c644b899b354e3ae730b51ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae126a0171a0139b09a51eb65c99177b1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#ae126a0171a0139b09a51eb65c99177b1">StableSort&lt; T &gt;</a> (this IList&lt; T &gt; list, Comparison&lt; T &gt; comp)</td></tr>
<tr class="memdesc:ae126a0171a0139b09a51eb65c99177b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a stable sort, i.e. a sort that preserves the relative order of items that compare equal. <a href="#ae126a0171a0139b09a51eb65c99177b1">More...</a><br /></td></tr>
<tr class="separator:ae126a0171a0139b09a51eb65c99177b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4721211936f60823cb1520ec6d7a1f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4721211936f60823cb1520ec6d7a1f2"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>StableSort&lt; T &gt;</b> (this IList&lt; T &gt; list)</td></tr>
<tr class="separator:af4721211936f60823cb1520ec6d7a1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184629aa54a252dddbaa912dadae682f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Collections_1_1ListSlice.html">ListSlice</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a184629aa54a252dddbaa912dadae682f">SortLowestK&lt; T &gt;</a> (this IList&lt; T &gt; list, int k)</td></tr>
<tr class="memdesc:a184629aa54a252dddbaa912dadae682f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a partial quicksort, known as "quickselect", to find and sort the lowest k elements in a list. <a href="#a184629aa54a252dddbaa912dadae682f">More...</a><br /></td></tr>
<tr class="separator:a184629aa54a252dddbaa912dadae682f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ee947c811687add6db91800f3658ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91ee947c811687add6db91800f3658ad"></a>
static <a class="el" href="structLoyc_1_1Collections_1_1ListSlice.html">ListSlice</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SortLowestK&lt; T &gt;</b> (this IList&lt; T &gt; list, int k, Comparison&lt; T &gt; comp)</td></tr>
<tr class="separator:a91ee947c811687add6db91800f3658ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3897c90516d01a8e2da710b30f0fa5f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3897c90516d01a8e2da710b30f0fa5f5"></a>
static <a class="el" href="structLoyc_1_1Collections_1_1ListSlice.html">ListSlice</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SortLowestK&lt; T &gt;</b> (this IList&lt; T &gt; list, int index, int count, int k, Comparison&lt; T &gt; comp)</td></tr>
<tr class="separator:a3897c90516d01a8e2da710b30f0fa5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b053dcacbf13c7430fddd3ec1eaf12"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Collections_1_1ListSlice.html">ListSlice</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a40b053dcacbf13c7430fddd3ec1eaf12">SortLowestKStable&lt; T &gt;</a> (this IList&lt; T &gt; list, int k)</td></tr>
<tr class="memdesc:a40b053dcacbf13c7430fddd3ec1eaf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stable version of SortLowestK&lt;T&gt;(IList&lt;T&gt;,int). This means that when k&gt;1 and adjacent results at the beginning of <code>list</code> compare equal, they keep the same order that they had originally. <a href="#a40b053dcacbf13c7430fddd3ec1eaf12">More...</a><br /></td></tr>
<tr class="separator:a40b053dcacbf13c7430fddd3ec1eaf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac929f16d9a60d1f817c0d238cc2abff1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac929f16d9a60d1f817c0d238cc2abff1"></a>
static <a class="el" href="structLoyc_1_1Collections_1_1ListSlice.html">ListSlice</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SortLowestKStable&lt; T &gt;</b> (this IList&lt; T &gt; list, int k, Comparison&lt; T &gt; comp)</td></tr>
<tr class="separator:ac929f16d9a60d1f817c0d238cc2abff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ab7166841f5709058a2d88c17aaeb6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#ac0ab7166841f5709058a2d88c17aaeb6">InsertionSort&lt; T &gt;</a> (this IList&lt; T &gt; array, int index, int count, Comparison&lt; T &gt; comp)</td></tr>
<tr class="memdesc:ac0ab7166841f5709058a2d88c17aaeb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an insertion sort. <a href="#ac0ab7166841f5709058a2d88c17aaeb6">More...</a><br /></td></tr>
<tr class="separator:ac0ab7166841f5709058a2d88c17aaeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d2000a9a756a9e139470674f391911"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a23d2000a9a756a9e139470674f391911">SortPair&lt; T &gt;</a> (this IList&lt; T &gt; list, int i, int j, Comparison&lt; T &gt; comp)</td></tr>
<tr class="memdesc:a23d2000a9a756a9e139470674f391911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts two items to ensure that list[i] is less than list[j]. <a href="#a23d2000a9a756a9e139470674f391911">More...</a><br /></td></tr>
<tr class="separator:a23d2000a9a756a9e139470674f391911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201a0b2cd95f4b2a9e6e779c404a7561"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a201a0b2cd95f4b2a9e6e779c404a7561">Swap&lt; T &gt;</a> (this IList&lt; T &gt; list, int i, int j)</td></tr>
<tr class="memdesc:a201a0b2cd95f4b2a9e6e779c404a7561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps list[i] with list[j]. <a href="#a201a0b2cd95f4b2a9e6e779c404a7561">More...</a><br /></td></tr>
<tr class="separator:a201a0b2cd95f4b2a9e6e779c404a7561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a0dddc53dd0350995b5251242d4487"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29a0dddc53dd0350995b5251242d4487"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Swap&lt; T &gt;</b> (this <a class="el" href="interfaceLoyc_1_1Collections_1_1IArray.html">IArray</a>&lt; T &gt; list, int i, int j)</td></tr>
<tr class="separator:a29a0dddc53dd0350995b5251242d4487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa6a8bc17e1d2d390178b00aa067e37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fa6a8bc17e1d2d390178b00aa067e37"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Randomize&lt; T &gt;</b> (this IList&lt; T &gt; list)</td></tr>
<tr class="separator:a3fa6a8bc17e1d2d390178b00aa067e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7591a978e976e35d5088e20f095cc277"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7591a978e976e35d5088e20f095cc277"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Randomize&lt; T &gt;</b> (this T[] list)</td></tr>
<tr class="separator:a7591a978e976e35d5088e20f095cc277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2502639e26d964b0cd01b533e6c6d55"><td class="memItemLeft" align="right" valign="top">static T[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#af2502639e26d964b0cd01b533e6c6d55">Randomized&lt; T &gt;</a> (this IReadOnlyList&lt; T &gt; list)</td></tr>
<tr class="memdesc:af2502639e26d964b0cd01b533e6c6d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quickly makes a copy of a list, as an array, in random order. <a href="#af2502639e26d964b0cd01b533e6c6d55">More...</a><br /></td></tr>
<tr class="separator:af2502639e26d964b0cd01b533e6c6d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bb996c13ce99bc06aad17d1302a632"><td class="memItemLeft" align="right" valign="top">static R[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#ab2bb996c13ce99bc06aad17d1302a632">SelectArray&lt; T, R &gt;</a> (this T[] input, Func&lt; T, R &gt; selector)</td></tr>
<tr class="memdesc:ab2bb996c13ce99bc06aad17d1302a632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps an array to another array of the same length. <a href="#ab2bb996c13ce99bc06aad17d1302a632">More...</a><br /></td></tr>
<tr class="separator:ab2bb996c13ce99bc06aad17d1302a632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6166b7ee4eb0cd093625ae900050c9f"><td class="memItemLeft" align="right" valign="top">static R[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#af6166b7ee4eb0cd093625ae900050c9f">SelectArray&lt; T, R &gt;</a> (this IReadOnlyList&lt; T &gt; input, Func&lt; T, R &gt; selector)</td></tr>
<tr class="memdesc:af6166b7ee4eb0cd093625ae900050c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list to an array of the same length. <a href="#af6166b7ee4eb0cd093625ae900050c9f">More...</a><br /></td></tr>
<tr class="separator:af6166b7ee4eb0cd093625ae900050c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a091494f72779f6e57a3d7535e93997"><td class="memItemLeft" align="right" valign="top">static R[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a2a091494f72779f6e57a3d7535e93997">SelectArray&lt; T, R &gt;</a> (this <a class="el" href="interfaceLoyc_1_1Collections_1_1IListAndListSource.html">IListAndListSource</a>&lt; T &gt; input, Func&lt; T, R &gt; selector)</td></tr>
<tr class="memdesc:a2a091494f72779f6e57a3d7535e93997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list to an array of the same length. <a href="#a2a091494f72779f6e57a3d7535e93997">More...</a><br /></td></tr>
<tr class="separator:a2a091494f72779f6e57a3d7535e93997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d62f1b0762693646c71d00461792122"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a3d62f1b0762693646c71d00461792122">RemoveAll&lt; T &gt;</a> (this IList&lt; T &gt; list, Predicate&lt; T &gt; match)</td></tr>
<tr class="memdesc:a3d62f1b0762693646c71d00461792122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the all the elements that match the conditions defined by the specified predicate. <a href="#a3d62f1b0762693646c71d00461792122">More...</a><br /></td></tr>
<tr class="separator:a3d62f1b0762693646c71d00461792122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab175d889dec7806ac8a1279771d8613"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab175d889dec7806ac8a1279771d8613"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ReverseInPlace&lt; T &gt;</b> (this IList&lt; T &gt; list)</td></tr>
<tr class="separator:aab175d889dec7806ac8a1279771d8613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92763c86efb3827b4748beda93ef1960"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92763c86efb3827b4748beda93ef1960"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ReverseInPlace&lt; T &gt;</b> (this <a class="el" href="interfaceLoyc_1_1Collections_1_1IArray.html">IArray</a>&lt; T &gt; list)</td></tr>
<tr class="separator:a92763c86efb3827b4748beda93ef1960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d64bea5f88a2a512c59a416ee22a61f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d64bea5f88a2a512c59a416ee22a61f"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange&lt; T &gt;</b> (this IList&lt; T &gt; list, IEnumerable&lt; T &gt; range)</td></tr>
<tr class="separator:a2d64bea5f88a2a512c59a416ee22a61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51e58d5724d06b6e05f31ce5bb8fd68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af51e58d5724d06b6e05f31ce5bb8fd68"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange&lt; T &gt;</b> (this IList&lt; T &gt; list, int index, IReadOnlyCollection&lt; T &gt; source)</td></tr>
<tr class="separator:af51e58d5724d06b6e05f31ce5bb8fd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5841dd539c5e80e93ffa712935aa27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e5841dd539c5e80e93ffa712935aa27"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange&lt; T &gt;</b> (this IList&lt; T &gt; list, int index, ICollection&lt; T &gt; source)</td></tr>
<tr class="separator:a4e5841dd539c5e80e93ffa712935aa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa651a2e2afd008ae2e594cd723b8d40a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa651a2e2afd008ae2e594cd723b8d40a"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange&lt; T &gt;</b> (this IList&lt; T &gt; list, int index, <a class="el" href="interfaceLoyc_1_1Collections_1_1IListAndListSource.html">IListAndListSource</a>&lt; T &gt; source)</td></tr>
<tr class="separator:aa651a2e2afd008ae2e594cd723b8d40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12fb42d0a12bf1a9825b1a13e4c17d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af12fb42d0a12bf1a9825b1a13e4c17d6"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange&lt; T &gt;</b> (this IList&lt; T &gt; list, int index, <a class="el" href="interfaceLoyc_1_1Collections_1_1ICollectionAndReadOnly.html">ICollectionAndReadOnly</a>&lt; T &gt; source)</td></tr>
<tr class="separator:af12fb42d0a12bf1a9825b1a13e4c17d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4979ca0ce4084119b7f0b199d3df36f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4979ca0ce4084119b7f0b199d3df36f"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange&lt; T &gt;</b> (this IList&lt; T &gt; list, int index, int count, IEnumerable&lt; T &gt; source)</td></tr>
<tr class="separator:ad4979ca0ce4084119b7f0b199d3df36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1935f631ec45cbff4a8d01c39d35292b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a1935f631ec45cbff4a8d01c39d35292b">InsertRangeHelper&lt; T &gt;</a> (IList&lt; T &gt; list, int index, int spaceNeeded)</td></tr>
<tr class="memdesc:a1935f631ec45cbff4a8d01c39d35292b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the list size by <code>spaceNeeded</code> and copies elements starting at <code>list[index]</code> "rightward" to make room for inserted elements that will be initialized by the caller. <a href="#a1935f631ec45cbff4a8d01c39d35292b">More...</a><br /></td></tr>
<tr class="separator:a1935f631ec45cbff4a8d01c39d35292b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e80f36d06f3472d8bb8a81c03a86be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Collections_1_1Repeated.html">Repeated</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a76e80f36d06f3472d8bb8a81c03a86be">Repeat&lt; T &gt;</a> (T value, int count)</td></tr>
<tr class="memdesc:a76e80f36d06f3472d8bb8a81c03a86be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a helper object that stores one value, but acts like a read-only list that repeats the value the specified number of times. <a href="#a76e80f36d06f3472d8bb8a81c03a86be">More...</a><br /></td></tr>
<tr class="separator:a76e80f36d06f3472d8bb8a81c03a86be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113e21367fef9583bcbe11ff88058c02"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Collections_1_1Repeated.html">Repeated</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html#a113e21367fef9583bcbe11ff88058c02">Single&lt; T &gt;</a> (T value)</td></tr>
<tr class="memdesc:a113e21367fef9583bcbe11ff88058c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a helper object that stores one value, but acts like a read-only list of one item. <a href="#a113e21367fef9583bcbe11ff88058c02">More...</a><br /></td></tr>
<tr class="separator:a113e21367fef9583bcbe11ff88058c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac0ab7166841f5709058a2d88c17aaeb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.ListExt.InsertionSort&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an insertion sort.</p>
<p>The insertion sort is a stable sort algorithm that is slow in general (O(N^2)). It should be used only when (a) the list to be sorted is short (less than 10-20 elements) or (b) the list is very nearly sorted already.</p>
<dl class="section see"><dt>See also</dt><dd>InternalList.InsertionSort</dd></dl>

</div>
</div>
<a class="anchor" id="a1935f631ec45cbff4a8d01c39d35292b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.ListExt.InsertRangeHelper&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNeeded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases the list size by <code>spaceNeeded</code> and copies elements starting at <code>list[index]</code> "rightward" to make room for inserted elements that will be initialized by the caller.</p>

</div>
</div>
<a class="anchor" id="af2502639e26d964b0cd01b533e6c6d55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T [] Loyc.Collections.ListExt.Randomized&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IReadOnlyList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quickly makes a copy of a list, as an array, in random order.</p>

</div>
</div>
<a class="anchor" id="a222092fa78ef95be6c705e5887be371e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int [] Loyc.Collections.ListExt.RangeArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of Length <code>count</code> containing the numbers 0 through <code>count-1</code>.</p>

</div>
</div>
<a class="anchor" id="a3d62f1b0762693646c71d00461792122"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Collections.ListExt.RemoveAll&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the all the elements that match the conditions defined by the specified predicate.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements removed from the list</dd></dl>

</div>
</div>
<a class="anchor" id="a5e41b63e568e0d11c5a4d93b9ae95598"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.ListExt.RemoveRange&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes <code>count</code> items from <code>list</code> starting at the specified <code>index</code>.</p>

</div>
</div>
<a class="anchor" id="a76e80f36d06f3472d8bb8a81c03a86be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1Repeated.html">Repeated</a>&lt;T&gt; <a class="el" href="namespaceLoyc_1_1Collections.html#af0ffc4d7615f186f5aa815a344723f35a7020426cfb0a204051be4b3053d2acc8">Loyc.Collections.ListExt.Repeat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a helper object that stores one value, but acts like a read-only list that repeats the value the specified number of times.</p>
<dl class="section return"><dt>Returns</dt><dd><code>new <a class="el" href="structLoyc_1_1Collections_1_1Repeated.html" title="Helper struct. A sequence that stores one value, but acts like a list in which that value is repeated...">Repeated</a>&lt;T&gt;(value, count)</code></dd></dl>

</div>
</div>
<a class="anchor" id="a9f4a70edc0a116a3c37914b1716195b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.ListExt.Resize&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this List&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes a list by removing items from the list (if it is too long) or adding <code>default(T)</code> values to the end (if it is too short).</p>

</div>
</div>
<a class="anchor" id="a196b24b319bc544a44d9325c2bc8827c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.ListExt.Resize&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes a list by removing items from the list (if it is too long) or adding <code>default(T)</code> values to the end (if it is too short).</p>

</div>
</div>
<a class="anchor" id="ab2bb996c13ce99bc06aad17d1302a632"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R [] Loyc.Collections.ListExt.SelectArray&lt; T, R &gt; </td>
          <td>(</td>
          <td class="paramtype">this T[]&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; T, R &gt;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps an array to another array of the same length.</p>

</div>
</div>
<a class="anchor" id="af6166b7ee4eb0cd093625ae900050c9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R [] Loyc.Collections.ListExt.SelectArray&lt; T, R &gt; </td>
          <td>(</td>
          <td class="paramtype">this IReadOnlyList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; T, R &gt;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list to an array of the same length.</p>

</div>
</div>
<a class="anchor" id="a2a091494f72779f6e57a3d7535e93997"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R [] Loyc.Collections.ListExt.SelectArray&lt; T, R &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interfaceLoyc_1_1Collections_1_1IListAndListSource.html">IListAndListSource</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; T, R &gt;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list to an array of the same length.</p>

</div>
</div>
<a class="anchor" id="a113e21367fef9583bcbe11ff88058c02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1Repeated.html">Repeated</a>&lt;T&gt; Loyc.Collections.ListExt.Single&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a helper object that stores one value, but acts like a read-only list of one item.</p>
<dl class="section return"><dt>Returns</dt><dd><code>new <a class="el" href="structLoyc_1_1Collections_1_1Repeated.html" title="Helper struct. A sequence that stores one value, but acts like a list in which that value is repeated...">Repeated</a>&lt;T&gt;(value, 1)</code></dd></dl>

</div>
</div>
<a class="anchor" id="afaef02e1c644b899b354e3ae730b51ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.ListExt.Sort&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a quicksort using a Comparison function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index at which to begin sorting a portion of the list.</td></tr>
    <tr><td class="paramname">count</td><td>Number of items to sort starting at 'index'.</td></tr>
  </table>
  </dd>
</dl>
<p>This method exists because the .NET framework offers no method to sort IList&lt;T&gt;&ndash;you can sort arrays and List&lt;T&gt;, but not IList. </p>
<p>This quicksort algorithm uses a best-of-three pivot so that it remains performant (fast) if the input is already sorted. It is designed to perform reasonably well in case the data contains many duplicates (not verified). It is also designed to avoid using excessive stack space if a worst-case input occurs that requires O(N^2) time. </p>

</div>
</div>
<a class="anchor" id="a184629aa54a252dddbaa912dadae682f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1ListSlice.html">ListSlice</a>&lt;T&gt; Loyc.Collections.ListExt.SortLowestK&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses a partial quicksort, known as "quickselect", to find and sort the lowest k elements in a list.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list that will be partially sorted.</td></tr>
    <tr><td class="paramname">k</td><td>Number of elements that will be sorted at the beginning of the list when this method returns. If <code>k &gt; list.Count</code>, the entire list is sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Although the list is modified in-place, a slice of the beginning of the same list is returned. The slice will have k elements (or list.Count elements, whichever is less).</dd></dl>
<p>Whereas quicksort typically runs in O(N log N) time, quickselect typically requires O(N) time for small values of k, although the worst-case performance remains O(N^2).</p>

</div>
</div>
<a class="anchor" id="a40b053dcacbf13c7430fddd3ec1eaf12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1ListSlice.html">ListSlice</a>&lt;T&gt; Loyc.Collections.ListExt.SortLowestKStable&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A stable version of SortLowestK&lt;T&gt;(IList&lt;T&gt;,int). This means that when k&gt;1 and adjacent results at the beginning of <code>list</code> compare equal, they keep the same order that they had originally.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list that will be partially sorted.</td></tr>
    <tr><td class="paramname">k</td><td>Number of elements that will be sorted at the beginning of the list when this method returns. If <code>k &gt; list.Count</code>, the entire list is sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This method uses the quickselect algorithm and stability is achieved using a temporary array of <code>list.Count</code> integers.</dd></dl>

</div>
</div>
<a class="anchor" id="a23d2000a9a756a9e139470674f391911"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Loyc.Collections.ListExt.SortPair&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts two items to ensure that list[i] is less than list[j].</p>
<dl class="section return"><dt>Returns</dt><dd>True if the array elements were swapped, false if not.</dd></dl>

</div>
</div>
<a class="anchor" id="ae126a0171a0139b09a51eb65c99177b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.ListExt.StableSort&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a stable sort, i.e. a sort that preserves the relative order of items that compare equal.</p>
<p>On larger inputs, this algorithm uses a quicksort and therefore runs in O(N log N) time, but it requires O(N) temporary space (specifically, an array of N integers) and is slower than a standard quicksort, so you should use it only if you need a stable sort or if the input is usually small (in which case insertion sort is used). </p>

</div>
</div>
<a class="anchor" id="a201a0b2cd95f4b2a9e6e779c404a7561"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.ListExt.Swap&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps list[i] with list[j].</p>

</div>
</div>
<a class="anchor" id="ac126b64fa61fd78133d7ff9943aded4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt;A, B&gt; &gt; Loyc.Collections.ListExt.Zip&lt; A, B &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; A &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; B &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sequence of length <code>Min(a.Count(), b.Count())</code> of items from <code>a</code> and <code>b</code> paired together. The output is produced lazily, so infinite input sequences are supported.</p>

</div>
</div>
<a class="anchor" id="a9ceb39a2537063d2a71a7ec9807e7552"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt;A, B&gt; &gt; Loyc.Collections.ListExt.ZipLeft&lt; A, B &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; A &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; B &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>defaultB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sequence that has the same length as the first sequence, with items from the first and second sequence paired together.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultB</td><td>If the second sequence <code>b</code> is shorter than the first sequence, the remaining items of the first sequence are paired with this value. Otherwise, this value is not used.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01d968377b9c352d0c215923ee6fcee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;C&gt; Loyc.Collections.ListExt.ZipLeft&lt; A, B, C &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; A &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; B &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>defaultB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; A, B, C &gt;&#160;</td>
          <td class="paramname"><em>resultSelector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alternate version of ZipLeft&lt;A, B&gt;(IEnumerable&lt;A&gt;, IEnumerable&lt;B&gt;, B) in which a user-defined function is used to combine the items from the two lists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultB</td><td>If the second sequence <code>b</code> is shorter than the first sequence, the remaining items of the first sequence are paired with this value. Otherwise, this value is not used.</td></tr>
    <tr><td class="paramname">resultSelector</td><td>A function that combines items from the two lists.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98a05ad8d7cf390774d03e3910da7b49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt;A, B&gt; &gt; Loyc.Collections.ListExt.ZipLonger&lt; A, B &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; A &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; B &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sequence as long as the longer of two sequences. Items from the first and second sequence are initially paired together, and when one sequence ends, the other sequence's remaining values are paired with a default value.</p>

</div>
</div>
<a class="anchor" id="a682aba93ad405a19a4957b0a6c5487ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt;A, B&gt; &gt; Loyc.Collections.ListExt.ZipLonger&lt; A, B &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; A &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; B &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>defaultA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>defaultB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sequence as long as the longer of two sequences. Items from the first and second sequence are initially paired together, and when one sequence ends, the other sequence's remaining values are paired with a default value provided as a parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultA</td><td>If the first sequence <code>a</code> is shorter than the second sequence, the remaining items of the second sequence are paired with this value. Otherwise, this value is not used.</td></tr>
    <tr><td class="paramname">defaultB</td><td>If the second sequence <code>b</code> is shorter than the first sequence, the remaining items of the first sequence are paired with this value. Otherwise, this value is not used.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7711a3f1659aa33aaa19aac6b3ad202"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;C&gt; Loyc.Collections.ListExt.ZipLonger&lt; A, B, C &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; A &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; B &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>defaultA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>defaultB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; A, B, C &gt;&#160;</td>
          <td class="paramname"><em>resultSelector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alternate version of ZipLonger&lt;A, B&gt;(IEnumerable&lt;A&gt;, IEnumerable&lt;B&gt;, A, B) in which a user-defined function is used to combine the items from the two lists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultSelector</td><td>A function that combines items from the two lists.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 17 2020 22:06:20 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
