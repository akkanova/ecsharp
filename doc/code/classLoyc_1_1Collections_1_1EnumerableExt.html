<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Enhanced C#: Loyc.Collections.EnumerableExt Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html">EnumerableExt</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classLoyc_1_1Collections_1_1EnumerableExt-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.EnumerableExt Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Additional extension methods for IEnumerable&lt;T&gt;, IReadOnlyCollection&lt;T&gt;, and ICollection&lt;T&gt;, beyond what LINQ provides.  
 <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#details">More...</a></p>
<hr/><b>Source file</b>s:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Essentials/Collections/Adapters/BufferedSequence.cs'>/Core/Loyc.Essentials/Collections/Adapters/BufferedSequence.cs</a></li>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Essentials/Collections/Adapters/CollectionAsSource.cs'>/Core/Loyc.Essentials/Collections/Adapters/CollectionAsSource.cs</a></li>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Essentials/Collections/Adapters/SelectDictionaryFromKeys.cs'>/Core/Loyc.Essentials/Collections/Adapters/SelectDictionaryFromKeys.cs</a></li>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Essentials/Collections/ExtensionMethods/EnumerableExt.cs'>/Core/Loyc.Essentials/Collections/ExtensionMethods/EnumerableExt.cs</a></li>
</ul>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>Additional extension methods for IEnumerable&lt;T&gt;, IReadOnlyCollection&lt;T&gt;, and ICollection&lt;T&gt;, beyond what LINQ provides. </p>
<p>The methods include WithIndexes&lt;T&gt;, which pairs each item of a sequence with a 0-based index of that item; ForEach&lt;T&gt;, which runs a lambda for each member of a sequence; <a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#a55ac60a0b41aec5509a71dfd69e9df4e" title="Gets the lowest index at which a condition is true, or -1 if nowhere.">IndexWhere&lt;T&gt;</a>, which finds the index where a predicate is true; <a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#a28aaeadc14ae336745d3666465a9e193" title="Returns all adjacent pairs (e.g. for the list {1,2,3}, returns {(1,2),(2,3)})">AdjacentPairs&lt;T&gt;</a>, which pairs each list item with the next one, and MinOrDefault, which finds the item such that some associated value is minimized (in contrast to LINQ's Min(), which just returns the minimum value itself.) And there's more. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af37723006271c6adbd165e60d4782d82"><td class="memItemLeft" align="right" valign="top"><a id="af37723006271c6adbd165e60d4782d82"></a>
static <a class="el" href="classLoyc_1_1Collections_1_1BufferedSequence.html">BufferedSequence</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Buffered&lt; T &gt;</b> (this IEnumerator&lt; T &gt; source)</td></tr>
<tr class="separator:af37723006271c6adbd165e60d4782d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213341c0ef036170e0e55e7e6ad278a6"><td class="memItemLeft" align="right" valign="top"><a id="a213341c0ef036170e0e55e7e6ad278a6"></a>
static <a class="el" href="classLoyc_1_1Collections_1_1BufferedSequence.html">BufferedSequence</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Buffered&lt; T &gt;</b> (this IEnumerable&lt; T &gt; source)</td></tr>
<tr class="separator:a213341c0ef036170e0e55e7e6ad278a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf03a0e2a97ea74c0f99500d8c670a2b"><td class="memItemLeft" align="right" valign="top"><a id="aaf03a0e2a97ea74c0f99500d8c670a2b"></a>
static <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">IListSource</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Buffered&lt; T &gt;</b> (this <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">IListSource</a>&lt; T &gt; source)</td></tr>
<tr class="separator:aaf03a0e2a97ea74c0f99500d8c670a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e97d9384d74c5263190f62e83f8c57"><td class="memItemLeft" align="right" valign="top">static IReadOnlyCollection&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#af4e97d9384d74c5263190f62e83f8c57">AsReadOnly&lt; T &gt;</a> (this ICollection&lt; T &gt; c)</td></tr>
<tr class="memdesc:af4e97d9384d74c5263190f62e83f8c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats any ICollection{T} object to IReadOnlyCollection{T}.  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#af4e97d9384d74c5263190f62e83f8c57">More...</a><br /></td></tr>
<tr class="separator:af4e97d9384d74c5263190f62e83f8c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc382bcc528253e7b79fbc58fd7c0711"><td class="memItemLeft" align="right" valign="top">static IReadOnlyDictionary&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#abc382bcc528253e7b79fbc58fd7c0711">AsReadOnlyDictionary&lt; K, V &gt;</a> (this IReadOnlyCollection&lt; K &gt; keys, Func&lt; K, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; V &gt;&gt; tryGetValue, Func&lt; K, V &gt; getValue=null)</td></tr>
<tr class="memdesc:abc382bcc528253e7b79fbc58fd7c0711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a collection of keys to an IReadOnlyDictionary, based on a function that can obtain a value for a given key.  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#abc382bcc528253e7b79fbc58fd7c0711">More...</a><br /></td></tr>
<tr class="separator:abc382bcc528253e7b79fbc58fd7c0711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb744ff4fb67da3a239866452d66b188"><td class="memItemLeft" align="right" valign="top"><a id="acb744ff4fb67da3a239866452d66b188"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ForEach&lt; T &gt;</b> (this IEnumerable&lt; T &gt; list, Action&lt; T &gt; action)</td></tr>
<tr class="separator:acb744ff4fb67da3a239866452d66b188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d638746d1107bbfa00d1320f50b5133"><td class="memItemLeft" align="right" valign="top"><a id="a0d638746d1107bbfa00d1320f50b5133"></a>
static IEnumerable&lt; KeyValuePair&lt; int, T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WithIndexes&lt; T &gt;</b> (this IEnumerable&lt; T &gt; c)</td></tr>
<tr class="separator:a0d638746d1107bbfa00d1320f50b5133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5bd67eb70fe791e805e21ea65e4ffd"><td class="memItemLeft" align="right" valign="top">static ? int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#afc5bd67eb70fe791e805e21ea65e4ffd">FirstIndexWhere&lt; T &gt;</a> (this IEnumerable&lt; T &gt; list, Func&lt; T, bool &gt; pred)</td></tr>
<tr class="memdesc:afc5bd67eb70fe791e805e21ea65e4ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lowest index at which a condition is true, or null if nowhere.  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#afc5bd67eb70fe791e805e21ea65e4ffd">More...</a><br /></td></tr>
<tr class="separator:afc5bd67eb70fe791e805e21ea65e4ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ac60a0b41aec5509a71dfd69e9df4e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#a55ac60a0b41aec5509a71dfd69e9df4e">IndexWhere&lt; T &gt;</a> (this IEnumerable&lt; T &gt; list, Func&lt; T, bool &gt; pred)</td></tr>
<tr class="memdesc:a55ac60a0b41aec5509a71dfd69e9df4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lowest index at which a condition is true, or -1 if nowhere.  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#a55ac60a0b41aec5509a71dfd69e9df4e">More...</a><br /></td></tr>
<tr class="separator:a55ac60a0b41aec5509a71dfd69e9df4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4081cc7829d249d9376fdf53a18008"><td class="memItemLeft" align="right" valign="top"><a id="a1f4081cc7829d249d9376fdf53a18008"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOfMin</b> (this IEnumerable&lt; int &gt; source)</td></tr>
<tr class="separator:a1f4081cc7829d249d9376fdf53a18008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcc1b8ddbf0064798d47639d7cba3d4"><td class="memItemLeft" align="right" valign="top"><a id="a9bcc1b8ddbf0064798d47639d7cba3d4"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOfMin&lt; T &gt;</b> (this IEnumerable&lt; T &gt; source, Func&lt; T, int &gt; selector)</td></tr>
<tr class="separator:a9bcc1b8ddbf0064798d47639d7cba3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48aead4c426fb1435834259343eec2e6"><td class="memItemLeft" align="right" valign="top"><a id="a48aead4c426fb1435834259343eec2e6"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOfMin&lt; T &gt;</b> (this IEnumerable&lt; T &gt; source, Func&lt; T, int &gt; selector, out int min)</td></tr>
<tr class="separator:a48aead4c426fb1435834259343eec2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1d3790c14b337545e33640d080b87c"><td class="memItemLeft" align="right" valign="top"><a id="a8e1d3790c14b337545e33640d080b87c"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOfMax</b> (this IEnumerable&lt; int &gt; source)</td></tr>
<tr class="separator:a8e1d3790c14b337545e33640d080b87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63833db0d713e3e44bf84cc8f57213da"><td class="memItemLeft" align="right" valign="top"><a id="a63833db0d713e3e44bf84cc8f57213da"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOfMax&lt; T &gt;</b> (this IEnumerable&lt; T &gt; source, Func&lt; T, int &gt; selector)</td></tr>
<tr class="separator:a63833db0d713e3e44bf84cc8f57213da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9ec39cdfd734d146800098141ad77f"><td class="memItemLeft" align="right" valign="top"><a id="a9e9ec39cdfd734d146800098141ad77f"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOfMax&lt; T &gt;</b> (this IEnumerable&lt; T &gt; source, Func&lt; T, int &gt; selector, out int max)</td></tr>
<tr class="separator:a9e9ec39cdfd734d146800098141ad77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab123e553d79d2500b835e611463a6713"><td class="memItemLeft" align="right" valign="top"><a id="ab123e553d79d2500b835e611463a6713"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOfMin&lt; T &gt;</b> (this IEnumerable&lt; T &gt; source)</td></tr>
<tr class="separator:ab123e553d79d2500b835e611463a6713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5ab7050b48415b694b9012e5ae93fe"><td class="memItemLeft" align="right" valign="top"><a id="aaa5ab7050b48415b694b9012e5ae93fe"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOfMin&lt; T, R &gt;</b> (this IEnumerable&lt; T &gt; source, Func&lt; T, R &gt; selector)</td></tr>
<tr class="separator:aaa5ab7050b48415b694b9012e5ae93fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5742a83761e17f12f3f0f90ac02ca1e5"><td class="memItemLeft" align="right" valign="top"><a id="a5742a83761e17f12f3f0f90ac02ca1e5"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOfMin&lt; T, R &gt;</b> (this IEnumerable&lt; T &gt; source, Func&lt; T, R &gt; selector, out R min)</td></tr>
<tr class="separator:a5742a83761e17f12f3f0f90ac02ca1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a4853766ff9ef22d457ed05c1af3dd"><td class="memItemLeft" align="right" valign="top"><a id="ae8a4853766ff9ef22d457ed05c1af3dd"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOfMax&lt; T &gt;</b> (this IEnumerable&lt; T &gt; source)</td></tr>
<tr class="separator:ae8a4853766ff9ef22d457ed05c1af3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228cb670442d6fb1069b5ae6ab43d972"><td class="memItemLeft" align="right" valign="top"><a id="a228cb670442d6fb1069b5ae6ab43d972"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOfMax&lt; T, R &gt;</b> (this IEnumerable&lt; T &gt; source, Func&lt; T, R &gt; selector)</td></tr>
<tr class="separator:a228cb670442d6fb1069b5ae6ab43d972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6013f03d7b6ed807061a8cea55aaf3db"><td class="memItemLeft" align="right" valign="top"><a id="a6013f03d7b6ed807061a8cea55aaf3db"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOfMax&lt; T, R &gt;</b> (this IEnumerable&lt; T &gt; source, Func&lt; T, R &gt; selector, out R max)</td></tr>
<tr class="separator:a6013f03d7b6ed807061a8cea55aaf3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7927ac693f82e8faad31dee8d7d947dc"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#a7927ac693f82e8faad31dee8d7d947dc">MinOrDefault&lt; T &gt;</a> (this IEnumerable&lt; T &gt; list, Func&lt; T, int &gt; selector, T defaultValue=default(T))</td></tr>
<tr class="memdesc:a7927ac693f82e8faad31dee8d7d947dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the item in the list that has the minimum value for some selector.  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#a7927ac693f82e8faad31dee8d7d947dc">More...</a><br /></td></tr>
<tr class="separator:a7927ac693f82e8faad31dee8d7d947dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1089b1d9f0fe3a3ae8f9f708ea2820"><td class="memItemLeft" align="right" valign="top"><a id="aba1089b1d9f0fe3a3ae8f9f708ea2820"></a>
static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#aba1089b1d9f0fe3a3ae8f9f708ea2820">MinOrDefault&lt; T &gt;</a> (this IEnumerable&lt; T &gt; list, Func&lt; T, double &gt; selector, T defaultValue=default(T))</td></tr>
<tr class="separator:aba1089b1d9f0fe3a3ae8f9f708ea2820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa849d3b679f19165ce5856ff12d51613"><td class="memItemLeft" align="right" valign="top"><a id="aa849d3b679f19165ce5856ff12d51613"></a>
static IEnumerable&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WhereNotNull&lt; T &gt;</b> (this IEnumerable&lt; T &gt; list)</td></tr>
<tr class="separator:aa849d3b679f19165ce5856ff12d51613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5479ff0edf01453bd0d6eff097faa492"><td class="memItemLeft" align="right" valign="top"><a id="a5479ff0edf01453bd0d6eff097faa492"></a>
static IEnumerable&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WhereNotNull&lt; T &gt;</b> (this IEnumerable&lt; T?&gt; list)</td></tr>
<tr class="separator:a5479ff0edf01453bd0d6eff097faa492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810c3ad3d92ffcc2e871422a9d67ddeb"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; Out &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#a810c3ad3d92ffcc2e871422a9d67ddeb">SelectFilter&lt; T, Out &gt;</a> (this IEnumerable&lt; T &gt; list, Func&lt; T, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; Out &gt;&gt; filter)</td></tr>
<tr class="memdesc:a810c3ad3d92ffcc2e871422a9d67ddeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines 'Select' and 'Where' in a single operation.  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#a810c3ad3d92ffcc2e871422a9d67ddeb">More...</a><br /></td></tr>
<tr class="separator:a810c3ad3d92ffcc2e871422a9d67ddeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab12bb537a998412880799cbb353fda2"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#aab12bb537a998412880799cbb353fda2">MaxOrDefault&lt; T &gt;</a> (this IEnumerable&lt; T &gt; list, Func&lt; T, int &gt; selector, T defaultValue=default(T))</td></tr>
<tr class="memdesc:aab12bb537a998412880799cbb353fda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>item</em> in the list that has the maximum value for some selector.  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#aab12bb537a998412880799cbb353fda2">More...</a><br /></td></tr>
<tr class="separator:aab12bb537a998412880799cbb353fda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfcb2c73ea017aa28def0439cb2c6ea"><td class="memItemLeft" align="right" valign="top"><a id="a8cfcb2c73ea017aa28def0439cb2c6ea"></a>
static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#a8cfcb2c73ea017aa28def0439cb2c6ea">MaxOrDefault&lt; T &gt;</a> (this IEnumerable&lt; T &gt; list, Func&lt; T, double &gt; selector, T defaultValue=default(T))</td></tr>
<tr class="separator:a8cfcb2c73ea017aa28def0439cb2c6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc45b80d774ececb51d11b24313aa69c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#acc45b80d774ececb51d11b24313aa69c">IndexOf&lt; T &gt;</a> (this IEnumerable&lt; T &gt; list, T item)</td></tr>
<tr class="memdesc:acc45b80d774ececb51d11b24313aa69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific value.  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#acc45b80d774ececb51d11b24313aa69c">More...</a><br /></td></tr>
<tr class="separator:acc45b80d774ececb51d11b24313aa69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40049dc415e6512434a3116c21fe98ec"><td class="memItemLeft" align="right" valign="top"><a id="a40049dc415e6512434a3116c21fe98ec"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOf&lt; T &gt;</b> (this IEnumerable&lt; T &gt; list, T item, IEqualityComparer&lt; T &gt; comp)</td></tr>
<tr class="separator:a40049dc415e6512434a3116c21fe98ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2a586f5222e8828b3651ccac71c7f5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#abc2a586f5222e8828b3651ccac71c7f5">SequenceHashCode&lt; T &gt;</a> (this IEnumerable&lt; T &gt; list)</td></tr>
<tr class="memdesc:abc2a586f5222e8828b3651ccac71c7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A companion to Enumerable.SequenceEqual&lt;T&gt; that computes a hashcode for a list.  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#abc2a586f5222e8828b3651ccac71c7f5">More...</a><br /></td></tr>
<tr class="separator:abc2a586f5222e8828b3651ccac71c7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae562457405a3863e5dd260b7af96e89b"><td class="memItemLeft" align="right" valign="top"><a id="ae562457405a3863e5dd260b7af96e89b"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>SequenceHashCode&lt; T &gt;</b> (this IEnumerable&lt; T &gt; list, IEqualityComparer&lt; T &gt; comp)</td></tr>
<tr class="separator:ae562457405a3863e5dd260b7af96e89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6af03afbb1a0cc88d639533478b742e"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; Base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#ae6af03afbb1a0cc88d639533478b742e">Upcast&lt; Base, Derived &gt;</a> (this IEnumerable&lt; Derived &gt; list)</td></tr>
<tr class="memdesc:ae6af03afbb1a0cc88d639533478b742e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcasts a sequence.  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#ae6af03afbb1a0cc88d639533478b742e">More...</a><br /></td></tr>
<tr class="separator:ae6af03afbb1a0cc88d639533478b742e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28aaeadc14ae336745d3666465a9e193"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt; T, T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#a28aaeadc14ae336745d3666465a9e193">AdjacentPairs&lt; T &gt;</a> (this IEnumerable&lt; T &gt; list)</td></tr>
<tr class="memdesc:a28aaeadc14ae336745d3666465a9e193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all adjacent pairs (e.g. for the list {1,2,3}, returns {(1,2),(2,3)})  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#a28aaeadc14ae336745d3666465a9e193">More...</a><br /></td></tr>
<tr class="separator:a28aaeadc14ae336745d3666465a9e193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b0c1f96cf1eb8415458a4ad731b0e9"><td class="memItemLeft" align="right" valign="top"><a id="aa8b0c1f96cf1eb8415458a4ad731b0e9"></a>
static IEnumerable&lt; <a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt; T, T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AdjacentPairs&lt; T &gt;</b> (this IEnumerator&lt; T &gt; e)</td></tr>
<tr class="separator:aa8b0c1f96cf1eb8415458a4ad731b0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0320af2a69f229087550fc16269fdb7e"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; <a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt; T, T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html#a0320af2a69f229087550fc16269fdb7e">AdjacentPairsCircular&lt; T &gt;</a> (this IEnumerable&lt; T &gt; list)</td></tr>
<tr class="memdesc:a0320af2a69f229087550fc16269fdb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all adjacent pairs, treating the first and last pairs as adjacent (e.g. for the list {1,2,3,4}, returns the pairs {(1,2),(2,3),(3,4),(4,1)}.)  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#a0320af2a69f229087550fc16269fdb7e">More...</a><br /></td></tr>
<tr class="separator:a0320af2a69f229087550fc16269fdb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6bc81fbc3b63d3f3648f8a0bd2bfb5"><td class="memItemLeft" align="right" valign="top"><a id="aec6bc81fbc3b63d3f3648f8a0bd2bfb5"></a>
static IEnumerable&lt; <a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt; T, T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AdjacentPairsCircular&lt; T &gt;</b> (this IEnumerator&lt; T &gt; e)</td></tr>
<tr class="separator:aec6bc81fbc3b63d3f3648f8a0bd2bfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0400f000876e93e85420c248a964a03"><td class="memItemLeft" align="right" valign="top"><a id="aa0400f000876e93e85420c248a964a03"></a>
static List&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ToList&lt; T &gt;</b> (this IEnumerator&lt; T &gt; e)</td></tr>
<tr class="separator:aa0400f000876e93e85420c248a964a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a28aaeadc14ae336745d3666465a9e193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28aaeadc14ae336745d3666465a9e193">&#9670;&nbsp;</a></span>AdjacentPairs&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt;T, T&gt; &gt; Loyc.Collections.EnumerableExt.AdjacentPairs&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all adjacent pairs (e.g. for the list {1,2,3}, returns {(1,2),(2,3)}) </p>

</div>
</div>
<a id="a0320af2a69f229087550fc16269fdb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0320af2a69f229087550fc16269fdb7e">&#9670;&nbsp;</a></span>AdjacentPairsCircular&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;<a class="el" href="classLoyc_1_1Pair.html">Pair</a>&lt;T, T&gt; &gt; Loyc.Collections.EnumerableExt.AdjacentPairsCircular&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all adjacent pairs, treating the first and last pairs as adjacent (e.g. for the list {1,2,3,4}, returns the pairs {(1,2),(2,3),(3,4),(4,1)}.) </p>

</div>
</div>
<a id="af4e97d9384d74c5263190f62e83f8c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e97d9384d74c5263190f62e83f8c57">&#9670;&nbsp;</a></span>AsReadOnly&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IReadOnlyCollection&lt;T&gt; Loyc.Collections.EnumerableExt.AsReadOnly&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this ICollection&lt; T &gt;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats any ICollection{T} object to IReadOnlyCollection{T}. </p>
<p>This method is named "AsReadOnly" and not "ToReadOnly" because, in contrast to methods like ToArray(), and ToList() it does not make a copy of the sequence, although it does create a new wrapper object.</p>

</div>
</div>
<a id="abc382bcc528253e7b79fbc58fd7c0711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc382bcc528253e7b79fbc58fd7c0711">&#9670;&nbsp;</a></span>AsReadOnlyDictionary&lt; K, V &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IReadOnlyDictionary&lt;K, V&gt; Loyc.Collections.EnumerableExt.AsReadOnlyDictionary&lt; K, V &gt; </td>
          <td>(</td>
          <td class="paramtype">this IReadOnlyCollection&lt; K &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; K, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; V &gt;&gt;&#160;</td>
          <td class="paramname"><em>tryGetValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; K, V &gt;&#160;</td>
          <td class="paramname"><em>getValue</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a collection of keys to an IReadOnlyDictionary, based on a function that can obtain a value for a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>A collection of dictionary keys.</td></tr>
    <tr><td class="paramname">tryGetValue</td><td>This function is used both to test membership and to get values.</td></tr>
    <tr><td class="paramname">getValue</td><td>This function is optional. It is used to get values when it is known in advance that the key exists (in GetEnumerator() and in the Values property). If this is null, tryGetValue is used instead. Providing this function can increase performance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is useful, for example, when you need to implement an interface that provides a dictionary of values, but your data is in the wrong format. You don't want to convert the entire dictionary, since the caller might only need to look up one item from it. </p><div class="fragment"><div class="line"><span class="keyword">interface </span>ICompany</div>
<div class="line">{</div>
<div class="line">    IReadOnlyDictionary&lt;long, string&gt; Employees { <span class="keyword">get</span>; }</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"><span class="keyword">class </span>Company : ICompany</div>
<div class="line">{</div>
<div class="line">    Dictionary&lt;int, Person&gt; _employees = <span class="keyword">new</span> Dictionary&lt;int, Person&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> IReadOnlyDictionary&lt;long, string&gt; Employees =&gt; </div>
<div class="line">        LinqToLists.Select(_employees.Keys, k =&gt; (<span class="keywordtype">long</span>)k)</div>
<div class="line">        .AsReadOnlyDictionary(k =&gt; {</div>
<div class="line">            var v = _employees.TryGetValue((<span class="keywordtype">int</span>)k);</div>
<div class="line">            <span class="keywordflow">return</span> v.HasValue ? (Maybe&lt;string&gt;)v.Value.ToString() : Maybe&lt;string&gt;.NoValue;</div>
<div class="line">        });     </div>
<div class="line">&lt;br&gt;</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"><span class="keyword">class </span>Person</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">string</span> FirstName, LastName;</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keywordtype">string</span> ToString() =&gt; FirstName + <span class="stringliteral">&quot; &quot;</span> + LastName;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afc5bd67eb70fe791e805e21ea65e4ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5bd67eb70fe791e805e21ea65e4ffd">&#9670;&nbsp;</a></span>FirstIndexWhere&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ? int Loyc.Collections.EnumerableExt.FirstIndexWhere&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; T, bool &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the lowest index at which a condition is true, or null if nowhere. </p>

</div>
</div>
<a id="acc45b80d774ececb51d11b24313aa69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc45b80d774ececb51d11b24313aa69c">&#9670;&nbsp;</a></span>IndexOf&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Collections.EnumerableExt.IndexOf&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the index of a specific value. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the value, if found, or -1 if it was not found.</dd></dl>
<p>At first, this method was a member of <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html" title="A read-only list indexed by an integer.">IListSource</a> itself, just in case the source might have some kind of fast lookup logic (e.g. binary search) or custom comparer. However, since the item to find is an "in" argument, it would prevent <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html" title="A read-only list indexed by an integer.">IListSource</a> from being marked covariant when I upgrade to C# 4. </p>

</div>
</div>
<a id="a55ac60a0b41aec5509a71dfd69e9df4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ac60a0b41aec5509a71dfd69e9df4e">&#9670;&nbsp;</a></span>IndexWhere&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Collections.EnumerableExt.IndexWhere&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; T, bool &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the lowest index at which a condition is true, or -1 if nowhere. </p>

</div>
</div>
<a id="aab12bb537a998412880799cbb353fda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab12bb537a998412880799cbb353fda2">&#9670;&nbsp;</a></span>MaxOrDefault&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T Loyc.Collections.EnumerableExt.MaxOrDefault&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; T, int &gt;&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>default(T)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>item</em> in the list that has the maximum value for some selector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list to search</td></tr>
    <tr><td class="paramname">selector</td><td>A function that takes a number from the list</td></tr>
    <tr><td class="paramname">defaultValue</td><td>A value </td></tr>
  </table>
  </dd>
</dl>
<p>Unfortunately, the standard LINQ methods Max(lambda) and Min(lambda) return the minimum or maximum value returned from the lambda function, which is unfortunate because you often want the original value from the list, not the number returned by the lambda. That's a flawed design, because often you want the original T value and not the projected number; if the developer actually wanted the min/max <em>number</em>, he could have just used <code>list.Select(lambda).Max()</code> instead of <code>list.Max(lambda)</code>. </p>
<p>So MinOrDefault() and MaxByDefault() are different in two ways: (1) they returns the original T value from the collection, and (2) if the collection is empty, they return a default value. </p>

</div>
</div>
<a id="a7927ac693f82e8faad31dee8d7d947dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7927ac693f82e8faad31dee8d7d947dc">&#9670;&nbsp;</a></span>MinOrDefault&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T Loyc.Collections.EnumerableExt.MinOrDefault&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; T, int &gt;&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>default(T)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the item in the list that has the minimum value for some selector. </p>

</div>
</div>
<a id="a810c3ad3d92ffcc2e871422a9d67ddeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810c3ad3d92ffcc2e871422a9d67ddeb">&#9670;&nbsp;</a></span>SelectFilter&lt; T, Out &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;Out&gt; Loyc.Collections.EnumerableExt.SelectFilter&lt; T, Out &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; T, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; Out &gt;&gt;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines 'Select' and 'Where' in a single operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>If this function returns Maybe&lt;O&gt;.NoValue then the element is suppressed from the output; otherwise the Maybe&lt;T&gt;.Value is sent to the output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence filtered and changed by <code>filter</code>.</dd></dl>

</div>
</div>
<a id="abc2a586f5222e8828b3651ccac71c7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2a586f5222e8828b3651ccac71c7f5">&#9670;&nbsp;</a></span>SequenceHashCode&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Loyc.Collections.EnumerableExt.SequenceHashCode&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A companion to Enumerable.SequenceEqual&lt;T&gt; that computes a hashcode for a list. </p>

</div>
</div>
<a id="ae6af03afbb1a0cc88d639533478b742e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6af03afbb1a0cc88d639533478b742e">&#9670;&nbsp;</a></span>Upcast&lt; Base, Derived &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;Base&gt; Loyc.Collections.EnumerableExt.Upcast&lt; Base, Derived &gt; </td>
          <td>(</td>
          <td class="paramtype">this IEnumerable&lt; Derived &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upcasts a sequence. </p>
<p>In .NET 4+ this is a no-op that just returns <code>list</code>, but in .NET 3.5 that's illegal, so this method creates an adapter.</p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>Derived</em></td><td>&#160;:</td><td valign="top"><em>class</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>Derived</em></td><td>&#160;:</td><td valign="top"><em>Base</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 22 2020 11:06:30 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
