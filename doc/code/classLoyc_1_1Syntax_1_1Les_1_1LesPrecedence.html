<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Enhanced C#: Loyc.Syntax.Les.LesPrecedence Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Syntax.html">Syntax</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Syntax_1_1Les.html">Les</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Syntax_1_1Les_1_1LesPrecedence.html">LesPrecedence</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="classLoyc_1_1Syntax_1_1Les_1_1LesPrecedence-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Syntax.Les.LesPrecedence Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a> objects that represent the precedence levels of LES.  
 <a href="classLoyc_1_1Syntax_1_1Les_1_1LesPrecedence.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Syntax/LES/LesPrecedence.cs'>/Core/Loyc.Syntax/LES/LesPrecedence.cs</a></li>
</ul>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>Contains <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a> objects that represent the precedence levels of LES. </p>
<p>In LES, the precedence of an operator is decided based simply on the text of the operator. The precedence of each one-character operator is predefined; the precedence of any operator with two or more characters is decided based on the first and last characters (according to the rules below). Other characters, if any, do not affect precedence. </p>
<p>The LES precedence table mostly matches popular programming languages, i.e. those in the C family. </p>
<p>An operator consists of a sequence of the following characters: </p><pre>
   ~ ! % ^ * - + = | &lt; &gt; / ? : . &amp;
</pre><p> In addition, the $ character is allowed as the first character and, if present, it forces the operator to be interpreted as a prefix operator. </p>
<p>LESv3 also has operators that start with a single quote, which can include both letters and punctuation (e.g. <code>'|foo|</code>). The quote itself is ignored for the purpose of choosing precedence. LESv2 has <code><code>backquoted</code></code> operators instead, whereas in LESv3 backquoted strings are simply identifiers. </p>
<p>It is notable that the following punctuation cannot be used in operators: </p><ul>
<li>
"@" is used for multiple other purposes. </li>
<li>
"#" is conventionally used to mark "keywords" (although in LESv2, the parser treats it like an underscore or a letter.) </li>
<li>
"," and ";" are separators, so for example, "?,!" is parsed as three separate tokens. </li>
<li>
The backslash "\" is reserved for future use. </li>
</ul>
<p>The following table shows all the precedence levels and associativities of the "built-in" LES operators, except a couple of special operators such as the "lambda" operator =&gt;, whose precedence is different on the left side than on the right side. Each precedence level has a name, which corresponds to a static field of this class. All binary operators are left-associative unless otherwise specified. </p><ol>
<li>
Substitute: prefix $ . : (note: prefix-dot is not allowed in LES3) </li>
<li>
Primary: binary . =:, generic arguments List!(int), suffix ++ &ndash;, method calls f(x), indexers a[i] </li>
<li>
NullDot: binary ?. :: (in LESv2, :: is NullDot, in LESv3 it's Primary) </li>
<li>
DoubleBang: binary right-associative !! </li>
<li>
Prefix: prefix ~ ! % ^ * / - + &amp; <code>backtick</code> (LESv2 only) </li>
<li>
Power: binary ** </li>
<li>
Multiply: binary * / % \ &gt;&gt; &lt;&lt; </li>
<li>
Add: binary + - </li>
<li>
Arrow: binary right-associative -&gt; &lt;- </li>
<li>
PrefixDots: prefix .. </li>
<li>
Range: binary right-associative .. </li>
<li>
Compare: binary != == &gt;= &gt; &lt; &lt;= </li>
<li>
And: binary &amp;&amp; </li>
<li>
Or: binary || ^^ </li>
<li>
IfElse: binary right-associative ? : </li>
<li>
LowerKeyword: a lowercase keyword </li>
<li>
PrefixOr: | </li>
</ol>
<p>Not listed in table: binary <code>=&gt; ~ = ?? &gt;&gt; ^ | &amp; &lt;&lt; </code>; prefix <code>? = &gt; &lt;</code>; non-lowercase keywords. </p>
<p>Notice that the precedence of an operator depends on how it is used. The prefix operator <code>-</code> has higher precedence than the binary operator <code>-</code>, so for example <code>- y * z</code> is parsed as <code>(- y) * z</code>, while <code>x - y * z</code> is parsed as <code>x - (y * z)</code>. </p>
<p>Programmers often use the shift operators <code>&gt;&gt;</code> and <code>&lt;&lt;</code> in place of multiplication or division, so their <em>natural</em> precedence is the same as <code>*</code> and <code>/</code>. However, traditionally the C family of languages confusingly give the shift operators a precedence below <code>+</code>. Therefore, LES does not allow mixing of shift operators with <code>+ - * /</code>; <code>a &gt;&gt; b + c</code> should produce a parse error. This is called immiscibility as explained in the documentation of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a>. Parsing may still complete, but the exact output tree is unspecified (may be <code>(a &gt;&gt; b) + c</code> or <code>a &gt;&gt; (b + c)</code>). </p>
<p>Likewise, the bitwise <code>^ | &amp;</code> operators cannot be mixed with comparison operators as in <code>a | 1 == 3</code>. </p>
<p>The Lambda operator =&gt;, which is right-associative, has a precedence level above Multiply on the left side, but below Assign on the right side. For example, the expression <code>a = b =&gt; c = d</code> is parsed as <code>a = (b =&gt; (c = d))</code>, and similarly <code>a + b =&gt; c + d</code> is parsed as <code>a + (b =&gt; (c + d))</code>, but <code>a ** b =&gt; c ** d</code> is parsed <code>(a ** b) =&gt; (c ** d)</code>. The idea of two different precedences on the two sides of an operator may seem strange; see the documentation of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a> for more explanation. </p>
<p>Similarly, all assignment operators (including compound assignments like +=) have a high precedence on the left side and low precedence on the right. This decision was made for WebAssembly, in which an expression like <code>2 * i32_store[$f(),4] = 3 * $g()</code> is best parsed as <code>2 * (i32_store[$f(),4] = (3 * $g()))</code> (NOTE: this example will surely be wrong by the time Wasm is released). </p>
<p>As a nod to functional languages, the arrow operator "-&gt;" is right- associative and has a precedence below '*' so that <code>int * int -&gt; int</code> parses as <code>(int * int) -&gt; int</code> rather than <code>int * (int -&gt; int)</code> as in the C family of languages. </p>
<p>Some operators like <code>'this-one</code> do not begin with punctuation. These "keyword operators" must be used as binary operators. They either start with a lowercase letter or they don't. If they do start with a lowercase letter, their precedence is LowerKeyword, which is very low, below assignment, so that <code>a = b 'then x = y</code> parses like <code>(a = b) 'then (x = y)</code>. </p>
<p>If they do not start with a lowercase letter (as in <code>'Foo</code> or <code>'123</code>) then they have an indeterminate precedence, below power (**) but above comparison (==). This means that an operator like 'XOR or 'Mod cannot be mixed with operators of precedence Multiply, Add, Arrow, AndBits, OrBits, OrIfNull, PrefixDots, and Range operators. Mixing operators illegally (e.g. <code>x 'Mod y + z</code>) will produce a parse error. </p>
<p>After constructing an initial table based on common operators from other languages, I noticed that </p><ul>
<li>
None of the high-precedence operators were right-associative, so I added the !! operator to "fill in the gap". </li>
<li>
There were no prefix operators with low precedence, so I added ".." whose precedence is just above binary "..", and "|" which has a precedence lower than anything except attributes (this "operator" is inspired by Nemerle, which uses "|" in pattern matching and variants.) </li>
</ul>
<p>I also wanted to have a little "room to grow"&ndash;to defer the precedence decision to a future time for some operators. So the precedence of the binary operator ~ has a range of operators with which it cannot be mixed, the same range as for uppercase operators without punctuation; for example, <code>x ~ y + z</code> is invalid but <code>x ~ y == z</code> is allowed. </p>
<p>The operators <code>\ ? = &gt; &lt;</code> cannot be used as prefix operators. </p>
<p>The way that low-precedence prefix operators are parsed deserves some discussion... TODO. </p>
<p>Most operators can have two roles. Most operators can either be binary operators or prefix operators; for example, <code>!*!</code> is a binary operator in <code>x !*! y</code> but a prefix operator in <code>x + !*! y</code>. </p>
<p>The operators <code>++ &ndash;</code> also have two roles, but different roles: they can be either prefix or suffix operators, but not binary operators. For example, <code>-*-</code> is a suffix operator in <code>x -*- + y</code> and a prefix operator in <code>x + -*- y</code>. Please note that <code>x -*- y</code> is ambiguous (it could be parsed as either of two superexpressions, <code>(x -*-) (y)</code> or <code>(x) (-*- y)</code>) and it is illegal. </p>
<p>Operators that start with $ can only be prefix operators (not binary or suffix). Having only a single role makes these operators unambiguous inside superexpressions (LESv2) or with juxtaposition (LESv3). </p>
<p>An operator cannot have all three roles (suffix, prefix and binary); that would be overly ambiguous. For example, if "-" could also be a suffix operator then <code>x - + y</code> could be parsed as <code>(x -) + y</code> as well as <code>x - (+ y)</code>. More subtly, LES does not define any operators that could take binary or suffix roles, because that would also be ambiguous. For example, suppose <code>|?|</code> is a binary or suffix operator, but not a prefix operator. Clearly <code>x |?| y</code> and <code>x |?| |?| y</code> are unambiguous, but <code>x |?| + y</code> is ambiguous: it could be parsed as <code>(x |?|) + y</code> or <code>x |?| (+ y)</code>. It turns out that a computer language can contain operators that serve as binary and prefix operators, OR it can contain operators that serve as binary and suffix operators, but a language is ambiguous if it has both kinds of operators at the same time.</p>
<h3>How to detect an operator's precedence</h3>
<p>To determine the precedence of any given operator, first you must decide, mainly based on the context in which the operator appears and the text of the operator, whether it is a prefix, binary, or suffix operator. Suffix operators can only be derived from the operators <code>++, &ndash;</code> ("derived" means that you can add additional operator characters in the middle, e.g. <code>+++</code> and <code>-%-</code> are can be prefix or suffix operators.) </p>
<p>If an operator starts with a single quote in LESv3 ('), the quote is not considered for the purpose of choosing precedence (rather, it is used to allow letters and digits in the operator name). </p>
<p>Next, if the operator is only one character, simply find it in the list of operators in the previous section to learn its precedence. If the operator is two or more characters, take the first character A and the and the last character Z, and of the following rules, use the <b>first</b> rule that applies: </p><ol>
<li>
If AZ is "!=" or "==", or if the operator is exactly two characters long (ignoring the initial single quote) and equal to "&gt;=", or "&amp;lt;=", its precedence is Compare. This rule separates comparison operators from assignment operators, so that "&gt;&gt;=" is different from "&gt;=", and "===" counts as a comparison operator. </li>
<li>
If it's an infix operator and Z is '=', the precedence is Assign. </li>
<li>
Look for an operator named AZ from the section above. If it is defined, the operator will have the same precedence. For example, binary <code>=|&gt;</code> has the same precedence as binary "=&gt;". </li>
<li>
Otherwise, look for an entry in the table for Z. For example, binary "%+" has the same precedence as binary "+" and unary "-*" has the same precedence as unary "*". </li>
<li>
If the operator is not an infix operator, it is illegal (e.g. prefix ?? doesn't exist). </li>
<li>
If A is a lowercase letter, the precedence is LowerKeyword. </li>
<li>
Otherwise, the operator's precedence is Other. </li>
</ol>
<p>The double-colon :: has the "wrong" precedence according to C# and C++ rules; <code>a.b::c.d</code> is parsed <code>(a.b)::(c.d)</code> although it would be parsed <code>((a.b)::c).d</code> in C# and C++. The change in precedence allows double colon to be used for variable declarations in <a class="el" href="namespaceLeMP.html" title="The lexical macro processor. Main classes: LeMP.Compiler and LeMP.MacroProcessor.">LeMP</a>, as in <code>x::System.Drawing.Point</code>. The lower precedence allows this to be parsed properly, but it sacrifices full fidelity with C#/C++. </p>
<p>There are no ternary operators in LES. '?' and ':' are right-associative binary operators, so <code>c ? a : b</code> is parsed as <code>c ? (a : b)</code>. The lack of an official ternary operator reduces the complexity of the parser. </p>
<p>LES represents <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject....">Loyc</a> trees, which do not distinguish operators and functions except by name; <code>x += y</code> is equivalent to the function call <code>&lsquo;&rsquo;+=&lsquo;(x, y)</code> in LESv3 (<code>&amp;rsquo;+=(x, y)</code> in LESv2), and the actual name of the function is <code>'+=</code>. Operators that do not start with a single quote in LES <b>do</b> start with a single quote in the final output (e.g. <code>2 + 2</code> is equivalent to <code>2 '+ 2</code>). There is an exception: While prefix ++ and &ndash; are named <code>'++</code> and <code>'&ndash;</code>, the suffix versions are named <code>'suf++</code> and <code>'suf&ndash;</code> in the output tree. For LESv2 operators surrounded by <code>backquotes</code>, the backquotes are not included in the output tree (e.g. <code><code>sqrt</code> x</code> is equivalent to <code>sqrt(x)</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a></dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:aa9bb5712f99ff67bd856e332d50f1d01"><td class="memItemLeft" align="right" valign="top"><a id="aa9bb5712f99ff67bd856e332d50f1d01"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Substitute</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(111, 110)</td></tr>
<tr class="separator:aa9bb5712f99ff67bd856e332d50f1d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a6428206281c4f6f43858724719ab8"><td class="memItemLeft" align="right" valign="top"><a id="a43a6428206281c4f6f43858724719ab8"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Of</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(106, 105)</td></tr>
<tr class="separator:a43a6428206281c4f6f43858724719ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edd74b62cc04e05ac3d6f8c28912d80"><td class="memItemLeft" align="right" valign="top"><a id="a6edd74b62cc04e05ac3d6f8c28912d80"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Primary</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(100)</td></tr>
<tr class="separator:a6edd74b62cc04e05ac3d6f8c28912d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5853313fb3a547b31be9e4ffd0e9d04"><td class="memItemLeft" align="right" valign="top"><a id="ad5853313fb3a547b31be9e4ffd0e9d04"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NullDot</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(95)</td></tr>
<tr class="separator:ad5853313fb3a547b31be9e4ffd0e9d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3643f997f23a10e9eb60ec53073ce5"><td class="memItemLeft" align="right" valign="top"><a id="abd3643f997f23a10e9eb60ec53073ce5"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Power</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(91, 90)</td></tr>
<tr class="separator:abd3643f997f23a10e9eb60ec53073ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b018cf348cd17f3ef2c3cf2a4cd150"><td class="memItemLeft" align="right" valign="top"><a id="a22b018cf348cd17f3ef2c3cf2a4cd150"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Prefix</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(111, 85, 85, 85)</td></tr>
<tr class="separator:a22b018cf348cd17f3ef2c3cf2a4cd150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47477edbaa9e216296df212217e34de4"><td class="memItemLeft" align="right" valign="top"><a id="a47477edbaa9e216296df212217e34de4"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SuffixWord</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(80, 111, 80, 80)</td></tr>
<tr class="separator:a47477edbaa9e216296df212217e34de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd71e268cfda5994bf20466134cd60bd"><td class="memItemLeft" align="right" valign="top"><a id="afd71e268cfda5994bf20466134cd60bd"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RangePrefix</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(111, 75, 75, 75)</td></tr>
<tr class="separator:afd71e268cfda5994bf20466134cd60bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab052fc9d1095a99bebdc17d6a1e45677"><td class="memItemLeft" align="right" valign="top"><a id="ab052fc9d1095a99bebdc17d6a1e45677"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Range</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(75)</td></tr>
<tr class="separator:ab052fc9d1095a99bebdc17d6a1e45677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd730beb81800989d1baf39cd14e8e4a"><td class="memItemLeft" align="right" valign="top"><a id="abd730beb81800989d1baf39cd14e8e4a"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Multiply</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(70)</td></tr>
<tr class="separator:abd730beb81800989d1baf39cd14e8e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d1884a1356976d44ddf566da590a11"><td class="memItemLeft" align="right" valign="top"><a id="a21d1884a1356976d44ddf566da590a11"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>UpperWord</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(65)</td></tr>
<tr class="separator:a21d1884a1356976d44ddf566da590a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932f4658b28a49e4a3f75a5bcebaa0d1"><td class="memItemLeft" align="right" valign="top"><a id="a932f4658b28a49e4a3f75a5bcebaa0d1"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Shift</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(65, 65, 60, 65)</td></tr>
<tr class="separator:a932f4658b28a49e4a3f75a5bcebaa0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c461632e9c21933f00277aa592f006"><td class="memItemLeft" align="right" valign="top"><a id="a95c461632e9c21933f00277aa592f006"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Other</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(65, 65, 55, 70)</td></tr>
<tr class="separator:a95c461632e9c21933f00277aa592f006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4ddb4ba8c513e7206a52f5d910a81c"><td class="memItemLeft" align="right" valign="top"><a id="ade4ddb4ba8c513e7206a52f5d910a81c"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Add</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(60)</td></tr>
<tr class="separator:ade4ddb4ba8c513e7206a52f5d910a81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616c621732f21105b3b1622a82b65b41"><td class="memItemLeft" align="right" valign="top"><a id="a616c621732f21105b3b1622a82b65b41"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Squiggly</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(55)</td></tr>
<tr class="separator:a616c621732f21105b3b1622a82b65b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594dfe5a4a3922a8fdfa267caed7ad02"><td class="memItemLeft" align="right" valign="top"><a id="a594dfe5a4a3922a8fdfa267caed7ad02"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SquigglyPrefix</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(111,55,55,55)</td></tr>
<tr class="separator:a594dfe5a4a3922a8fdfa267caed7ad02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5da27c4ee9c4ee5099d934eed2bc1a"><td class="memItemLeft" align="right" valign="top"><a id="a2a5da27c4ee9c4ee5099d934eed2bc1a"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AndBits</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(52, 52, 35, 52)</td></tr>
<tr class="separator:a2a5da27c4ee9c4ee5099d934eed2bc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46008db0862f5210f48568347c7c15f4"><td class="memItemLeft" align="right" valign="top"><a id="a46008db0862f5210f48568347c7c15f4"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OrBits</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(50, 50, 35, 52)</td></tr>
<tr class="separator:a46008db0862f5210f48568347c7c15f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f9c846992b5c44be8e41f211e3387b"><td class="memItemLeft" align="right" valign="top"><a id="a64f9c846992b5c44be8e41f211e3387b"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OrIfNull</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(45)</td></tr>
<tr class="separator:a64f9c846992b5c44be8e41f211e3387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185d971d56531e611cf75bb4d95a9cd9"><td class="memItemLeft" align="right" valign="top"><a id="a185d971d56531e611cf75bb4d95a9cd9"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Compare</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(40)</td></tr>
<tr class="separator:a185d971d56531e611cf75bb4d95a9cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da84af5647ddbd1b356b9e2a0009123"><td class="memItemLeft" align="right" valign="top"><a id="a6da84af5647ddbd1b356b9e2a0009123"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AndBitsLES2</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(37, 37, 35, 52)</td></tr>
<tr class="separator:a6da84af5647ddbd1b356b9e2a0009123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab311d98790ef82827d9ec885b8d0d086"><td class="memItemLeft" align="right" valign="top"><a id="ab311d98790ef82827d9ec885b8d0d086"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OrBitsLES2</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(35, 35, 35, 52)</td></tr>
<tr class="separator:ab311d98790ef82827d9ec885b8d0d086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3034b4106944c716aee464d6494ec2"><td class="memItemLeft" align="right" valign="top"><a id="aff3034b4106944c716aee464d6494ec2"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Arrow</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(31, 30)</td></tr>
<tr class="separator:aff3034b4106944c716aee464d6494ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b39cd2d38208e094b8e1ceb5b519b0"><td class="memItemLeft" align="right" valign="top"><a id="af9b39cd2d38208e094b8e1ceb5b519b0"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ArrowPrefix</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(111, 30, 30, 30)</td></tr>
<tr class="separator:af9b39cd2d38208e094b8e1ceb5b519b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bbf445cfa6a8d2213fc5442b0f25f6"><td class="memItemLeft" align="right" valign="top"><a id="ab8bbf445cfa6a8d2213fc5442b0f25f6"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>And</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(25)</td></tr>
<tr class="separator:ab8bbf445cfa6a8d2213fc5442b0f25f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4ee7b7939ea8136ba9e4db6c25a181"><td class="memItemLeft" align="right" valign="top"><a id="a8e4ee7b7939ea8136ba9e4db6c25a181"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Or</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(20)</td></tr>
<tr class="separator:a8e4ee7b7939ea8136ba9e4db6c25a181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8df17dd1636a6d89d3459bee50d4cc7"><td class="memItemLeft" align="right" valign="top"><a id="af8df17dd1636a6d89d3459bee50d4cc7"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IfElse</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(16, 15)</td></tr>
<tr class="separator:af8df17dd1636a6d89d3459bee50d4cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625c4d7d8cd282772557de160ce661a8"><td class="memItemLeft" align="right" valign="top"><a id="a625c4d7d8cd282772557de160ce661a8"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ColonArrowPrefix</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(111, 15)</td></tr>
<tr class="separator:a625c4d7d8cd282772557de160ce661a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33c3738835ef2fadb907f22cac08bdb"><td class="memItemLeft" align="right" valign="top"><a id="ac33c3738835ef2fadb907f22cac08bdb"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Assign</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(28, 10, 10, 10)</td></tr>
<tr class="separator:ac33c3738835ef2fadb907f22cac08bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34d72365790ab39b4f37b29ebf14036"><td class="memItemLeft" align="right" valign="top"><a id="af34d72365790ab39b4f37b29ebf14036"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LowerKeyword</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(6, 5, 5, 5)</td></tr>
<tr class="separator:af34d72365790ab39b4f37b29ebf14036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46260591bdf468d70b22f019872fa212"><td class="memItemLeft" align="right" valign="top"><a id="a46260591bdf468d70b22f019872fa212"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Lambda</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(48, 0, 0, 0)</td></tr>
<tr class="separator:a46260591bdf468d70b22f019872fa212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a096c44c461a59eafff5fa959df8248"><td class="memItemLeft" align="right" valign="top"><a id="a5a096c44c461a59eafff5fa959df8248"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LambdaPrefix</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(111, 0, 0, 0)</td></tr>
<tr class="separator:a5a096c44c461a59eafff5fa959df8248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dbf813c7f19b6d9a38c727a29728a6"><td class="memItemLeft" align="right" valign="top"><a id="a56dbf813c7f19b6d9a38c727a29728a6"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Triangle</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(-5)</td></tr>
<tr class="separator:a56dbf813c7f19b6d9a38c727a29728a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc103d1b5bda16d30666cd1680d8aaba"><td class="memItemLeft" align="right" valign="top"><a id="afc103d1b5bda16d30666cd1680d8aaba"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TrianglePrefix</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(111, -5)</td></tr>
<tr class="separator:afc103d1b5bda16d30666cd1680d8aaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c6be7119cc38dd5e2cf720c4e2b146"><td class="memItemLeft" align="right" valign="top"><a id="a92c6be7119cc38dd5e2cf720c4e2b146"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SuperExpr</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(-10)</td></tr>
<tr class="separator:a92c6be7119cc38dd5e2cf720c4e2b146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c336b6683d38453a11cea89a9c9110"><td class="memItemLeft" align="right" valign="top"><a id="a11c336b6683d38453a11cea89a9c9110"></a>
static readonly <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Illegal</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(58)</td></tr>
<tr class="separator:a11c336b6683d38453a11cea89a9c9110"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 3 2020 16:52:18 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
