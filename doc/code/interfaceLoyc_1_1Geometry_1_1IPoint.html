<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Enhanced C#: Loyc.Geometry.IPoint&lt; T &gt; Interface Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Geometry.html">Geometry</a></li><li class="navelem"><a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html">IPoint</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="interfaceLoyc_1_1Geometry_1_1IPoint-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Geometry.IPoint&lt; T &gt; Interface Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A mutable 2D point with X and Y coordinates.  
 <a href="interfaceLoyc_1_1Geometry_1_1IPoint.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Interfaces/Geometry/IPoint.cs'>/Core/Loyc.Interfaces/Geometry/IPoint.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Geometry.IPoint&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interfaceLoyc_1_1Geometry_1_1IPoint.png" usemap="#Loyc.Geometry.IPoint_3C_20T_20_3E_map" alt=""/>
  <map id="Loyc.Geometry.IPoint_3C_20T_20_3E_map" name="Loyc.Geometry.IPoint_3C_20T_20_3E_map">
<area href="interfaceLoyc_1_1Geometry_1_1IPointBase.html" title="This interface exists to work around a limitation of C#; use IPoint&lt;T&gt; instead." alt="Loyc.Geometry.IPointBase&lt; T &gt;" shape="rect" coords="0,56,260,80"/>
<area href="interfaceLoyc_1_1Geometry_1_1INewPoint.html" alt="Loyc.Geometry.INewPoint&lt; IPoint&lt; T &gt;, T &gt;" shape="rect" coords="270,56,530,80"/>
<area href="interfaceLoyc_1_1Geometry_1_1IPointReader.html" title="Interface for reading the coordinates of a 2D point." alt="Loyc.Geometry.IPointReader&lt; T &gt;" shape="rect" coords="0,0,260,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>A mutable 2D point with X and Y coordinates. </p>
<p>WARNING: When casting a point (or vector) structure to this interface, it is boxed, making a copy. Changes made through a reference to <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> do not affect the original point! </p>
<p>It is important to distinguish between generic code that operates on points (e.g. Foo&lt;Point,T&gt;(Point x) where Point:<a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>&lt;T&gt;) and code that uses the <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> interface directly (e.g. Foo(<a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>&lt;int&gt;) or even Foo&lt;T&gt;(<a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>&lt;T&gt; x)). The latter uses slow, late-bound interface calls and the boxing-copy issue mentioned before must be kept in mind. Generic code that uses <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> as a <em>constraint</em>, not as a <em>parameter type,</em> is faster and does not have the same problem because it does not actually box the point, nor does it use late-bound invocation. </p>
<p>Normally this interface is not used directly, and the only operation provided is New(). It is provided in case you want it, but generally it's better to use Point&lt;T&gt;. </p>
<p>In order for this interface to work more easily in generic code, there is no corresponding IVector type for vectors because generic code must declare every type it needs as a separate type parameter, which makes the code very cumbersome to write already, even without a point/vector distinction. </p>
<p>The New() method is not normally used in generic code because it returns <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>&lt;T&gt;, not the original point type. It is provided mainly in case somebody wants to use the raw interface to manipulate points. </p>
<p>Due to a limitation of C#, the X and Y coordinates are separated into a separate interface (IPointBase&lt;T&gt;) from the New() method in INewPoint&lt;Point,T&gt;. Without this separation, it's impossible to write fast generic code that can operate on both <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> itself and on concrete types such as Point&lt;T&gt;. The reason for this is very subtle. To understand it, consider the following generic method that adds two points together: </p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point Add&lt;Point,T,M&gt;(<span class="keyword">this</span> M m, Point a, Point b)</div>
<div class="line">    where Point : IPoint&lt;T&gt;</div>
<div class="line">    where M : IAdditionGroup&lt;T&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> a.New(m.Add(a.X, b.X), m.Add(a.Y, b.Y));</div>
<div class="line">}</div>
</div><!-- fragment --><p> As written, this code does not compile. The reason is that a.New() does not return a Point; instead, it returns IPoint&lt;T&gt;, which is a more general (interface) type than Point (which is probably a struct). Therefore, in order for the code above to work, a cast from <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> to Point would be necessary. However, the boxing performed by new() and the unboxing performed by the cast will slow down the method. My goal, however, is to allow generic code to run fast; otherwise it's hard to justify the extra effort required to make the code generic. After all, the code to add non-generic points is trivial in comparison: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> PointD <a class="code" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Add</a>(PointD a, PointD b) { <span class="keywordflow">return</span> a + b; }</div>
</div><!-- fragment --><p> You might think to yourself, "okay, why don't we just add a new() 
constraint on Point?" In that case the Add() method can be written as follows: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point Add&lt;Point,T,M&gt;(<span class="keyword">this</span> M m, Point a, Point b)</div>
<div class="line">    where Point : IPoint&lt;T&gt;, <span class="keyword">new</span>()</div>
<div class="line">    where M : IAdditionGroup&lt;T&gt;</div>
<div class="line">{</div>
<div class="line">    Point p = <span class="keyword">new</span> Point();</div>
<div class="line">    p.X = m.Add(a.X, b.X);</div>
<div class="line">    p.Y = m.Add(a.Y, b.Y);</div>
<div class="line">    <span class="keywordflow">return</span> p;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This works if the input is a concrete point type, but this version of the method cannot be used if Point happens to be IPoint&lt;T&gt; itself; you cannot do "new IPoint" because it is an interface. To solve this I considered splitting out New() into a separate interface and using it as a constraint of the generic method: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point Add&lt;Point,T,M&gt;(<span class="keyword">this</span> M m, Point a, Point b)</div>
<div class="line">    where Point : IPoint&lt;T&gt;, INewPoint&lt;Point, T&gt;</div>
<div class="line">    where M : IAdditionGroup&lt;T&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> a.New(m.Add(a.X, b.X), m.Add(a.Y, b.Y));</div>
<div class="line">}</div>
</div><!-- fragment --><p> This code compiles under one condition: <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> must <em>not</em> be derived from <a class="el" href="interfaceLoyc_1_1Geometry_1_1INewPoint.html" title="This interface exists to work around a limitation of C#; see IPoint&lt;T&gt;.">INewPoint</a>&lt;<a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>&lt;T&gt;,T&gt;. Because if it is, then the call to New() is ambiguous: does a.New() refer to <a class="el" href="interfaceLoyc_1_1Geometry_1_1INewPoint.html" title="This interface exists to work around a limitation of C#; see IPoint&lt;T&gt;.">INewPoint</a>&lt;<a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>&lt;T&gt;,T&gt;.New() or to <a class="el" href="interfaceLoyc_1_1Geometry_1_1INewPoint.html" title="This interface exists to work around a limitation of C#; see IPoint&lt;T&gt;.">INewPoint</a>&lt;Point,T&gt;.New()? Remember, <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> is not the same as Point from the compiler's perspective&ndash;<a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> is an interface, but Point is typically a struct (it could be the same as <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>, but in general, it is not). The compiler doesn't know which version of New() to call, so it refuses to compile the code. It will compile if we change the method body to </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> ((INewPoint&lt;Point,T&gt;)a).New(m.Add(a.X, b.X), m.Add(a.Y, b.Y));</div>
</div><!-- fragment --><p> The cast resolves the ambiguity, but as a side-effect, 'a' is boxed and the call to New() becomes a virtual call that cannot be inlined. So the same performance penalty is back! </p>
<p>But as I was saying, the original code does compile if <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> is <em>not</em> derived from <a class="el" href="interfaceLoyc_1_1Geometry_1_1INewPoint.html" title="This interface exists to work around a limitation of C#; see IPoint&lt;T&gt;.">INewPoint</a>. Unfortunately, if <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> is not derived from <a class="el" href="interfaceLoyc_1_1Geometry_1_1INewPoint.html" title="This interface exists to work around a limitation of C#; see IPoint&lt;T&gt;.">INewPoint</a> then it is impossible to pass a reference to <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> to this method (because it no longer meets the constraints). Remember, that is the limitation I am trying to avoid! </p>
<p>One more "solution" is not to create any new points: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point Add&lt;Point,T,M&gt;(<span class="keyword">this</span> M m, Point a, Point b)</div>
<div class="line">    where Point : IPoint&lt;T&gt;</div>
<div class="line">    where M : IAdditionGroup&lt;T&gt;</div>
<div class="line">{</div>
<div class="line">    a.X = m.Add(a.X, b.X);</div>
<div class="line">    a.Y = m.Add(a.Y, b.Y);</div>
<div class="line">    <span class="keywordflow">return</span> a;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Alas, this version of the code modifies the point 'a' if Point is <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>, but it does not modify 'a' if Point is a struct, because structs are passed by value. This inconsistency is not acceptable, and besides, there are (of course) situations where creating new points is required. </p>
<p>The problem is that if there is only one New() method defined (in the point structures such as PointI and PointD) then it's impossible to pass references to <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> to Add(); however, if there are two New() methods (one in the point struct and one in <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>), it is impossible to tell the C# compiler which method we want to call without slowing down the code as a side-effect. My solution to this very peculiar problem is to split <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> into two independent interfaces, <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPointBase.html" title="This interface exists to work around a limitation of C#; use IPoint&lt;T&gt; instead.">IPointBase</a> and <a class="el" href="interfaceLoyc_1_1Geometry_1_1INewPoint.html" title="This interface exists to work around a limitation of C#; see IPoint&lt;T&gt;.">INewPoint</a>. This separation allows us to tell the C# compiler that Point implements only one of the New() methods, not both: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point Add&lt;Point,T,M&gt;(<span class="keyword">this</span> M m, Point a, Point b)</div>
<div class="line">    where Point : IPointBase&lt;T&gt;, INewPoint&lt;Point, T&gt;</div>
<div class="line">    where M : IAdditionGroup&lt;T&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> a.New(m.Add(a.X, b.X), m.Add(a.Y, b.Y));</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPointBase.html" title="This interface exists to work around a limitation of C#; use IPoint&lt;T&gt; instead.">IPointBase</a>, unlike <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>, does not have a New() method, so only the New() method in <a class="el" href="interfaceLoyc_1_1Geometry_1_1INewPoint.html" title="This interface exists to work around a limitation of C#; see IPoint&lt;T&gt;.">INewPoint</a>&lt;Point, T&gt; is available to be called, and the C# compiler stops complaining. Also, since <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>&lt;T&gt; implements both <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPointBase.html" title="This interface exists to work around a limitation of C#; use IPoint&lt;T&gt; instead.">IPointBase</a>&lt;T&gt; and <a class="el" href="interfaceLoyc_1_1Geometry_1_1INewPoint.html" title="This interface exists to work around a limitation of C#; see IPoint&lt;T&gt;.">INewPoint</a>&lt;<a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>&lt;T&gt;, T&gt;, it meets the generic constraints of this method and can be passed to it. </p>
<p>Note that you don't have to write methods like Add() yourself (they are provided as extension methods on <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>.) Still, if you've read this far, you're probably now afraid of the effort required to write generic code! Your fear may be justified. But there is another, easier way that you can write generic code, based on Point&lt;T&gt; instead of <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a>: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point&lt;T&gt; Add&lt;T&gt;(Point&lt;T&gt; a, Point&lt;T&gt; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> a+b;</div>
<div class="line">}</div>
</div><!-- fragment --><p> A lot easier without all those constraints, yes? The main disadvantage of this version is that it doesn't have great performance, because the additions are done through interface calls. A second disadvantage is that you can't pass an <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> to it. That's okay because as stated before, normally the <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> interface is not used directly! </p>
<p>Code that uses Point&lt;T,M&gt; can run faster: </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point&lt;T,M&gt; Add&lt;T,M&gt;(Point&lt;T,M&gt; a, Point&lt;T,M&gt; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> a+b;</div>
<div class="line">}</div>
</div><!-- fragment --><p> So, in summary, supporting fast generic code that can also operate on <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPoint.html" title="A mutable 2D point with X and Y coordinates.">IPoint</a> requires this odd arrangement of interfaces, and if you want to write such generic code then you will need three type parameters (Point, T and M) with the following constraints: </p><div class="fragment"><div class="line">where Point : IPointBase&lt;T&gt;, INewPoint&lt;Point, T&gt;</div>
<div class="line">where M : IMath&lt;T&gt; <span class="comment">// or another math interface</span></div>
</div><!-- fragment --><p> It may help to place your methods in a generic class (of Point, T and M) so that you only have to write the constraints once. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header properties_interfaceLoyc_1_1Geometry_1_1IPointBase"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceLoyc_1_1Geometry_1_1IPointBase')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPointBase.html">Loyc.Geometry.IPointBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a8ee534b6b2b1d444c87516181584392e inherit properties_interfaceLoyc_1_1Geometry_1_1IPointBase"><td class="memItemLeft" align="right" valign="top">new T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Geometry_1_1IPointBase.html#a8ee534b6b2b1d444c87516181584392e">X</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a8ee534b6b2b1d444c87516181584392e inherit properties_interfaceLoyc_1_1Geometry_1_1IPointBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontal coordinate of a point or vector.  <a href="interfaceLoyc_1_1Geometry_1_1IPointBase.html#a8ee534b6b2b1d444c87516181584392e">More...</a><br /></td></tr>
<tr class="separator:a8ee534b6b2b1d444c87516181584392e inherit properties_interfaceLoyc_1_1Geometry_1_1IPointBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707be43f39d9a7680a9f3e8bc33f446d inherit properties_interfaceLoyc_1_1Geometry_1_1IPointBase"><td class="memItemLeft" align="right" valign="top">new T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Geometry_1_1IPointBase.html#a707be43f39d9a7680a9f3e8bc33f446d">Y</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a707be43f39d9a7680a9f3e8bc33f446d inherit properties_interfaceLoyc_1_1Geometry_1_1IPointBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertical coordinate of a point or vector.  <a href="interfaceLoyc_1_1Geometry_1_1IPointBase.html#a707be43f39d9a7680a9f3e8bc33f446d">More...</a><br /></td></tr>
<tr class="separator:a707be43f39d9a7680a9f3e8bc33f446d inherit properties_interfaceLoyc_1_1Geometry_1_1IPointBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interfaceLoyc_1_1Geometry_1_1IPointReader"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceLoyc_1_1Geometry_1_1IPointReader')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceLoyc_1_1Geometry_1_1IPointReader.html">Loyc.Geometry.IPointReader&lt; T &gt;</a></td></tr>
<tr class="memitem:a79907cdff0282a6927177f40d966db65 inherit properties_interfaceLoyc_1_1Geometry_1_1IPointReader"><td class="memItemLeft" align="right" valign="top"><a id="a79907cdff0282a6927177f40d966db65"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>X</b><code> [get]</code></td></tr>
<tr class="separator:a79907cdff0282a6927177f40d966db65 inherit properties_interfaceLoyc_1_1Geometry_1_1IPointReader"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b2b15c489132c13a073e3063af513e inherit properties_interfaceLoyc_1_1Geometry_1_1IPointReader"><td class="memItemLeft" align="right" valign="top"><a id="a93b2b15c489132c13a073e3063af513e"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>Y</b><code> [get]</code></td></tr>
<tr class="separator:a93b2b15c489132c13a073e3063af513e inherit properties_interfaceLoyc_1_1Geometry_1_1IPointReader"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interfaceLoyc_1_1Geometry_1_1INewPoint"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interfaceLoyc_1_1Geometry_1_1INewPoint')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interfaceLoyc_1_1Geometry_1_1INewPoint.html">Loyc.Geometry.INewPoint&lt; IPoint&lt; T &gt;, T &gt;</a></td></tr>
<tr class="memitem:ab07cbe25b7ae1fe2a4d34ae5f8000a8a inherit pub_methods_interfaceLoyc_1_1Geometry_1_1INewPoint"><td class="memItemLeft" align="right" valign="top"><a id="ab07cbe25b7ae1fe2a4d34ae5f8000a8a"></a>
Point&#160;</td><td class="memItemRight" valign="bottom"><b>New</b> (T x, T y)</td></tr>
<tr class="separator:ab07cbe25b7ae1fe2a4d34ae5f8000a8a inherit pub_methods_interfaceLoyc_1_1Geometry_1_1INewPoint"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<div class="ttc" id="anamespaceLoyc_1_1Collections_html_ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9"><div class="ttname"><a href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Loyc.Collections.AListOperation.Add</a></div><div class="ttdeci">@ Add</div><div class="ttdoc">A new item will be added unconditionally, without affecting existing elements, in no particular order...</div></div>
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 5 2020 09:07:39 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
