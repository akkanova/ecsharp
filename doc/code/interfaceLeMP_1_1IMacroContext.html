<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Enhanced C#: LeMP.IMacroContext Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLeMP.html">LeMP</a></li><li class="navelem"><a class="el" href="interfaceLeMP_1_1IMacroContext.html">IMacroContext</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interfaceLeMP_1_1IMacroContext-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LeMP.IMacroContext Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This interface provides services offered by the lexical macro processor (<a class="el" href="namespaceLeMP.html" title="The lexical macro processor. Main classes: LeMP.Compiler and LeMP.MacroProcessor.">LeMP</a>).  
 <a href="interfaceLeMP_1_1IMacroContext.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Syntax/LeMP/IMacroContext.cs'>/Core/Loyc.Syntax/LeMP/IMacroContext.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for LeMP.IMacroContext:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interfaceLeMP_1_1IMacroContext.png" usemap="#LeMP.IMacroContext_map" alt=""/>
  <map id="LeMP.IMacroContext_map" name="LeMP.IMacroContext_map">
<area href="interfaceLoyc_1_1IMessageSink.html" title="A general-purpose interface for a class that accepts formatted messages with context information." alt="Loyc.IMessageSink&lt; in in TContext &gt;" shape="rect" coords="0,0,225,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>This interface provides services offered by the lexical macro processor (<a class="el" href="namespaceLeMP.html" title="The lexical macro processor. Main classes: LeMP.Compiler and LeMP.MacroProcessor.">LeMP</a>). </p>
<p>Macros receive this as their second argument (see <a class="el" href="namespaceLeMP.html#af4fd3c217e2a127d5546c3b99a7f3576" title="Method signature of an LeMP macro.">LexicalMacro</a>)</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a8419c79777d647e75169adb9a3968ee8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceLoyc_1_1IMessageSink.html">IMessageSink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#a8419c79777d647e75169adb9a3968ee8">Sink</a><code> [get]</code></td></tr>
<tr class="memdesc:a8419c79777d647e75169adb9a3968ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the message sink, used for writing warnings and errors.  <a href="interfaceLeMP_1_1IMacroContext.html#a8419c79777d647e75169adb9a3968ee8">More...</a><br /></td></tr>
<tr class="separator:a8419c79777d647e75169adb9a3968ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12883b70ba50042d8fbda2e89e43b4f5"><td class="memItemLeft" align="right" valign="top">IDictionary&lt; object, object &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#a12883b70ba50042d8fbda2e89e43b4f5">ScopedProperties</a><code> [get]</code></td></tr>
<tr class="memdesc:a12883b70ba50042d8fbda2e89e43b4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a table of "properties" (arbitrary key-value pairs) that exist in the current scope. This dictionary is "persistent" in the computer science sense; any changes to these properties affect only the current scope and child scopes. When the current scope ends, the set of properties that existed in the parent scope are restored.  <a href="interfaceLeMP_1_1IMacroContext.html#a12883b70ba50042d8fbda2e89e43b4f5">More...</a><br /></td></tr>
<tr class="separator:a12883b70ba50042d8fbda2e89e43b4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6b2fbd85b1bb5fb33bf25f04aa890b"><td class="memItemLeft" align="right" valign="top">IReadOnlyList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#abb6b2fbd85b1bb5fb33bf25f04aa890b">Ancestors</a><code> [get]</code></td></tr>
<tr class="memdesc:abb6b2fbd85b1bb5fb33bf25f04aa890b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of ancestors of the current node being processed. Normally Ancestors[0] is a #splice node that contains a list of all top-level statements in the file, and Ancestors.Last() is the current node.  <a href="interfaceLeMP_1_1IMacroContext.html#abb6b2fbd85b1bb5fb33bf25f04aa890b">More...</a><br /></td></tr>
<tr class="separator:abb6b2fbd85b1bb5fb33bf25f04aa890b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681a62874a05eee15058bd1723403ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#a681a62874a05eee15058bd1723403ce4">Parent</a><code> [get]</code></td></tr>
<tr class="memdesc:a681a62874a05eee15058bd1723403ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the logical parent of the current node, which is <code>Ancestors[Ancestors.Count - 2]</code>, or null if the current node is the root node.  <a href="interfaceLeMP_1_1IMacroContext.html#a681a62874a05eee15058bd1723403ce4">More...</a><br /></td></tr>
<tr class="separator:a681a62874a05eee15058bd1723403ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68425589ee09ef9f92085782abf8b53b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">IListSource</a>&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#a68425589ee09ef9f92085782abf8b53b">RemainingNodes</a><code> [get]</code></td></tr>
<tr class="memdesc:a68425589ee09ef9f92085782abf8b53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of the remaining nodes (arguments/statements or attributes) after this point in the code stream.  <a href="interfaceLeMP_1_1IMacroContext.html#a68425589ee09ef9f92085782abf8b53b">More...</a><br /></td></tr>
<tr class="separator:a68425589ee09ef9f92085782abf8b53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af6d218898eab6b531fc296fd915c9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#a1af6d218898eab6b531fc296fd915c9a">IsAttribute</a><code> [get]</code></td></tr>
<tr class="memdesc:a1af6d218898eab6b531fc296fd915c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current node is in the attribute list of its immediate parent.  <a href="interfaceLeMP_1_1IMacroContext.html#a1af6d218898eab6b531fc296fd915c9a">More...</a><br /></td></tr>
<tr class="separator:a1af6d218898eab6b531fc296fd915c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490691aaae9c12a3cc213ad4b1024dbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#a490691aaae9c12a3cc213ad4b1024dbd">IsTarget</a><code> [get]</code></td></tr>
<tr class="memdesc:a490691aaae9c12a3cc213ad4b1024dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current node is the target of its parent call node.  <a href="interfaceLeMP_1_1IMacroContext.html#a490691aaae9c12a3cc213ad4b1024dbd">More...</a><br /></td></tr>
<tr class="separator:a490691aaae9c12a3cc213ad4b1024dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada43164412ec526c6e8d081cbb43b5c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#ada43164412ec526c6e8d081cbb43b5c1">DropRemainingNodes</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ada43164412ec526c6e8d081cbb43b5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets a value that indicates whether to drop all remaining node after the current one when the current macro returns. This property has no effect if the macro rejects the input by returning null.  <a href="interfaceLeMP_1_1IMacroContext.html#ada43164412ec526c6e8d081cbb43b5c1">More...</a><br /></td></tr>
<tr class="separator:ada43164412ec526c6e8d081cbb43b5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f39549b84ec729a461c784f3a3a0ab"><td class="memItemLeft" align="right" valign="top">IReadOnlyDictionary&lt; <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a>, <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt; <a class="el" href="classLeMP_1_1MacroInfo.html">MacroInfo</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#ab7f39549b84ec729a461c784f3a3a0ab">AllKnownMacros</a><code> [get]</code></td></tr>
<tr class="memdesc:ab7f39549b84ec729a461c784f3a3a0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information about all macros registered with the macro processor, including macros whose namespace has not been opened with <code>#importMacros</code>.  <a href="interfaceLeMP_1_1IMacroContext.html#ab7f39549b84ec729a461c784f3a3a0ab">More...</a><br /></td></tr>
<tr class="separator:ab7f39549b84ec729a461c784f3a3a0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ba92c4e19b86ca5f7ed0972518df7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#ad4ba92c4e19b86ca5f7ed0972518df7e">NextTempCounter</a><code> [get]</code></td></tr>
<tr class="memdesc:ad4ba92c4e19b86ca5f7ed0972518df7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next number to use as a suffix for temporary variables (without incrementing).  <a href="interfaceLeMP_1_1IMacroContext.html#ad4ba92c4e19b86ca5f7ed0972518df7e">More...</a><br /></td></tr>
<tr class="separator:ad4ba92c4e19b86ca5f7ed0972518df7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2a6f20e79b626a1c314c9442d1beca2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#a2a6f20e79b626a1c314c9442d1beca2e">PreProcessChildren</a> ()</td></tr>
<tr class="memdesc:a2a6f20e79b626a1c314c9442d1beca2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies all available macros to the current node's children and returns the result.  <a href="interfaceLeMP_1_1IMacroContext.html#a2a6f20e79b626a1c314c9442d1beca2e">More...</a><br /></td></tr>
<tr class="separator:a2a6f20e79b626a1c314c9442d1beca2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc04e65902e3350fa8c2d1f801891022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Syntax_1_1LNodeList.html">LNodeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#adc04e65902e3350fa8c2d1f801891022">PreProcess</a> (<a class="el" href="structLoyc_1_1Syntax_1_1LNodeList.html">LNodeList</a> input, bool asRoot=false, bool resetOpenNamespaces=false, bool resetProperties=false, bool areAttributes=false)</td></tr>
<tr class="memdesc:adc04e65902e3350fa8c2d1f801891022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the macro processor on the specified node(s).  <a href="interfaceLeMP_1_1IMacroContext.html#adc04e65902e3350fa8c2d1f801891022">More...</a><br /></td></tr>
<tr class="separator:adc04e65902e3350fa8c2d1f801891022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62af6b8bb87db388544528221403a946"><td class="memItemLeft" align="right" valign="top"><a id="a62af6b8bb87db388544528221403a946"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#a62af6b8bb87db388544528221403a946">PreProcess</a> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> input, bool asRoot=false, bool resetOpenNamespaces=false, bool resetProperties=false, bool isTarget=false)</td></tr>
<tr class="separator:a62af6b8bb87db388544528221403a946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0aaef8542273f3c62fa0607ce3cb06e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#af0aaef8542273f3c62fa0607ce3cb06e">IncrementTempCounter</a> ()</td></tr>
<tr class="memdesc:af0aaef8542273f3c62fa0607ce3cb06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next number to use as a suffix for temporary variables, then increments it.  <a href="interfaceLeMP_1_1IMacroContext.html#af0aaef8542273f3c62fa0607ce3cb06e">More...</a><br /></td></tr>
<tr class="separator:af0aaef8542273f3c62fa0607ce3cb06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf41ab5e772b73344f442e010a1a61f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLeMP_1_1IMacroContext.html#aecf41ab5e772b73344f442e010a1a61f">RegisterMacro</a> (<a class="el" href="classLeMP_1_1MacroInfo.html">MacroInfo</a> macroInfo)</td></tr>
<tr class="memdesc:aecf41ab5e772b73344f442e010a1a61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new macro in the current scope.  <a href="interfaceLeMP_1_1IMacroContext.html#aecf41ab5e772b73344f442e010a1a61f">More...</a><br /></td></tr>
<tr class="separator:aecf41ab5e772b73344f442e010a1a61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interfaceLoyc_1_1IMessageSink"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interfaceLoyc_1_1IMessageSink')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interfaceLoyc_1_1IMessageSink.html">Loyc.IMessageSink&lt; in in TContext &gt;</a></td></tr>
<tr class="memitem:a9a94824f7aa5fcf1311cd67edcf4e222 inherit pub_methods_interfaceLoyc_1_1IMessageSink"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1IMessageSink.html#a9a94824f7aa5fcf1311cd67edcf4e222">Write</a> (<a class="el" href="namespaceLoyc.html#aeb4d5c77591b654c8d37485b1dd00f5e">Severity</a> level, TContext context, [Localizable] string format)</td></tr>
<tr class="memdesc:a9a94824f7aa5fcf1311cd67edcf4e222 inherit pub_methods_interfaceLoyc_1_1IMessageSink"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message to the target that this object represents.  <a href="interfaceLoyc_1_1IMessageSink.html#a9a94824f7aa5fcf1311cd67edcf4e222">More...</a><br /></td></tr>
<tr class="separator:a9a94824f7aa5fcf1311cd67edcf4e222 inherit pub_methods_interfaceLoyc_1_1IMessageSink"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44dd26ee810d4ecea40dcd0af78e069 inherit pub_methods_interfaceLoyc_1_1IMessageSink"><td class="memItemLeft" align="right" valign="top"><a id="af44dd26ee810d4ecea40dcd0af78e069"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Write</b> (<a class="el" href="namespaceLoyc.html#aeb4d5c77591b654c8d37485b1dd00f5e">Severity</a> level, TContext context, [Localizable] string format, object arg0, object arg1=null)</td></tr>
<tr class="separator:af44dd26ee810d4ecea40dcd0af78e069 inherit pub_methods_interfaceLoyc_1_1IMessageSink"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6357f7a23a2d6c3153f061a2684a77d8 inherit pub_methods_interfaceLoyc_1_1IMessageSink"><td class="memItemLeft" align="right" valign="top"><a id="a6357f7a23a2d6c3153f061a2684a77d8"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Write</b> (<a class="el" href="namespaceLoyc.html#aeb4d5c77591b654c8d37485b1dd00f5e">Severity</a> level, TContext context, [Localizable] string format, params object[] args)</td></tr>
<tr class="separator:a6357f7a23a2d6c3153f061a2684a77d8 inherit pub_methods_interfaceLoyc_1_1IMessageSink"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db1db5451df906265c101e025accace inherit pub_methods_interfaceLoyc_1_1IMessageSink"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1IMessageSink.html#a6db1db5451df906265c101e025accace">IsEnabled</a> (<a class="el" href="namespaceLoyc.html#aeb4d5c77591b654c8d37485b1dd00f5e">Severity</a> level)</td></tr>
<tr class="memdesc:a6db1db5451df906265c101e025accace inherit pub_methods_interfaceLoyc_1_1IMessageSink"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if messages of the specified type will actually be printed, or false if Write(type, ...) has no effect.  <a href="interfaceLoyc_1_1IMessageSink.html#a6db1db5451df906265c101e025accace">More...</a><br /></td></tr>
<tr class="separator:a6db1db5451df906265c101e025accace inherit pub_methods_interfaceLoyc_1_1IMessageSink"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af0aaef8542273f3c62fa0607ce3cb06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0aaef8542273f3c62fa0607ce3cb06e">&#9670;&nbsp;</a></span>IncrementTempCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LeMP.IMacroContext.IncrementTempCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next number to use as a suffix for temporary variables, then increments it. </p>

</div>
</div>
<a id="adc04e65902e3350fa8c2d1f801891022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc04e65902e3350fa8c2d1f801891022">&#9670;&nbsp;</a></span>PreProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Syntax_1_1LNodeList.html">LNodeList</a> LeMP.IMacroContext.PreProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1LNodeList.html">LNodeList</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asRoot</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetOpenNamespaces</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetProperties</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>areAttributes</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the macro processor on the specified node(s). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The node or node list to process.</td></tr>
    <tr><td class="paramname">asRoot</td><td>If false, the nodes are treated as children of the current node (using the current list of ancestors as a basis); if true, the list of parent nodes is cleared.</td></tr>
    <tr><td class="paramname">resetOpenNamespaces</td><td>If false, the set of open namespaces stays the same; if true it is cleared to the set of pre-opened namespaces (<a class="el" href="classLeMP_1_1MacroProcessor.html#ac7d649b15f5b12c664854825151a5fc1" title="Macros in these namespaces will be available without an explicit import command (#importMacros)....">MacroProcessor.PreOpenedNamespaces</a>) and macros defined with <a class="el" href="interfaceLeMP_1_1IMacroContext.html#aecf41ab5e772b73344f442e010a1a61f" title="Registers a new macro in the current scope.">RegisterMacro</a> are forgotten.</td></tr>
    <tr><td class="paramname">resetProperties</td><td>If true, <a class="el" href="interfaceLeMP_1_1IMacroContext.html#a12883b70ba50042d8fbda2e89e43b4f5" title="Returns a table of &quot;properties&quot; (arbitrary key-value pairs) that exist in the current scope....">ScopedProperties</a> is reset to contain only predefined properties.</td></tr>
  </table>
  </dd>
</dl>
<p>The node(s)</p>

</div>
</div>
<a id="a2a6f20e79b626a1c314c9442d1beca2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6f20e79b626a1c314c9442d1beca2e">&#9670;&nbsp;</a></span>PreProcessChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> LeMP.IMacroContext.PreProcessChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies all available macros to the current node's children and returns the result. </p>
<p>This method only processes children once. If this method is called again for the same node, it returns a cached result. </p>
<p>If the currently-running macro fails, the result may be thrown away and the effort of processing the children will have been wasted. If the macro succeeds, and its <a class="el" href="classLeMP_1_1LexicalMacroAttribute.html" title="Marks a method as a LeMP lexical macro.">LexicalMacroAttribute</a> uses the default <code><a class="el" href="namespaceLeMP.html#ab267185fdc116f4e8f06125be9858721a960b44c579bc2f6818d2daaf9e4c16f0" title="The macro&#39;s result is reprocessed directly (this is the default behavior).">MacroMode.Normal</a></code> processing mode, the children will (normally) be processed again after the macro returns. </p>

</div>
</div>
<a id="aecf41ab5e772b73344f442e010a1a61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf41ab5e772b73344f442e010a1a61f">&#9670;&nbsp;</a></span>RegisterMacro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> LeMP.IMacroContext.RegisterMacro </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLeMP_1_1MacroInfo.html">MacroInfo</a>&#160;</td>
          <td class="paramname"><em>macroInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a new macro in the current scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">macroInfo</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>The macro will be forgotten at the end of the current scope. Macros in child scopes do not shadow macros in outer scopes; if there are macros with the same name in the outer scope, conflicts are handled in the same way as with groups of macros that are imported in the same scope. For example, <code>Mode = <a class="el" href="namespaceLeMP.html#ab267185fdc116f4e8f06125be9858721a66057e7fb1b999cf202660a21fee7471" title="High priority. If this macro is ambiguous with another macro that doesn&#39;t have this flag nor Override...">MacroMode.PriorityOverride</a></code> can be used to make macros that override normal-priority macros.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="ab7f39549b84ec729a461c784f3a3a0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f39549b84ec729a461c784f3a3a0ab">&#9670;&nbsp;</a></span>AllKnownMacros</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IReadOnlyDictionary&lt;<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a>, <a class="el" href="structLoyc_1_1Collections_1_1VList.html">VList</a>&lt;<a class="el" href="classLeMP_1_1MacroInfo.html">MacroInfo</a>&gt; &gt; LeMP.IMacroContext.AllKnownMacros</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets information about all macros registered with the macro processor, including macros whose namespace has not been opened with <code>#importMacros</code>. </p>

</div>
</div>
<a id="abb6b2fbd85b1bb5fb33bf25f04aa890b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6b2fbd85b1bb5fb33bf25f04aa890b">&#9670;&nbsp;</a></span>Ancestors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IReadOnlyList&lt;<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&gt; LeMP.IMacroContext.Ancestors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of ancestors of the current node being processed. Normally Ancestors[0] is a #splice node that contains a list of all top-level statements in the file, and Ancestors.Last() is the current node. </p>
<p>You would expect that Ancestors[N] would contain Ancestors[N+1] as part of the attributes, target or arguments, but this is not always true. The ancestor list contains original versions of each node; when a child node is changed by a macro, the parent is not updated in this list, but macro processing continues for the descendants of that child, so the ancestor list may occasionally seem incoherent.</p>

</div>
</div>
<a id="ada43164412ec526c6e8d081cbb43b5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada43164412ec526c6e8d081cbb43b5c1">&#9670;&nbsp;</a></span>DropRemainingNodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LeMP.IMacroContext.DropRemainingNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets a value that indicates whether to drop all remaining node after the current one when the current macro returns. This property has no effect if the macro rejects the input by returning null. </p>
<p>See remarks at <a class="el" href="classLeMP_1_1MacroContext.html#a53620827a7b44050f95cd765e2c2f137" title="Splits the current node into a pair of &quot;argument&quot; and &quot;body&quot; lists, potentially treating ctx....">MacroContext.GetArgsAndBody</a>.</p>

<p class="reference">Referenced by <a class="el" href="classLeMP_1_1MacroContext.html#a53620827a7b44050f95cd765e2c2f137">LeMP.MacroContext.GetArgsAndBody()</a>.</p>

</div>
</div>
<a id="a1af6d218898eab6b531fc296fd915c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af6d218898eab6b531fc296fd915c9a">&#9670;&nbsp;</a></span>IsAttribute</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LeMP.IMacroContext.IsAttribute</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the current node is in the attribute list of its immediate parent. </p>

</div>
</div>
<a id="a490691aaae9c12a3cc213ad4b1024dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490691aaae9c12a3cc213ad4b1024dbd">&#9670;&nbsp;</a></span>IsTarget</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LeMP.IMacroContext.IsTarget</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the current node is the target of its parent call node. </p>

</div>
</div>
<a id="ad4ba92c4e19b86ca5f7ed0972518df7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ba92c4e19b86ca5f7ed0972518df7e">&#9670;&nbsp;</a></span>NextTempCounter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LeMP.IMacroContext.NextTempCounter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the next number to use as a suffix for temporary variables (without incrementing). </p>

</div>
</div>
<a id="a681a62874a05eee15058bd1723403ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681a62874a05eee15058bd1723403ce4">&#9670;&nbsp;</a></span>Parent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> LeMP.IMacroContext.Parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the logical parent of the current node, which is <code>Ancestors[Ancestors.Count - 2]</code>, or null if the current node is the root node. </p>
<p>Please note that the current node may not actually exist in the parent node due to changes made earlier to the current node by other macros (or even the same macro); the Parent property still returns the old version of the parent node.</p>

</div>
</div>
<a id="a68425589ee09ef9f92085782abf8b53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68425589ee09ef9f92085782abf8b53b">&#9670;&nbsp;</a></span>RemainingNodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">IListSource</a>&lt;<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&gt; LeMP.IMacroContext.RemainingNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a list of the remaining nodes (arguments/statements or attributes) after this point in the code stream. </p>
<p>The list is null when processing a target node. </p>
<p>For example, if your macro is called "macro" and it appears in the following context: </p><div class="fragment"><div class="line">{</div>
<div class="line">  a();</div>
<div class="line">  macro(b());</div>
<div class="line">  c();</div>
<div class="line">  d();</div>
<div class="line">}</div>
</div><!-- fragment --><p> Then this list will contain two items, c() and d(). Similarly, if the context is <code>[a, b, macro(c), d, e]</code> then the list will contain the items d and e. </p>

<p class="reference">Referenced by <a class="el" href="classLeMP_1_1MacroContext.html#a53620827a7b44050f95cd765e2c2f137">LeMP.MacroContext.GetArgsAndBody()</a>.</p>

</div>
</div>
<a id="a12883b70ba50042d8fbda2e89e43b4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12883b70ba50042d8fbda2e89e43b4f5">&#9670;&nbsp;</a></span>ScopedProperties</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IDictionary&lt;object, object&gt; LeMP.IMacroContext.ScopedProperties</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a table of "properties" (arbitrary key-value pairs) that exist in the current scope. This dictionary is "persistent" in the computer science sense; any changes to these properties affect only the current scope and child scopes. When the current scope ends, the set of properties that existed in the parent scope are restored. </p>
<p>Scopes are bounded by curly brace nodes (Call nodes named "{}"). </p>

</div>
</div>
<a id="a8419c79777d647e75169adb9a3968ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8419c79777d647e75169adb9a3968ee8">&#9670;&nbsp;</a></span>Sink</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceLoyc_1_1IMessageSink.html">IMessageSink</a> LeMP.IMacroContext.Sink</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the message sink, used for writing warnings and errors. </p>
<p>For backward compatibility, <a class="el" href="interfaceLeMP_1_1IMacroContext.html" title="This interface provides services offered by the lexical macro processor (LeMP).">IMacroContext</a> itself implements IMessageSink also.</p>

<p class="reference">Referenced by <a class="el" href="classLoyc_1_1LLPG_1_1Macros.html#a248cff146c92539da7786af63445bc02">Loyc.LLPG.Macros.LLLPG_lexer()</a>, <a class="el" href="classLoyc_1_1LLPG_1_1Macros.html#ae102955f76c97cf0f27303b6d616e43d">Loyc.LLPG.Macros.LLLPG_parser()</a>, and <a class="el" href="classLoyc_1_1LLPG_1_1Macros.html#ab27ccc42e5eaa88f4bed8f10a87e4e2a">Loyc.LLPG.Macros.LllpgMacro()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 3 2020 16:52:14 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
