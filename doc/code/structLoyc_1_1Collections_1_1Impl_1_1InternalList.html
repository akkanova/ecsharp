<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Enhanced C#: Loyc.Collections.Impl.InternalList&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections_1_1Impl.html">Impl</a></li><li class="navelem"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Nested classes</a> &#124;
<a href="#pub-attribs">Public fields</a> &#124;
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classLoyc_1_1Collections_1_1Impl_1_1InternalList-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.Impl.InternalList&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A compact auto-enlarging array structure that is intended to be used within other data structures. It should only be used internally in "private" or "protected" members of low-level code.  
 <a href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Essentials/Collections/Implementations/InternalList.cs'>/Core/Loyc.Essentials/Collections/Implementations/InternalList.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.Impl.InternalList&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structLoyc_1_1Collections_1_1Impl_1_1InternalList.png" usemap="#Loyc.Collections.Impl.InternalList_3C_20T_20_3E_map" alt=""/>
  <map id="Loyc.Collections.Impl.InternalList_3C_20T_20_3E_map" name="Loyc.Collections.Impl.InternalList&lt; T &gt;_map">
<area href="interfaceLoyc_1_1Collections_1_1IListAndListSource.html" title="This interface is to be used by read-only sequences that nevertheless wish to be compatible with APIs..." alt="Loyc.Collections.IListAndListSource&lt; T &gt;" shape="rect" coords="879,168,1162,192"/>
<area href="interfaceLoyc_1_1Collections_1_1IListRangeMethods.html" alt="Loyc.Collections.IListRangeMethods&lt; T &gt;" shape="rect" coords="1172,168,1455,192"/>
<area href="interfaceLoyc_1_1Collections_1_1IListAndReadOnly.html" title="This interface is meant to be implemented by read-only sequence classes that originally implemented I..." alt="Loyc.Collections.IListAndReadOnly&lt; T &gt;" shape="rect" coords="439,112,722,136"/>
<area href="interfaceLoyc_1_1Collections_1_1IListSource.html" alt="Loyc.Collections.IListSource&lt; T &gt;" shape="rect" coords="732,112,1015,136"/>
<area href="interfaceLoyc_1_1Collections_1_1ICollectionAndSource.html" title="This interface is to be implemented by read-only sequence types that still want to be compatible with..." alt="Loyc.Collections.ICollectionAndSource&lt; T &gt;" shape="rect" coords="1465,112,1748,136"/>
<area href="interfaceLoyc_1_1Collections_1_1ICollectionAndReadOnly.html" title="This interface is meant to be implemented by read-only sequence types that originally implemented ICo..." alt="Loyc.Collections.ICollectionAndReadOnly&lt; T &gt;" shape="rect" coords="146,56,429,80"/>
<area href="interfaceLoyc_1_1Collections_1_1ICollectionSource.html" title="A variation of IReadOnlyCollection that provides the Contains() and CopyTo() methods from ICollection..." alt="Loyc.Collections.ICollectionSource&lt; T &gt;" shape="rect" coords="1172,56,1455,80"/>
<area href="interfaceLoyc_1_1Collections_1_1ICollectionAndReadOnly.html" title="This interface is meant to be implemented by read-only sequence types that originally implemented ICo..." alt="Loyc.Collections.ICollectionAndReadOnly&lt; T &gt;" shape="rect" coords="1758,56,2041,80"/>
<area href="interfaceLoyc_1_1Collections_1_1IContains.html" alt="Loyc.Collections.IContains&lt; T &gt;" shape="rect" coords="1025,0,1308,24"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>A compact auto-enlarging array structure that is intended to be used within other data structures. It should only be used internally in "private" or "protected" members of low-level code. </p>
<p>Contains static methods to help manage raw arrays with even less overhead than InternalList&lt;T&gt;. </p>
<p>An <a href="http://core.loyc.net/collections/internal-list.html">article</a> about this class is available. </p>
<p><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html" title="A compact auto-enlarging array structure that is intended to be used within other data structures...">InternalList</a> is a struct, not a class, in order to save memory; and for maximum performance, it asserts rather than throwing an exception when an incorrect array index is used. Besides that, it has an InternalArray property that provides access to the internal array. For all these reasons one should not expose it in a public API, and it should only be used when performance trumps all other concerns. </p>
<p>Passing this structure by value is dangerous because changes to a copy of the structure may or may not be reflected in the original list. It's best not to pass it around at all, but if you must pass it, pass it by reference. Avoid using extension methods on this struct because an extension method will receive a copy of the struct. </p>
<p>Also, do not use the default contructor. Always specify an initial capacity or copy InternalList.Empty so that _array gets a value. This is required because methods such as Add(), Insert() and <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a95e91f931cbf4cde071db2f53e8b5f7b">Resize()</a> assume _array is not null. </p>
<p><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html" title="A compact auto-enlarging array structure that is intended to be used within other data structures...">InternalList</a> has one nice thing that List(of T) lacks: a <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a95e91f931cbf4cde071db2f53e8b5f7b">Resize</a> method and an equivalent Count setter. Which dork at Microsoft decided no one should be allowed to set the list length directly? This type also provides a handy Last property and a Pop method to respectively get or remove the last item. </p>
<p>Finally, alongside InternalList(T), the static class <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html" title="A compact auto-enlarging array structure that is intended to be used within other data structures...">InternalList</a> comes with some static methods (CopyToNewArray, Insert, RemoveAt, Move) to help manage raw arrays. You might want to use these in a data structure implementation even if you choose not to use InternalList(T) instances. </p>
<p>The methods of this class are used by some data structures that contain arrays but, for whatever reason, don't use InternalList&lt;T&gt;. These methods are also used by InternalList(T) itself. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Nested classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList_1_1Enumerator.html">Enumerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public fields</h2></td></tr>
<tr class="memitem:a47c6aa8a2ca24e6a668a2fcaf8f3ca86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47c6aa8a2ca24e6a668a2fcaf8f3ca86"></a>
bool ICollection&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>IsReadOnly</b> =&gt; false</td></tr>
<tr class="separator:a47c6aa8a2ca24e6a668a2fcaf8f3ca86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:a72a8a28c1829150e8d160f554cc65290"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72a8a28c1829150e8d160f554cc65290"></a>
static readonly T[]&#160;</td><td class="memItemRight" valign="bottom"><b>EmptyArray</b> = new T[0]</td></tr>
<tr class="separator:a72a8a28c1829150e8d160f554cc65290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a79234b52e5fa2676075c175587fbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17a79234b52e5fa2676075c175587fbf"></a>
static readonly <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Empty</b> = new <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt;T&gt;(0)</td></tr>
<tr class="separator:a17a79234b52e5fa2676075c175587fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a8bebb7cc4338950abf1806b2a1ccd072"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bebb7cc4338950abf1806b2a1ccd072"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Count</b><code> [get, set]</code></td></tr>
<tr class="separator:a8bebb7cc4338950abf1806b2a1ccd072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6812500287c4cab745c023d8e108a9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6812500287c4cab745c023d8e108a9a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsEmpty</b><code> [get]</code></td></tr>
<tr class="separator:af6812500287c4cab745c023d8e108a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5b302d17b19c2ae19ec38c12cf6834"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#ade5b302d17b19c2ae19ec38c12cf6834">Capacity</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ade5b302d17b19c2ae19ec38c12cf6834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the array length. <a href="#ade5b302d17b19c2ae19ec38c12cf6834">More...</a><br /></td></tr>
<tr class="separator:ade5b302d17b19c2ae19ec38c12cf6834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baaa87d2468b8d153f04d5a7006965c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9baaa87d2468b8d153f04d5a7006965c"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>First</b><code> [get, set]</code></td></tr>
<tr class="separator:a9baaa87d2468b8d153f04d5a7006965c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7375381ef878bb66c8c82c0856c47d45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7375381ef878bb66c8c82c0856c47d45"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>Last</b><code> [get, set]</code></td></tr>
<tr class="separator:a7375381ef878bb66c8c82c0856c47d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe1d3d09f7f7008fdff076888fbbf82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfe1d3d09f7f7008fdff076888fbbf82"></a>
T[]&#160;</td><td class="memItemRight" valign="bottom"><b>InternalArray</b><code> [get]</code></td></tr>
<tr class="separator:acfe1d3d09f7f7008fdff076888fbbf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb493701770bac856c6c27602a6b239"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bb493701770bac856c6c27602a6b239"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>this[int index]</b><code> [get, set]</code></td></tr>
<tr class="separator:a7bb493701770bac856c6c27602a6b239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829bfb5e6c6e53d8f7dd95d965c1661c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a829bfb5e6c6e53d8f7dd95d965c1661c"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>this[int index, T defaultValue]</b><code> [get]</code></td></tr>
<tr class="separator:a829bfb5e6c6e53d8f7dd95d965c1661c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3d326d5d5303dfb3e57fe4bf3f8c5388"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d326d5d5303dfb3e57fe4bf3f8c5388"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InternalList</b> (int capacity)</td></tr>
<tr class="separator:a3d326d5d5303dfb3e57fe4bf3f8c5388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dab4156702c46f390f595ed65067b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1dab4156702c46f390f595ed65067b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InternalList</b> (T[] array, int count)</td></tr>
<tr class="separator:ad1dab4156702c46f390f595ed65067b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd2b401423aff71f98d500665348902"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdd2b401423aff71f98d500665348902"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InternalList</b> (IEnumerable&lt; T &gt; items)</td></tr>
<tr class="separator:afdd2b401423aff71f98d500665348902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90dda99a333b4eb8fb90e8a31f63475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac90dda99a333b4eb8fb90e8a31f63475"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InternalList</b> (IEnumerator&lt; T &gt; items)</td></tr>
<tr class="separator:ac90dda99a333b4eb8fb90e8a31f63475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cffb40c1e5bb1419496da0f62e9ae1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6cffb40c1e5bb1419496da0f62e9ae1"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AutoRaiseCapacity</b> (int more, int capacityLimit)</td></tr>
<tr class="separator:ad6cffb40c1e5bb1419496da0f62e9ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e91f931cbf4cde071db2f53e8b5f7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95e91f931cbf4cde071db2f53e8b5f7b"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a95e91f931cbf4cde071db2f53e8b5f7b">Resize</a> (int newSize)</td></tr>
<tr class="separator:a95e91f931cbf4cde071db2f53e8b5f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308bcf2e3d38b8745942c52d1ea83a7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a308bcf2e3d38b8745942c52d1ea83a7c">Resize</a> (int newSize, bool allowReduceCapacity)</td></tr>
<tr class="memdesc:a308bcf2e3d38b8745942c52d1ea83a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the list larger or smaller, depending on whether <code>newSize</code> is larger or smaller than Count. <a href="#a308bcf2e3d38b8745942c52d1ea83a7c">More...</a><br /></td></tr>
<tr class="separator:a308bcf2e3d38b8745942c52d1ea83a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d91dd674fa42df2b1cfbb5ca498c714"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d91dd674fa42df2b1cfbb5ca498c714"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Add</b> (T item)</td></tr>
<tr class="separator:a9d91dd674fa42df2b1cfbb5ca498c714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674f49b35c8fb35ecf9d47a552f5ae98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a674f49b35c8fb35ecf9d47a552f5ae98"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (IEnumerator&lt; T &gt; items)</td></tr>
<tr class="separator:a674f49b35c8fb35ecf9d47a552f5ae98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ee9cfd80367491d421a34d1432ab52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42ee9cfd80367491d421a34d1432ab52"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Insert</b> (int index, T item)</td></tr>
<tr class="separator:a42ee9cfd80367491d421a34d1432ab52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cb0e22e005ba156fb48999025c86ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51cb0e22e005ba156fb48999025c86ed"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange</b> (int index, <a class="el" href="interfaceLoyc_1_1Collections_1_1ICollectionAndReadOnly.html">ICollectionAndReadOnly</a>&lt; T &gt; items)</td></tr>
<tr class="separator:a51cb0e22e005ba156fb48999025c86ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c8dfefe0fcc0cf912a6fca20013bc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50c8dfefe0fcc0cf912a6fca20013bc4"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange</b> (int index, IReadOnlyCollection&lt; T &gt; items)</td></tr>
<tr class="separator:a50c8dfefe0fcc0cf912a6fca20013bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb557030e31baf260de1dd47d5439a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eb557030e31baf260de1dd47d5439a0"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange</b> (int index, ICollection&lt; T &gt; items)</td></tr>
<tr class="separator:a7eb557030e31baf260de1dd47d5439a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad850c45b6c1f620fc4e0d1197651149e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad850c45b6c1f620fc4e0d1197651149e"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRangeHelper</b> (int index, int spaceNeeded)</td></tr>
<tr class="separator:ad850c45b6c1f620fc4e0d1197651149e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4be1968538f257850676fbee97f8d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f4be1968538f257850676fbee97f8d7"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange</b> (int index, IEnumerable&lt; T &gt; e)</td></tr>
<tr class="separator:a3f4be1968538f257850676fbee97f8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2350c8492f55b0a4f623f74eda9f9ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2350c8492f55b0a4f623f74eda9f9ef"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (IReadOnlyCollection&lt; T &gt; items)</td></tr>
<tr class="separator:ac2350c8492f55b0a4f623f74eda9f9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3273da83662bbdfb629e6a2f9ed9aacb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3273da83662bbdfb629e6a2f9ed9aacb"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (ICollection&lt; T &gt; items)</td></tr>
<tr class="separator:a3273da83662bbdfb629e6a2f9ed9aacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa037b2ea1c84f0ca362ba318c6e01740"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa037b2ea1c84f0ca362ba318c6e01740"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (IEnumerable&lt; T &gt; e)</td></tr>
<tr class="separator:aa037b2ea1c84f0ca362ba318c6e01740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970b4402de63d39071175738d2f4b2ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a970b4402de63d39071175738d2f4b2ea"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (<a class="el" href="interfaceLoyc_1_1Collections_1_1ICollectionAndReadOnly.html">ICollectionAndReadOnly</a>&lt; T &gt; items)</td></tr>
<tr class="separator:a970b4402de63d39071175738d2f4b2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad4f447018d5be2bc6cc8c6e1b33ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a4ad4f447018d5be2bc6cc8c6e1b33ef3">Clear</a> ()</td></tr>
<tr class="memdesc:a4ad4f447018d5be2bc6cc8c6e1b33ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list and frees the memory used by the list. Can also be used to initialize a list whose constructor was never called. <a href="#a4ad4f447018d5be2bc6cc8c6e1b33ef3">More...</a><br /></td></tr>
<tr class="separator:a4ad4f447018d5be2bc6cc8c6e1b33ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f968ed7f79971866a14d63828880c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03f968ed7f79971866a14d63828880c0"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt</b> (int index)</td></tr>
<tr class="separator:a03f968ed7f79971866a14d63828880c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98711953c490d20215a4de88f3dc0f94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98711953c490d20215a4de88f3dc0f94"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveRange</b> (int index, int count)</td></tr>
<tr class="separator:a98711953c490d20215a4de88f3dc0f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d790276cc0442da90633bac705341e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45d790276cc0442da90633bac705341e"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Pop</b> ()</td></tr>
<tr class="separator:a45d790276cc0442da90633bac705341e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ead3b0e6aed0621aa948e0df697fdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a38ead3b0e6aed0621aa948e0df697fdd">Clone</a> ()</td></tr>
<tr class="memdesc:a38ead3b0e6aed0621aa948e0df697fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a copy of the list with the same capacity <a href="#a38ead3b0e6aed0621aa948e0df697fdd">More...</a><br /></td></tr>
<tr class="separator:a38ead3b0e6aed0621aa948e0df697fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd274c181b05987edb9222d13b49736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#aefd274c181b05987edb9222d13b49736">CloneAndTrim</a> ()</td></tr>
<tr class="memdesc:aefd274c181b05987edb9222d13b49736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a copy of the list with Capacity = Count <a href="#aefd274c181b05987edb9222d13b49736">More...</a><br /></td></tr>
<tr class="separator:aefd274c181b05987edb9222d13b49736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c042c04a7753f6e366f42ba3ad8ee7"><td class="memItemLeft" align="right" valign="top">T[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a54c042c04a7753f6e366f42ba3ad8ee7">ToArray</a> ()</td></tr>
<tr class="memdesc:a54c042c04a7753f6e366f42ba3ad8ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a copy of the list, as an array <a href="#a54c042c04a7753f6e366f42ba3ad8ee7">More...</a><br /></td></tr>
<tr class="separator:a54c042c04a7753f6e366f42ba3ad8ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66841898b2e8093a26b734b00b1b213"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa66841898b2e8093a26b734b00b1b213"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch</b> (T lookFor)</td></tr>
<tr class="separator:aa66841898b2e8093a26b734b00b1b213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecebfe52f06760070959159c14c65b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afecebfe52f06760070959159c14c65b8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch</b> (T lookFor, Comparer&lt; T &gt; comp)</td></tr>
<tr class="separator:afecebfe52f06760070959159c14c65b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca12f97160c31e2b1238f2d8fed4eb73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca12f97160c31e2b1238f2d8fed4eb73"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch</b> (T lookFor, Comparer&lt; T &gt; comp, bool lowerBound)</td></tr>
<tr class="separator:aca12f97160c31e2b1238f2d8fed4eb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ce4412584c838a3566b4012a5db52c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3ce4412584c838a3566b4012a5db52c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch&lt; K &gt;</b> (K lookFor, Func&lt; T, K, int &gt; func, bool lowerBound)</td></tr>
<tr class="separator:ad3ce4412584c838a3566b4012a5db52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46efa20acf8b9b4b1df5b80a5c7bfb5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a46efa20acf8b9b4b1df5b80a5c7bfb5b">Move</a> (int from, int to)</td></tr>
<tr class="memdesc:a46efa20acf8b9b4b1df5b80a5c7bfb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slides the array entry at [from] forward or backward in the list, until it reaches [to]. <a href="#a46efa20acf8b9b4b1df5b80a5c7bfb5b">More...</a><br /></td></tr>
<tr class="separator:a46efa20acf8b9b4b1df5b80a5c7bfb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4495d1c14db7ca5f767d8c3c23e853"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc4495d1c14db7ca5f767d8c3c23e853"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOf</b> (T item)</td></tr>
<tr class="separator:adc4495d1c14db7ca5f767d8c3c23e853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7141b6297553b7d16a578718cf12f070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7141b6297553b7d16a578718cf12f070"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>IndexOf</b> (T item, int index)</td></tr>
<tr class="separator:a7141b6297553b7d16a578718cf12f070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf1734a801a9f31a56d7d35a11648d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bf1734a801a9f31a56d7d35a11648d1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Contains</b> (T item)</td></tr>
<tr class="separator:a5bf1734a801a9f31a56d7d35a11648d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f78f25d402edaaa1b351da576a0c506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a6f78f25d402edaaa1b351da576a0c506">CopyTo</a> (T[] array, int arrayIndex)</td></tr>
<tr class="memdesc:a6f78f25d402edaaa1b351da576a0c506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements of the collection to an Array, starting at a particular array index. <a href="#a6f78f25d402edaaa1b351da576a0c506">More...</a><br /></td></tr>
<tr class="separator:a6f78f25d402edaaa1b351da576a0c506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ce7a72c93265c315d87a74598310f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6ce7a72c93265c315d87a74598310f4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Remove</b> (T item)</td></tr>
<tr class="separator:ac6ce7a72c93265c315d87a74598310f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db330773ac3bbd1cb52ee41b22bb341"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9db330773ac3bbd1cb52ee41b22bb341"></a>
System.Collections.IEnumerator System.Collections.IEnumerable.&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a9db330773ac3bbd1cb52ee41b22bb341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32451dd444c2e458f7a4a7295dc590ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32451dd444c2e458f7a4a7295dc590ef"></a>
IEnumerator&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a32451dd444c2e458f7a4a7295dc590ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904956e2452d66489b1f300b010dbfb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a904956e2452d66489b1f300b010dbfb9"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>TryGet</b> (int index, out bool fail)</td></tr>
<tr class="separator:a904956e2452d66489b1f300b010dbfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ffd3c951c6328027010a888c2c3e65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10ffd3c951c6328027010a888c2c3e65"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Sort</b> (Comparison&lt; T &gt; comp)</td></tr>
<tr class="separator:a10ffd3c951c6328027010a888c2c3e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffafe3a0ee757f3c2d0e9f49706be67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaffafe3a0ee757f3c2d0e9f49706be67"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Sort</b> (int index, int count, Comparison&lt; T &gt; comp)</td></tr>
<tr class="separator:aaffafe3a0ee757f3c2d0e9f49706be67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213e9ad3bd0ac28e1ed6ac70311491e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a213e9ad3bd0ac28e1ed6ac70311491e8"></a>
<a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange</a>&lt; T &gt; <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">IListSource</a>&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>Slice</b> (int start, int count)</td></tr>
<tr class="separator:a213e9ad3bd0ac28e1ed6ac70311491e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e9f1da6c843cb3a8f9f4d3adef7eba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8e9f1da6c843cb3a8f9f4d3adef7eba"></a>
<a class="el" href="structLoyc_1_1Collections_1_1Slice__.html">Slice_</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Slice</b> (int start, int count=int.MaxValue)</td></tr>
<tr class="separator:ad8e9f1da6c843cb3a8f9f4d3adef7eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b963fa5f8fc6a52a03f9696093b4ef0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b963fa5f8fc6a52a03f9696093b4ef0"></a>
<a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CopySection</b> (int start, int subcount)</td></tr>
<tr class="separator:a7b963fa5f8fc6a52a03f9696093b4ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interfaceLoyc_1_1Collections_1_1IListSource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html">Loyc.Collections.IListSource&lt; T &gt;</a></td></tr>
<tr class="memitem:a19a865ed54cfef48cd244d1343ff83b6 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a19a865ed54cfef48cd244d1343ff83b6">TryGet</a> (int index, out bool fail)</td></tr>
<tr class="memdesc:a19a865ed54cfef48cd244d1343ff83b6 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the item at the specified index, and does not throw an exception on failure. <a href="#a19a865ed54cfef48cd244d1343ff83b6">More...</a><br /></td></tr>
<tr class="separator:a19a865ed54cfef48cd244d1343ff83b6 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cf4d93658771ea9539ed905d2d91bf inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceLoyc_1_1Collections_1_1IRange.html">IRange</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource.html#a52cf4d93658771ea9539ed905d2d91bf">Slice</a> (int start, int count=int.MaxValue)</td></tr>
<tr class="memdesc:a52cf4d93658771ea9539ed905d2d91bf inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub-range of this list. <a href="#a52cf4d93658771ea9539ed905d2d91bf">More...</a><br /></td></tr>
<tr class="separator:a52cf4d93658771ea9539ed905d2d91bf inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListSource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interfaceLoyc_1_1Collections_1_1IContains"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interfaceLoyc_1_1Collections_1_1IContains')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interfaceLoyc_1_1Collections_1_1IContains.html">Loyc.Collections.IContains&lt; T &gt;</a></td></tr>
<tr class="memitem:af18fb028bdd55ed86fdebf069622e491 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IContains"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IContains.html#af18fb028bdd55ed86fdebf069622e491">Contains</a> (T item)</td></tr>
<tr class="memdesc:af18fb028bdd55ed86fdebf069622e491 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IContains"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the collection contains the specified item. <a href="#af18fb028bdd55ed86fdebf069622e491">More...</a><br /></td></tr>
<tr class="separator:af18fb028bdd55ed86fdebf069622e491 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IContains"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interfaceLoyc_1_1Collections_1_1IListRangeMethods"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interfaceLoyc_1_1Collections_1_1IListRangeMethods')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interfaceLoyc_1_1Collections_1_1IListRangeMethods.html">Loyc.Collections.IListRangeMethods&lt; T &gt;</a></td></tr>
<tr class="memitem:a1b5ba33e61273e4d6a2bd11ed5c64499 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListRangeMethods"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b5ba33e61273e4d6a2bd11ed5c64499"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange</b> (int index, IEnumerable&lt; T &gt; s)</td></tr>
<tr class="separator:a1b5ba33e61273e4d6a2bd11ed5c64499 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListRangeMethods"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcac0929c3a604b202fb97b9259da3fa inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListRangeMethods"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcac0929c3a604b202fb97b9259da3fa"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange</b> (int index, IReadOnlyCollection&lt; T &gt; s)</td></tr>
<tr class="separator:afcac0929c3a604b202fb97b9259da3fa inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListRangeMethods"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbfaa2303c4feb7019d266acb126603 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListRangeMethods"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cbfaa2303c4feb7019d266acb126603"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveRange</b> (int index, int amount)</td></tr>
<tr class="separator:a3cbfaa2303c4feb7019d266acb126603 inherit pub_methods_interfaceLoyc_1_1Collections_1_1IListRangeMethods"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a40563816b57afb837d28ed07e1f77508"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a40563816b57afb837d28ed07e1f77508">AsInternalList&lt; T &gt;</a> (this T[] array)</td></tr>
<tr class="memdesc:a40563816b57afb837d28ed07e1f77508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an array to <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html" title="A compact auto-enlarging array structure that is intended to be used within other data structures...">InternalList</a> (exists to help infer type params) <a href="#a40563816b57afb837d28ed07e1f77508">More...</a><br /></td></tr>
<tr class="separator:a40563816b57afb837d28ed07e1f77508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f313d926c1d1c2d62831018c66c0be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71f313d926c1d1c2d62831018c66c0be"></a>
static <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AsInternalList&lt; T &gt;</b> (this T[] array, int count)</td></tr>
<tr class="separator:a71f313d926c1d1c2d62831018c66c0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ba434a087f400b88c20de719588165"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8ba434a087f400b88c20de719588165"></a>
static T[]&#160;</td><td class="memItemRight" valign="bottom"><b>CopyToNewArray&lt; T &gt;</b> (T[] _array, int _count, int newCapacity)</td></tr>
<tr class="separator:af8ba434a087f400b88c20de719588165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c427b386ab45d299c126c8bcae1e4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6c427b386ab45d299c126c8bcae1e4e"></a>
static T[]&#160;</td><td class="memItemRight" valign="bottom"><b>CopyToNewArray&lt; T &gt;</b> (T[] array)</td></tr>
<tr class="separator:aa6c427b386ab45d299c126c8bcae1e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a59d8cce54b5f46344aa0b1f9a0c298"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a59d8cce54b5f46344aa0b1f9a0c298"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Fill&lt; T &gt;</b> (T[] array, T value)</td></tr>
<tr class="separator:a0a59d8cce54b5f46344aa0b1f9a0c298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab282a804e3d2c4a152d579c47bde59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ab282a804e3d2c4a152d579c47bde59"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Fill&lt; T &gt;</b> (T[] array, int start, int count, T value)</td></tr>
<tr class="separator:a1ab282a804e3d2c4a152d579c47bde59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340c2902326d3b11bbc14caad89f3195"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a340c2902326d3b11bbc14caad89f3195"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch&lt; T &gt;</b> (T[] array, int count, T k, Comparer&lt; T &gt; comp, bool lowerBound)</td></tr>
<tr class="separator:a340c2902326d3b11bbc14caad89f3195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac142f62c44b6ca5f0ae825e0ee54d15a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#ac142f62c44b6ca5f0ae825e0ee54d15a">BinarySearch&lt; T, K &gt;</a> (T[] _array, int _count, K k, Func&lt; T, K, int &gt; compare, bool lowerBound)</td></tr>
<tr class="memdesc:ac142f62c44b6ca5f0ae825e0ee54d15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary search with a custom comparison function. <a href="#ac142f62c44b6ca5f0ae825e0ee54d15a">More...</a><br /></td></tr>
<tr class="separator:ac142f62c44b6ca5f0ae825e0ee54d15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4fa7f119d682c93210e564381decb4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#acb4fa7f119d682c93210e564381decb4">BinarySearchByIndex&lt; Anything &gt;</a> (Anything data, int count, Func&lt; int, Anything, int &gt; compare, bool lowerBound)</td></tr>
<tr class="memdesc:acb4fa7f119d682c93210e564381decb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binary search function that knows nothing about the list being searched. <a href="#acb4fa7f119d682c93210e564381decb4">More...</a><br /></td></tr>
<tr class="separator:acb4fa7f119d682c93210e564381decb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2f20d649b2becfc052a9bd690bac2a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#abb2f20d649b2becfc052a9bd690bac2a">NextLargerSize</a> (int than)</td></tr>
<tr class="memdesc:abb2f20d649b2becfc052a9bd690bac2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">As an alternative to the typical enlarging pattern of doubling the array size when it overflows, this function proposes a 75% size increase instead (100% when the array is small), while ensuring that the array length stays even. <a href="#abb2f20d649b2becfc052a9bd690bac2a">More...</a><br /></td></tr>
<tr class="separator:abb2f20d649b2becfc052a9bd690bac2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ad1d96f0e38afc2dad7ddefa6dba6f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a43ad1d96f0e38afc2dad7ddefa6dba6f">NextLargerSize</a> (int than, int capacityLimit)</td></tr>
<tr class="memdesc:a43ad1d96f0e38afc2dad7ddefa6dba6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#abb2f20d649b2becfc052a9bd690bac2a" title="As an alternative to the typical enlarging pattern of doubling the array size when it overflows...">NextLargerSize(int)</a>, but allows you to specify a capacity limit, to avoid wasting memory when a collection has a known maximum size. <a href="#a43ad1d96f0e38afc2dad7ddefa6dba6f">More...</a><br /></td></tr>
<tr class="separator:a43ad1d96f0e38afc2dad7ddefa6dba6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad612daa407e08829f8fc49c776910b56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad612daa407e08829f8fc49c776910b56"></a>
static T[]&#160;</td><td class="memItemRight" valign="bottom"><b>Insert&lt; T &gt;</b> (int index, T item, T[] array, int count)</td></tr>
<tr class="separator:ad612daa407e08829f8fc49c776910b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1f9f6301dbd8affb807ce1f3100f0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d1f9f6301dbd8affb807ce1f3100f0a"></a>
static T[]&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRangeHelper&lt; T &gt;</b> (int index, int spaceNeeded, T[] array, int count)</td></tr>
<tr class="separator:a3d1f9f6301dbd8affb807ce1f3100f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07584155781019ad4fc67fb3afbf3497"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07584155781019ad4fc67fb3afbf3497"></a>
static T[]&#160;</td><td class="memItemRight" valign="bottom"><b>AutoRaiseCapacity&lt; T &gt;</b> (T[] array, int count, int more, int capacityLimit)</td></tr>
<tr class="separator:a07584155781019ad4fc67fb3afbf3497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a580f5d1352f01e35da16b7cb38a98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25a580f5d1352f01e35da16b7cb38a98"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt&lt; T &gt;</b> (int index, T[] array, int count)</td></tr>
<tr class="separator:a25a580f5d1352f01e35da16b7cb38a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af202db7d5eace97f197489a83b4159b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af202db7d5eace97f197489a83b4159b7"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt&lt; T &gt;</b> (int index, int removeCount, T[] array, int count)</td></tr>
<tr class="separator:af202db7d5eace97f197489a83b4159b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1432b8c6b6f28c3f015e24fa3bbdb326"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1432b8c6b6f28c3f015e24fa3bbdb326"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Move&lt; T &gt;</b> (T[] array, int from, int to)</td></tr>
<tr class="separator:a1432b8c6b6f28c3f015e24fa3bbdb326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0057f0aabae8797d9ba66d4a7282956"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#ae0057f0aabae8797d9ba66d4a7282956">Sort&lt; T &gt;</a> (T[] array, int index, int count, Comparison&lt; T &gt; comp)</td></tr>
<tr class="memdesc:ae0057f0aabae8797d9ba66d4a7282956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a quicksort using a Comparison function. <a href="#ae0057f0aabae8797d9ba66d4a7282956">More...</a><br /></td></tr>
<tr class="separator:ae0057f0aabae8797d9ba66d4a7282956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6599f6f281966c4a5c2923c1318538"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a7b6599f6f281966c4a5c2923c1318538">InsertionSort&lt; T &gt;</a> (T[] array, int index, int count, Comparison&lt; T &gt; comp)</td></tr>
<tr class="memdesc:a7b6599f6f281966c4a5c2923c1318538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an insertion sort. <a href="#a7b6599f6f281966c4a5c2923c1318538">More...</a><br /></td></tr>
<tr class="separator:a7b6599f6f281966c4a5c2923c1318538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d35473aeab4ea44cd59ef471ecf74f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3d35473aeab4ea44cd59ef471ecf74f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>AllEqual&lt; T &gt;</b> (this <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt; T &gt; a, <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt; T &gt; b)</td></tr>
<tr class="separator:ae3d35473aeab4ea44cd59ef471ecf74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7b7d4c96bffb01c20652dca1d4a4ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e7b7d4c96bffb01c20652dca1d4a4ef"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>AllEqual&lt; T &gt;</b> (T[] a, T[] b, int count)</td></tr>
<tr class="separator:a6e7b7d4c96bffb01c20652dca1d4a4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a40563816b57afb837d28ed07e1f77508"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.AsInternalList&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">this T[]&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an array to <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html" title="A compact auto-enlarging array structure that is intended to be used within other data structures...">InternalList</a> (exists to help infer type params)</p>

</div>
</div>
<a class="anchor" id="ac142f62c44b6ca5f0ae825e0ee54d15a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.BinarySearch&lt; T, K &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; T, K, int &gt;&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lowerBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a binary search with a custom comparison function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_array</td><td>Array to search</td></tr>
    <tr><td class="paramname">_count</td><td>Number of elements used in the array</td></tr>
    <tr><td class="paramname">k</td><td>A key to compare with elements of the array</td></tr>
    <tr><td class="paramname">compare</td><td>Lambda function that knows how to compare Ts with Ks (T and K can be the same). It is passed a series of elements from the array. It must return 0 if the element has the desired value, 1 if the supplied element is higher than desired, and -1 if it is lower than desired.</td></tr>
    <tr><td class="paramname">lowerBound</td><td>Whether to find the "lower bound" in case there are duplicates in the list. If duplicates exist of the search key k, the lowest index of a matching duplicate is returned. This search mode may be slightly slower when a match exists.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the matching array entry, if found. If no exact match was found, this method returns the bitwise complement of an insertion location that would preserve the order.</dd></dl>
<p>// The first 6 elements are sorted. The seventh is invalid, // and must be excluded from the binary search. int[] array = new int[] { 0, 10, 20, 30, 40, 50, -1 }; // The result will be 2, because array[2] == 20. int a = InternalList.BinarySearch(array, 6, i =&gt; i.CompareTo(20)); // The result will be ~2, which equals -3, because index 2 would // be the correct place to insert 17 to preserve the sort order. int b = InternalList.BinarySearch(array, 6, i =&gt; i.CompareTo(17)); </p>

</div>
</div>
<a class="anchor" id="acb4fa7f119d682c93210e564381decb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.BinarySearchByIndex&lt; Anything &gt; </td>
          <td>(</td>
          <td class="paramtype">Anything&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; int, Anything, int &gt;&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lowerBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A binary search function that knows nothing about the list being searched.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Anything</td><td>Any data type relevant to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>State information to be passed to compare()</td></tr>
    <tr><td class="paramname">count</td><td>Number of items in the list being searched</td></tr>
    <tr><td class="paramname">compare</td><td>Comparison method that is given the current index to examine and the state parameter "data".</td></tr>
    <tr><td class="paramname">lowerBound</td><td>Whether to find the "lower bound" in case there are duplicates in the list. If duplicates exist of the search key k exist, the lowest index of a matching duplicate is returned. This search mode may be slightly slower when a match exists.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the matching index, if found. If no exact match was found, this method returns the bitwise complement of an insertion location that would preserve the sort order.</dd></dl>

</div>
</div>
<a class="anchor" id="a4ad4f447018d5be2bc6cc8c6e1b33ef3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the list and frees the memory used by the list. Can also be used to initialize a list whose constructor was never called.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1SymbolSet.html#adc83e8de19e20fe568684aa671474df0">Loyc.SymbolSet.MayContain()</a>, <a class="el" href="structLoyc_1_1Syntax_1_1Impl_1_1PrinterState.html#a7b96f0b91765de18bdbb7f6a65f1378b">Loyc.Syntax.Impl.PrinterState.RevokeOrCommitNewlines()</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1AbstractTriviaInjector.html#a7109a7eb2172249ff4d5e2e41e55cc5b">Loyc.Syntax.AbstractTriviaInjector&lt; Token &gt;.RunCore()</a>.</p>

</div>
</div>
<a class="anchor" id="a38ead3b0e6aed0621aa948e0df697fdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a copy of the list with the same capacity</p>

<p>Referenced by <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Alts.html#a4be0ce9d16405368f7c09c9d2d526bfb">Loyc.LLParserGenerator.Alts.Clone()</a>.</p>

</div>
</div>
<a class="anchor" id="aefd274c181b05987edb9222d13b49736"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">InternalList</a>&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.CloneAndTrim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a copy of the list with Capacity = Count</p>

</div>
</div>
<a class="anchor" id="a6f78f25d402edaaa1b351da576a0c506"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements of the collection to an Array, starting at a particular array index.</p>
<p>It's usually more convenient to call the <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a54c042c04a7753f6e366f42ba3ad8ee7" title="Makes a copy of the list, as an array">ToArray()</a> extension method, which calls this method for you. </p>
<p>This method exists for performance reasons (the collection itself can often copy data out faster than an enumerator can). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>array is null.</td></tr>
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>arrayIndex is negative.</td></tr>
    <tr><td class="paramname">ArgumentException</td><td>The number of elements in the source collection is greater than the available space from arrayIndex to the end of the destination array.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1ICollectionSource.html#a5b39bfe772dce668223b14f6f838a2dc">Loyc.Collections.ICollectionSource&lt; T &gt;</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1SymbolSet.html#adc83e8de19e20fe568684aa671474df0">Loyc.SymbolSet.MayContain()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b6599f6f281966c4a5c2923c1318538"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.InsertionSort&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an insertion sort.</p>
<p>The insertion sort is a stable sort algorithm that is slow in general (O(N^2)). It should be used only when (a) the list to be sorted is short (less than about 20 elements) or (b) the list is very nearly sorted already.</p>
<dl class="section see"><dt>See also</dt><dd>ListExt.InsertionSort</dd></dl>

</div>
</div>
<a class="anchor" id="a46efa20acf8b9b4b1df5b80a5c7bfb5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.Move </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slides the array entry at [from] forward or backward in the list, until it reaches [to].</p>
<p>For example, if a list of integers is [0, 1, 2, 3, 4, 5] then Move(4,1) produces the following result: [0, 4, 1, 2, 3, 5]. </p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#a46efa20acf8b9b4b1df5b80a5c7bfb5b">Loyc.Collections.Impl.InternalList&lt; Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt; &gt;.Move()</a>, and <a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html#a2287db28b2b9044187ab4c62207bcd12">Loyc.LLParserGenerator.LLParserGenerator.Run()</a>.</p>

</div>
</div>
<a class="anchor" id="abb2f20d649b2becfc052a9bd690bac2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.NextLargerSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>than</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As an alternative to the typical enlarging pattern of doubling the array size when it overflows, this function proposes a 75% size increase instead (100% when the array is small), while ensuring that the array length stays even.</p>
<p>With a seed of 0, 2, or 4: 0, 2, 4, 8, 16, 30, 54, 96, 170, 298, 522...<br />
 With a seed of 1: 1, 2, 4, 8, 16, 30, 54, 96, 170, 298, 522...<br />
 With a seed of 3: 3, 6, 12, 22, 40, 72, 128, 226, 396...<br />
 With a seed of 5: 5, 10, 18, 32, 58, 102, 180, 316, 554...<br />
 With a seed of 7: 7, 14, 26, 46, 82, 144, 254, 446, 782... </p>
<p>75% size increases require 23.9% more allocations than size doubling (1.75 to the 1.239th power is about 2.0), but memory utilization is increased. With size doubling, the average list uses 2/3 of its entries, but with this resizing pattern, the average list uses 72.72% of its entries. The average size of a list is 8.3% lower. Originally I used 50% size increases, but they required 71% more allocations, which seemed like too much. </p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase.html#a640857ed3378f165ac5d63bd77093b55">Loyc.Collections.Impl.AListInnerBase&lt; int, T &gt;.LLDelete()</a>.</p>

</div>
</div>
<a class="anchor" id="a43ad1d96f0e38afc2dad7ddefa6dba6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.NextLargerSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>than</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacityLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#abb2f20d649b2becfc052a9bd690bac2a" title="As an alternative to the typical enlarging pattern of doubling the array size when it overflows...">NextLargerSize(int)</a>, but allows you to specify a capacity limit, to avoid wasting memory when a collection has a known maximum size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">than</td><td>Return value will be larger than this number.</td></tr>
    <tr><td class="paramname">capacityLimit</td><td>Maximum value to return. This parameter is ignored if it than &gt;= capacityLimit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Produces the same result as <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#abb2f20d649b2becfc052a9bd690bac2a" title="As an alternative to the typical enlarging pattern of doubling the array size when it overflows...">NextLargerSize(int)</a> unless the return value would be near capacityLimit (and capacityLimit <blockquote class="doxtable">
<p>than). If the return value would be more than capacityLimit, </p>
</blockquote>
capacityLimit is returned instead. If the return value would be slightly less than capacityLimit (within 20%) then capacityLimit is returned, to ensure that another reallocation will not be required later.</dd></dl>

</div>
</div>
<a class="anchor" id="a308bcf2e3d38b8745942c52d1ea83a7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.Resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowReduceCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the list larger or smaller, depending on whether <code>newSize</code> is larger or smaller than Count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allowReduceCapacity</td><td>If this is true, and the new size is smaller than one quarter the current <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html#ade5b302d17b19c2ae19ec38c12cf6834" title="Gets or sets the array length.">Capacity</a>, the array is reallocated to a smaller size. If this parameter is false, the array is never reallocated when shrinking the list.</td></tr>
    <tr><td class="paramname">newSize</td><td>New value of Count. If the Count increases, copies of default(T) are added to the end of the the list; otherwise items are removed from the end of the list.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0057f0aabae8797d9ba66d4a7282956"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.Sort&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a quicksort using a Comparison function.</p>
<p>Normally one uses Array.Sort for sorting arrays. This method exists because there is no Array.Sort overload that accepts both a Comparison and a range (index, count), nor does the .NET framework provide access to its internal adapter that converts Comparison to IComparer. </p>
<p>This quicksort algorithm uses a best-of-three pivot so that it remains performant (fast) if the input is already sorted. It is designed to perform reasonably well in case the data contains many duplicates (not verified). It is also designed to avoid using excessive stack space if a worst-case input occurs that requires O(N^2) time. </p>

</div>
</div>
<a class="anchor" id="a54c042c04a7753f6e366f42ba3ad8ee7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T [] <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.ToArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a copy of the list, as an array</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="ade5b302d17b19c2ae19ec38c12cf6834"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structLoyc_1_1Collections_1_1Impl_1_1InternalList.html">Loyc.Collections.Impl.InternalList</a>&lt; T &gt;.Capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the array length.</p>
<p>Changing this property requires O(Count) time and temporary space. Attempting to set the capacity lower than Count has no effect. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 17 2020 22:06:21 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
