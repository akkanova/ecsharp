<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Enhanced C#: Loyc.Syntax.Lexing.BaseLexer&lt; CharSrc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Syntax.html">Syntax</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Syntax_1_1Lexing.html">Lexing</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">BaseLexer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Nested classes</a> &#124;
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected fields</a> &#124;
<a href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Syntax.Lexing.BaseLexer&lt; CharSrc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The recommended base class for lexers generated by LLLPG, when not using the <code>inputSource</code> option. 
 <a href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Syntax/Lexing/BaseLexer.cs'>/Core/Loyc.Syntax/Lexing/BaseLexer.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Syntax.Lexing.BaseLexer&lt; CharSrc &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.png" usemap="#Loyc.Syntax.Lexing.BaseLexer_3C_20CharSrc_20_3E_map" alt=""/>
  <map id="Loyc.Syntax.Lexing.BaseLexer_3C_20CharSrc_20_3E_map" name="Loyc.Syntax.Lexing.BaseLexer&lt; CharSrc &gt;_map">
<area href="classLoyc_1_1Ecs_1_1Parser_1_1EcsLexer.html" title="Lexer for EC# source code (see ILexer&lt;Token&gt;)." alt="Loyc.Ecs.Parser.EcsLexer" shape="rect" coords="0,112,341,136"/>
<area href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseILexer.html" title="A version of BaseLexer&lt;CharSrc&gt; that implements ILexer&lt;Token&gt;. You should use this base class if you ..." alt="Loyc.Syntax.Lexing.BaseILexer&lt; CharSrc, Token &gt;" shape="rect" coords="351,112,692,136"/>
<area href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSourceWorkaround.html" title="This class only exists to work around a limitation of the C# language: &quot;cannot change access modifier..." alt="Loyc.Syntax.Lexing.LexerSourceWorkaround&lt; CharSrc &gt;" shape="rect" coords="702,112,1043,136"/>
<area href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSource.html" title="An implementation of the LLLPG Lexer API, used with the LLLPG options inputSource and inputClass..." alt="Loyc.Syntax.Lexing.LexerSource&lt; CharSrc &gt;" shape="rect" coords="702,168,1043,192"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>The recommended base class for lexers generated by LLLPG, when not using the <code>inputSource</code> option.</p>
<p>Alias for <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#aee0fca65b95753d88fdccc1b9e5a7214" title="Initializes BaseLexer.">BaseLexer&lt;C&gt;</a> where C is ICharSource.</p>
<p>If you are using the <code>inputSource</code> and <code>inputClass</code> options of, LLLPG, use LexerSource&lt;CharSource&gt; instead. If you want to write a lexer that implements ILexer&lt;Tok&gt; (so it is compatible with postprocessors like <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1IndentTokenGenerator.html" title="A preprocessor usually inserted between the lexer and parser that inserts &quot;indent&quot;, &quot;dedent&quot;, and &quot;end-of-line&quot; tokens at appropriate places in a token stream. ">IndentTokenGenerator</a> and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1TokensToTree.html" title="A preprocessor usually inserted between the lexer and parser that converts a token list into a token ...">TokensToTree</a>), use BaseILexer&lt;CharSrc,Tok&gt; as your base class instead. </p>
<p>This class contains many methods required by LLLPG, such as NewSet, LA(int), LA0, <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#ae2ed46c1667602dbdfdab1f5fe49785a" title="Increments InputPosition. Called by LLLPG when prediction already verified the input (and caller does...">Skip</a>, Match(...), and TryMatch(...), along with a few properties that are not used by LLLPG that you still might want to have around, such as FileName, CharSource and <a class="el" href="classLoyc_1_1Syntax_1_1SourceFile.html" title="A default implementation of ISourceFile based on IndexPositionMapper.">SourceFile</a>. </p>
<p>It also implements the caching behavior for which ICharSource was created. See the documentation of ICharSource for more information. </p>
<p>All lexers derived from <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html" title="The recommended base class for lexers generated by LLLPG, when not using the inputSource option...">BaseLexer</a> should call <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#aaf01d80adc87cbc7457dac46df1f41b1" title="The lexer must call this method exactly once after it advances past each newline, even inside comment...">AfterNewline()</a> at the end of their newline rule, in order to increment the current line number. Alternately, your lexer can borrow the newline parser built into <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html" title="The recommended base class for lexers generated by LLLPG, when not using the inputSource option...">BaseLexer</a>, which is called <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#abae963fe4011bda74065554b7f606f0e" title="Default newline parser that matches &#39; &#39; or &#39;&#39; unconditionally.">Newline()</a> and calls <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#aaf01d80adc87cbc7457dac46df1f41b1" title="The lexer must call this method exactly once after it advances past each newline, even inside comment...">AfterNewline()</a> for you. It is possible to have LLLPG treat this method as a rule, and tell LLLPG the meaning of the rule like this: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> token <a class="code" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#abae963fe4011bda74065554b7f606f0e">Newline</a> <span class="charliteral">&#39;\r&#39;</span> <span class="charliteral">&#39;\n&#39;</span>? | <span class="charliteral">&#39;\n&#39;</span> };</div><div class="line"><span class="comment">// BaseLexer also defines a Spaces() method, which behaves like this:</span></div><div class="line"><span class="keyword">extern</span> token <a class="code" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a79c4e1d9e02ed6f1bd69870ff2f44a99">Spaces</a> (<span class="charliteral">&#39; &#39;</span>|<span class="charliteral">&#39;\t&#39;</span>)* }; </div></div><!-- fragment --><p> The <code>extern</code> modifier tells LLLPG not to generate code for the rule, but the rule must still have a body so that LLLPG can perform prediction. </p>
<p>By default, errors are handled by throwing FormatException. The recommended way to alter this behavior is to change the <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a2e052d761c53ba883b58b03cb7f8e4ff" title="Gets or sets the object to which error messages are sent. The default object is LogExceptionErrorSink...">ErrorSink</a> property. For example, set it to <a class="el" href="classLoyc_1_1MessageSink.html#a81ac62c2a94fe066156cce21f878f2a1" title="Sends all messages to the System.Console.WriteLine(string).">MessageSink.Console</a> to send errors to the console, or use <a class="el" href="classLoyc_1_1MessageSink.html#a56c0dedc4cca2f845665f0cdd1ed0fbd" title="Sends all messages to a user-defined method.">MessageSink.FromDelegate</a> to provide a custom handler. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharSrc</td><td>A class that implements ICharSource. In order to write lexers that can accept any source of characters, set CharSrc=ICharSource. For maximum performance when parsing strings (or to avoid memory allocation), set CharSrc=UString (UString is a wrapper around <code>System.String</code> that, among other things, implements <code>ICharSource</code>; please note that C# will implicitly convert normal strings to UString for you).</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>CharSrc</em></td><td>&#160;:</td><td valign="top"><em>ICharSource</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Nested classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_1_1SavePosition.html">SavePosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class used by LLLPG for backtracking. <a href="structLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer_1_1SavePosition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:a1fbcd1f42ea2ebe33b7ee53481fd73e6"><td class="memItemLeft" align="right" valign="top">static readonly IMessageSink&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a1fbcd1f42ea2ebe33b7ee53481fd73e6">LogExceptionErrorSink</a></td></tr>
<tr class="memdesc:a1fbcd1f42ea2ebe33b7ee53481fd73e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws <a class="el" href="classLoyc_1_1LogException.html" title="An exception that includes a &quot;context&quot; object as part of a LogMessage structure, typically used to in...">LogException</a> when it receives an error. Non-errors are sent to MessageSink.Default. <a href="#a1fbcd1f42ea2ebe33b7ee53481fd73e6">More...</a><br /></td></tr>
<tr class="separator:a1fbcd1f42ea2ebe33b7ee53481fd73e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2519061cb92a4df83891264cec3796f0"><td class="memItemLeft" align="right" valign="top">static readonly IMessageSink&#160;</td><td class="memItemRight" valign="bottom"><b>FormatExceptionErrorSink</b></td></tr>
<tr class="separator:a2519061cb92a4df83891264cec3796f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a2e052d761c53ba883b58b03cb7f8e4ff"><td class="memItemLeft" align="right" valign="top">IMessageSink&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a2e052d761c53ba883b58b03cb7f8e4ff">ErrorSink</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a2e052d761c53ba883b58b03cb7f8e4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the object to which error messages are sent. The default object is <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a1fbcd1f42ea2ebe33b7ee53481fd73e6" title="Throws LogException when it receives an error. Non-errors are sent to MessageSink.Default.">LogExceptionErrorSink</a>, which throws an exception if an error occurs. <a href="#a2e052d761c53ba883b58b03cb7f8e4ff">More...</a><br /></td></tr>
<tr class="separator:a2e052d761c53ba883b58b03cb7f8e4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e48d9dc50a8819b2eef0d066271ca9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94e48d9dc50a8819b2eef0d066271ca9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LA0</b><code> [get]</code></td></tr>
<tr class="separator:a94e48d9dc50a8819b2eef0d066271ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab763519cf99be73dc4df98dacc54288f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab763519cf99be73dc4df98dacc54288f"></a>
CharSrc&#160;</td><td class="memItemRight" valign="bottom"><b>CharSource</b><code> [get]</code></td></tr>
<tr class="separator:ab763519cf99be73dc4df98dacc54288f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ac6dbc04a18d1553cb0b181162f4e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7ac6dbc04a18d1553cb0b181162f4e0"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>FileName</b><code> [get]</code></td></tr>
<tr class="separator:aa7ac6dbc04a18d1553cb0b181162f4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72525ee341d3f3381289c0684fb415fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72525ee341d3f3381289c0684fb415fd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>InputPosition</b><code> [get, protected set]</code></td></tr>
<tr class="separator:a72525ee341d3f3381289c0684fb415fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740398ec867b589603e66118e072ac9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a740398ec867b589603e66118e072ac9a"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSourceFile.html">LexerSourceFile</a>&lt; CharSrc &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SourceFile</b><code> [get]</code></td></tr>
<tr class="separator:a740398ec867b589603e66118e072ac9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aa65ed2e21ad7fa8e4ef86bc4b35af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a10aa65ed2e21ad7fa8e4ef86bc4b35af">LineNumber</a><code> [get]</code></td></tr>
<tr class="memdesc:a10aa65ed2e21ad7fa8e4ef86bc4b35af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current line number. Starts at 1 for the first line, unless derived class changes it. <a href="#a10aa65ed2e21ad7fa8e4ef86bc4b35af">More...</a><br /></td></tr>
<tr class="separator:a10aa65ed2e21ad7fa8e4ef86bc4b35af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195bafdad5c6bc2d0dce2354f2debce2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a195bafdad5c6bc2d0dce2354f2debce2">LineStartAt</a><code> [get]</code></td></tr>
<tr class="memdesc:a195bafdad5c6bc2d0dce2354f2debce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index at which the current line started. <a href="#a195bafdad5c6bc2d0dce2354f2debce2">More...</a><br /></td></tr>
<tr class="separator:a195bafdad5c6bc2d0dce2354f2debce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aee0fca65b95753d88fdccc1b9e5a7214"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#aee0fca65b95753d88fdccc1b9e5a7214">BaseLexer</a> (CharSrc chars, string fileName=&quot;&quot;, int inputPosition=0, bool newSourceFile=true)</td></tr>
<tr class="memdesc:aee0fca65b95753d88fdccc1b9e5a7214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html" title="The recommended base class for lexers generated by LLLPG, when not using the inputSource option...">BaseLexer</a>. <a href="#aee0fca65b95753d88fdccc1b9e5a7214">More...</a><br /></td></tr>
<tr class="separator:aee0fca65b95753d88fdccc1b9e5a7214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429c45b8daf9f0adafa187bf4e27f211"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a429c45b8daf9f0adafa187bf4e27f211">Reset</a> (CharSrc chars, string fileName=&quot;&quot;, int inputPosition=0, bool newSourceFile=true)</td></tr>
<tr class="memdesc:a429c45b8daf9f0adafa187bf4e27f211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitializes the object. This method is called by the constructor. <a href="#a429c45b8daf9f0adafa187bf4e27f211">More...</a><br /></td></tr>
<tr class="separator:a429c45b8daf9f0adafa187bf4e27f211"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a905fa03603e9bbe2cdcee89c2e4dc48c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a905fa03603e9bbe2cdcee89c2e4dc48c"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Reset</b> ()</td></tr>
<tr class="separator:a905fa03603e9bbe2cdcee89c2e4dc48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc17a4768d11713a95f4c084f201d7ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc17a4768d11713a95f4c084f201d7ef"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LA</b> (int i)</td></tr>
<tr class="separator:abc17a4768d11713a95f4c084f201d7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ed46c1667602dbdfdab1f5fe49785a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#ae2ed46c1667602dbdfdab1f5fe49785a">Skip</a> ()</td></tr>
<tr class="memdesc:ae2ed46c1667602dbdfdab1f5fe49785a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments InputPosition. Called by LLLPG when prediction already verified the input (and caller doesn't save LA(0)) <a href="#ae2ed46c1667602dbdfdab1f5fe49785a">More...</a><br /></td></tr>
<tr class="separator:ae2ed46c1667602dbdfdab1f5fe49785a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf01d80adc87cbc7457dac46df1f41b1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#aaf01d80adc87cbc7457dac46df1f41b1">AfterNewline</a> ()</td></tr>
<tr class="memdesc:aaf01d80adc87cbc7457dac46df1f41b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lexer must call this method exactly once after it advances past each newline, even inside comments and strings. This method keeps the <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a10aa65ed2e21ad7fa8e4ef86bc4b35af" title="Current line number. Starts at 1 for the first line, unless derived class changes it...">LineNumber</a> and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a195bafdad5c6bc2d0dce2354f2debce2" title="Index at which the current line started.">LineStartAt</a> properties updated. <a href="#aaf01d80adc87cbc7457dac46df1f41b1">More...</a><br /></td></tr>
<tr class="separator:aaf01d80adc87cbc7457dac46df1f41b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2204b25204257e6c67fd86072fa73d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe2204b25204257e6c67fd86072fa73d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BaseLexer</b> (ICharSource source, string fileName=&quot;&quot;, int inputPosition=0, bool newSourceFile=true)</td></tr>
<tr class="separator:afe2204b25204257e6c67fd86072fa73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a53c05e773d4c3fda024f067af57ae6bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c05e773d4c3fda024f067af57ae6bf"></a>
static HashSet&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NewSet</b> (params int[] items)</td></tr>
<tr class="separator:a53c05e773d4c3fda024f067af57ae6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc64d3d34e11b837e3bc791067c2085a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc64d3d34e11b837e3bc791067c2085a"></a>
static HashSet&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NewSetOfRanges</b> (params int[] ranges)</td></tr>
<tr class="separator:abc64d3d34e11b837e3bc791067c2085a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected fields</h2></td></tr>
<tr class="memitem:ac427e0418ad3558756a6365be0b7461e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac427e0418ad3558756a6365be0b7461e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CachedBlockSize</b> = 512</td></tr>
<tr class="separator:ac427e0418ad3558756a6365be0b7461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb254f4f5e4f2b6c76067ea306fb8db4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb254f4f5e4f2b6c76067ea306fb8db4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_lineStartAt</b></td></tr>
<tr class="separator:aeb254f4f5e4f2b6c76067ea306fb8db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8eeb903f5eef427b220c816436496da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8eeb903f5eef427b220c816436496da"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_lineNumber</b> = 1</td></tr>
<tr class="separator:ae8eeb903f5eef427b220c816436496da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53ed2c550ac6e738972acc41ad71757"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab53ed2c550ac6e738972acc41ad71757"></a>
SourcePos&#160;</td><td class="memItemRight" valign="bottom"><b>IndexToLine</b> (int charIndex)</td></tr>
<tr class="separator:ab53ed2c550ac6e738972acc41ad71757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae963fe4011bda74065554b7f606f0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#abae963fe4011bda74065554b7f606f0e">Newline</a> ()</td></tr>
<tr class="memdesc:abae963fe4011bda74065554b7f606f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default newline parser that matches '<br />
' or '' unconditionally. <a href="#abae963fe4011bda74065554b7f606f0e">More...</a><br /></td></tr>
<tr class="separator:abae963fe4011bda74065554b7f606f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c4e1d9e02ed6f1bd69870ff2f44a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a79c4e1d9e02ed6f1bd69870ff2f44a99">Spaces</a> ()</td></tr>
<tr class="memdesc:a79c4e1d9e02ed6f1bd69870ff2f44a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips past any spaces at the current position. Equivalent to <code>rule Spaces @[ (' '|'')* ]</code> in LLLPG. <a href="#a79c4e1d9e02ed6f1bd69870ff2f44a99">More...</a><br /></td></tr>
<tr class="separator:a79c4e1d9e02ed6f1bd69870ff2f44a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a912e497d5edaeefc406f702c42cd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24a912e497d5edaeefc406f702c42cd0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchAny</b> ()</td></tr>
<tr class="separator:a24a912e497d5edaeefc406f702c42cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989354ec16b9fbb098beaca1f4954234"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a989354ec16b9fbb098beaca1f4954234"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Match</b> (HashSet&lt; int &gt; set)</td></tr>
<tr class="separator:a989354ec16b9fbb098beaca1f4954234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8f9413e205be2d30ccbd974f2098be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf8f9413e205be2d30ccbd974f2098be"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Match</b> (int a)</td></tr>
<tr class="separator:abf8f9413e205be2d30ccbd974f2098be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae696dfbc3405c2c92c9d2ab5c71898da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae696dfbc3405c2c92c9d2ab5c71898da"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Match</b> (int a, int b)</td></tr>
<tr class="separator:ae696dfbc3405c2c92c9d2ab5c71898da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88e5e0ef54f8f30394d78200866c8bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad88e5e0ef54f8f30394d78200866c8bc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Match</b> (int a, int b, int c)</td></tr>
<tr class="separator:ad88e5e0ef54f8f30394d78200866c8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16124cdfbbc03f33a1cc70774070a58f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16124cdfbbc03f33a1cc70774070a58f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Match</b> (int a, int b, int c, int d)</td></tr>
<tr class="separator:a16124cdfbbc03f33a1cc70774070a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b27c275f5c7611471ec953d93b10c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79b27c275f5c7611471ec953d93b10c5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchRange</b> (int aLo, int aHi)</td></tr>
<tr class="separator:a79b27c275f5c7611471ec953d93b10c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e219b0596bba3e3298ae41a13b8b1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00e219b0596bba3e3298ae41a13b8b1e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchRange</b> (int aLo, int aHi, int bLo, int bHi)</td></tr>
<tr class="separator:a00e219b0596bba3e3298ae41a13b8b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb5b2865347675eeafaf54e942d74af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fb5b2865347675eeafaf54e942d74af"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExcept</b> ()</td></tr>
<tr class="separator:a0fb5b2865347675eeafaf54e942d74af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8666dcd3ffb3512ba4d5537f6dc67480"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8666dcd3ffb3512ba4d5537f6dc67480"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExcept</b> (HashSet&lt; int &gt; set)</td></tr>
<tr class="separator:a8666dcd3ffb3512ba4d5537f6dc67480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64968bdd1a41ee4013021bea728738ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64968bdd1a41ee4013021bea728738ee"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExcept</b> (int a)</td></tr>
<tr class="separator:a64968bdd1a41ee4013021bea728738ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4262bd3b29b8b8708ae86df549dc4e27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4262bd3b29b8b8708ae86df549dc4e27"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExcept</b> (int a, int b)</td></tr>
<tr class="separator:a4262bd3b29b8b8708ae86df549dc4e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ce2931370ef2653fd598eefbdef4db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5ce2931370ef2653fd598eefbdef4db"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExcept</b> (int a, int b, int c)</td></tr>
<tr class="separator:ab5ce2931370ef2653fd598eefbdef4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d3b3f3f052f98bee8c25cbaf5af04f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97d3b3f3f052f98bee8c25cbaf5af04f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExcept</b> (int a, int b, int c, int d)</td></tr>
<tr class="separator:a97d3b3f3f052f98bee8c25cbaf5af04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79345325987375813bf153380ee0f75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab79345325987375813bf153380ee0f75"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExceptRange</b> (int aLo, int aHi)</td></tr>
<tr class="separator:ab79345325987375813bf153380ee0f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2b55568a4f7430dc2944857366369e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b2b55568a4f7430dc2944857366369e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MatchExceptRange</b> (int aLo, int aHi, int bLo, int bHi)</td></tr>
<tr class="separator:a8b2b55568a4f7430dc2944857366369e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f44082eff9d65428ec01d752b5bff6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83f44082eff9d65428ec01d752b5bff6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatch</b> (HashSet&lt; int &gt; set)</td></tr>
<tr class="separator:a83f44082eff9d65428ec01d752b5bff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8caf15f395c4cdda9f9cd69a03583f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c8caf15f395c4cdda9f9cd69a03583f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatch</b> (int a)</td></tr>
<tr class="separator:a2c8caf15f395c4cdda9f9cd69a03583f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25af34eed7a5ce39509e937661b0fc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad25af34eed7a5ce39509e937661b0fc0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatch</b> (int a, int b)</td></tr>
<tr class="separator:ad25af34eed7a5ce39509e937661b0fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df24a7d60d5c4da814e2b30b39e024e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5df24a7d60d5c4da814e2b30b39e024e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatch</b> (int a, int b, int c)</td></tr>
<tr class="separator:a5df24a7d60d5c4da814e2b30b39e024e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad74f4f7b1114fe43a9abbe2d4bd0b6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad74f4f7b1114fe43a9abbe2d4bd0b6a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatch</b> (int a, int b, int c, int d)</td></tr>
<tr class="separator:aad74f4f7b1114fe43a9abbe2d4bd0b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d455af37f23ad5c1926cff8ee331b49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d455af37f23ad5c1926cff8ee331b49"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchRange</b> (int aLo, int aHi)</td></tr>
<tr class="separator:a7d455af37f23ad5c1926cff8ee331b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d41a5b72b6bebfcf045bb3ded8fc3b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d41a5b72b6bebfcf045bb3ded8fc3b4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchRange</b> (int aLo, int aHi, int bLo, int bHi)</td></tr>
<tr class="separator:a3d41a5b72b6bebfcf045bb3ded8fc3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa88a13bdc50b6804715ffc1bef787c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa88a13bdc50b6804715ffc1bef787c4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExcept</b> ()</td></tr>
<tr class="separator:afa88a13bdc50b6804715ffc1bef787c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4024ceef85e3cf565d661fdb3fef66b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4024ceef85e3cf565d661fdb3fef66b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExcept</b> (HashSet&lt; int &gt; set)</td></tr>
<tr class="separator:aa4024ceef85e3cf565d661fdb3fef66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f0db593c731313c884650cb910006e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42f0db593c731313c884650cb910006e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExcept</b> (int a)</td></tr>
<tr class="separator:a42f0db593c731313c884650cb910006e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115eb42b4fd0042e916ee09dd6ce45a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a115eb42b4fd0042e916ee09dd6ce45a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExcept</b> (int a, int b)</td></tr>
<tr class="separator:a115eb42b4fd0042e916ee09dd6ce45a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01978861942c755d0d57a0185671dfed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01978861942c755d0d57a0185671dfed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExcept</b> (int a, int b, int c)</td></tr>
<tr class="separator:a01978861942c755d0d57a0185671dfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad460e405359d3f91dee0b236c59c7434"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad460e405359d3f91dee0b236c59c7434"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExcept</b> (int a, int b, int c, int d)</td></tr>
<tr class="separator:ad460e405359d3f91dee0b236c59c7434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ecd2b9737ac3e9cdb43f735ab3e00e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93ecd2b9737ac3e9cdb43f735ab3e00e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExceptRange</b> (int aLo, int aHi)</td></tr>
<tr class="separator:a93ecd2b9737ac3e9cdb43f735ab3e00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa051af0df9e4ea469d41503f0c0dae4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa051af0df9e4ea469d41503f0c0dae4e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryMatchExceptRange</b> (int aLo, int aHi, int bLo, int bHi)</td></tr>
<tr class="separator:aa051af0df9e4ea469d41503f0c0dae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e00a004728efa30701f4d3cda228cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39e00a004728efa30701f4d3cda228cf"></a>
virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Check</b> (bool expectation, string expectedDescr=&quot;&quot;)</td></tr>
<tr class="separator:a39e00a004728efa30701f4d3cda228cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa705871192b412f511003f01639b97fb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#aa705871192b412f511003f01639b97fb">Error</a> (int lookaheadIndex, string message)</td></tr>
<tr class="memdesc:aa705871192b412f511003f01639b97fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called to handle errors that occur during lexing. <a href="#aa705871192b412f511003f01639b97fb">More...</a><br /></td></tr>
<tr class="separator:aa705871192b412f511003f01639b97fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67212f3809c7a95082c92b7c5c04c388"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a67212f3809c7a95082c92b7c5c04c388">Error</a> (int lookaheadIndex, string format, params object[] args)</td></tr>
<tr class="memdesc:a67212f3809c7a95082c92b7c5c04c388"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called to format and handle errors that occur during lexing. The default implementation sends errors to <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a2e052d761c53ba883b58b03cb7f8e4ff" title="Gets or sets the object to which error messages are sent. The default object is LogExceptionErrorSink...">ErrorSink</a>, which, by default, throws a FormatException. <a href="#a67212f3809c7a95082c92b7c5c04c388">More...</a><br /></td></tr>
<tr class="separator:a67212f3809c7a95082c92b7c5c04c388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d6401f50d9084d45fc515b4ed09437"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6d6401f50d9084d45fc515b4ed09437"></a>
virtual object&#160;</td><td class="memItemRight" valign="bottom"><b>IndexToPositionObject</b> (int charIndex)</td></tr>
<tr class="separator:ae6d6401f50d9084d45fc515b4ed09437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180ca0bc2dd4cb5dae55a6b82de2dbdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a180ca0bc2dd4cb5dae55a6b82de2dbdd"></a>
virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MatchError</b> (bool inverted, params int[] ranges)</td></tr>
<tr class="separator:a180ca0bc2dd4cb5dae55a6b82de2dbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2621df0453538154db43418000a82073"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a2621df0453538154db43418000a82073">MatchError</a> (bool inverted, IList&lt; int &gt; ranges)</td></tr>
<tr class="memdesc:a2621df0453538154db43418000a82073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles an error that occurs during Match(), MatchExcept(), MatchRange() or MatchExceptRange() <a href="#a2621df0453538154db43418000a82073">More...</a><br /></td></tr>
<tr class="separator:a2621df0453538154db43418000a82073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570afeccb0831511129a01a928789746"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a570afeccb0831511129a01a928789746"></a>
virtual <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Error</b> (bool inverted, HashSet&lt; int &gt; set)</td></tr>
<tr class="separator:a570afeccb0831511129a01a928789746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab17e0960bcab0b15dd3c2c0c9f012d"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a9ab17e0960bcab0b15dd3c2c0c9f012d">RangesToString</a> (IList&lt; int &gt; ranges)</td></tr>
<tr class="memdesc:a9ab17e0960bcab0b15dd3c2c0c9f012d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a list of character ranges to a string, e.g. for input list {'*','*','a','z'}, the output is "'*' 'a'..'z'". <a href="#a9ab17e0960bcab0b15dd3c2c0c9f012d">More...</a><br /></td></tr>
<tr class="separator:a9ab17e0960bcab0b15dd3c2c0c9f012d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a6036bb9deaf51fff90e741a79e206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#ab0a6036bb9deaf51fff90e741a79e206">PrintChar</a> (int c, StringBuilder sb)</td></tr>
<tr class="memdesc:ab0a6036bb9deaf51fff90e741a79e206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a character as a string, e.g. <code>'a' -&gt; "'a'"</code>, with the special value -1 representing EOF, so PrintChar(-1, ...) == "EOF". <a href="#ab0a6036bb9deaf51fff90e741a79e206">More...</a><br /></td></tr>
<tr class="separator:ab0a6036bb9deaf51fff90e741a79e206"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aee0fca65b95753d88fdccc1b9e5a7214"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.<a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">BaseLexer</a> </td>
          <td>(</td>
          <td class="paramtype">CharSrc&#160;</td>
          <td class="paramname"><em>chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputPosition</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newSourceFile</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html" title="The recommended base class for lexers generated by LLLPG, when not using the inputSource option...">BaseLexer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>A source of characters, e.g. UString.</td></tr>
    <tr><td class="paramname">fileName</td><td>A file name associated with the characters, which will be used for error reporting.</td></tr>
    <tr><td class="paramname">inputPosition</td><td>A location to start lexing (normally 0). Careful: If you're starting to lex in the middle of the file, the <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a10aa65ed2e21ad7fa8e4ef86bc4b35af" title="Current line number. Starts at 1 for the first line, unless derived class changes it...">LineNumber</a> still starts at 1, and (if <code>newSourceFile</code> is true) the <a class="el" href="classLoyc_1_1Syntax_1_1SourceFile.html" title="A default implementation of ISourceFile based on IndexPositionMapper.">SourceFile</a> object may or may not discover line breaks prior to the starting point, depending on how it is used.</td></tr>
    <tr><td class="paramname">newSourceFile</td><td>Whether to create a LexerSourceFile&lt;C&gt; object (an implementation of ISourceFile) to keep track of line boundaries. The <a class="el" href="classLoyc_1_1Syntax_1_1SourceFile.html" title="A default implementation of ISourceFile based on IndexPositionMapper.">SourceFile</a> property will point to this object, and it will be null if this parameter is false. Using 'false' will avoid memory allocation, but prevent you from mapping character positions to line numbers and vice versa. However, this object will still keep track of the current <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a10aa65ed2e21ad7fa8e4ef86bc4b35af" title="Current line number. Starts at 1 for the first line, unless derived class changes it...">LineNumber</a> and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a195bafdad5c6bc2d0dce2354f2debce2" title="Index at which the current line started.">LineStartAt</a> (the index where the current line started) when this parameter is false.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaf01d80adc87cbc7457dac46df1f41b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.AfterNewline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The lexer must call this method exactly once after it advances past each newline, even inside comments and strings. This method keeps the <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a10aa65ed2e21ad7fa8e4ef86bc4b35af" title="Current line number. Starts at 1 for the first line, unless derived class changes it...">LineNumber</a> and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a195bafdad5c6bc2d0dce2354f2debce2" title="Index at which the current line started.">LineStartAt</a> properties updated.</p>

<p>Reimplemented in <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseILexer.html#acdb9de5430c8ac55299c19736deeef7c">Loyc.Syntax.Lexing.BaseILexer&lt; CharSrc, Token &gt;</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSource.html#ade103d22afad41ba21889c2396006aed">Loyc.Syntax.Lexing.LexerSource&lt; CharSrc &gt;</a>.</p>

<p>References <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSourceFile.html#a4a6088563bf5f11122cf3e975e0c602d">Loyc.Syntax.Lexing.LexerSourceFile&lt; CharSource &gt;.AfterNewline()</a>.</p>

</div>
</div>
<a class="anchor" id="aa705871192b412f511003f01639b97fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.Error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lookaheadIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called to handle errors that occur during lexing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lookaheadIndex</td><td>Index where the error occurred, relative to the current InputPosition (i.e. InputPosition + lookaheadIndex is the position of the error).</td></tr>
    <tr><td class="paramname">message</td><td>An error message, not including the error location.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSourceWorkaround.html#af124a47fd8c62eef95e0a8990e251b78">Loyc.Syntax.Lexing.LexerSourceWorkaround&lt; CharSrc &gt;</a>, <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSource.html#a25b0fabb3d20ba608c2c4bd3e48e022d">Loyc.Syntax.Lexing.LexerSource&lt; CharSrc &gt;</a>, and <a class="el" href="classLoyc_1_1Ecs_1_1Parser_1_1EcsLexer.html#a0a19241db8db078399b6dd65ecd13f83">Loyc.Ecs.Parser.EcsLexer</a>.</p>

</div>
</div>
<a class="anchor" id="a67212f3809c7a95082c92b7c5c04c388"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.Error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lookaheadIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params object[]&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called to format and handle errors that occur during lexing. The default implementation sends errors to <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a2e052d761c53ba883b58b03cb7f8e4ff" title="Gets or sets the object to which error messages are sent. The default object is LogExceptionErrorSink...">ErrorSink</a>, which, by default, throws a FormatException.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lookaheadIndex</td><td>Index where the error occurred, relative to the current InputPosition (i.e. InputPosition + lookaheadIndex is the position of the error).</td></tr>
    <tr><td class="paramname">format</td><td>An error description with argument placeholders.</td></tr>
    <tr><td class="paramname">args</td><td>Arguments to insert into the error message.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSourceWorkaround.html#a5d226cb13e6f4ce57bb988c39e3dca5e">Loyc.Syntax.Lexing.LexerSourceWorkaround&lt; CharSrc &gt;</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSource.html#a1469281ae2a685657210cd51c705842a">Loyc.Syntax.Lexing.LexerSource&lt; CharSrc &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2621df0453538154db43418000a82073"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.MatchError </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IList&lt; int &gt;&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles an error that occurs during Match(), MatchExcept(), MatchRange() or MatchExceptRange()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverted</td><td>Set inversion flag. If true, then <code>expected</code> is actually a list of things that were NOT expected.</td></tr>
    <tr><td class="paramname">ranges</td><td>List of ranges of characters that were expected (or unexpected, if <code>inverted</code>)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abae963fe4011bda74065554b7f606f0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.Newline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default newline parser that matches '<br />
' or '' unconditionally.</p>
<p>You can use this implementation in an LLLPG lexer with "extern", like so: <code>extern rule Newline '' + '<br />
'? | '<br />
' };</code> By using this implementation everywhere in the grammar in which a newline is allowed (even inside comments and strings), you can ensure that <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#aaf01d80adc87cbc7457dac46df1f41b1" title="The lexer must call this method exactly once after it advances past each newline, even inside comment...">AfterNewline()</a> is called, so that the line number is updated properly. </p>

</div>
</div>
<a class="anchor" id="ab0a6036bb9deaf51fff90e741a79e206"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.PrintChar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringBuilder&#160;</td>
          <td class="paramname"><em>sb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a character as a string, e.g. <code>'a' -&gt; "'a'"</code>, with the special value -1 representing EOF, so PrintChar(-1, ...) == "EOF".</p>

<p>References <a class="el" href="classLoyc_1_1Syntax_1_1PrintHelpers.html#a60a4d97fc46d2f5826bd42f1016032ac">Loyc.Syntax.PrintHelpers.EscapeCStyle()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ab17e0960bcab0b15dd3c2c0c9f012d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.RangesToString </td>
          <td>(</td>
          <td class="paramtype">IList&lt; int &gt;&#160;</td>
          <td class="paramname"><em>ranges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a list of character ranges to a string, e.g. for input list {'*','*','a','z'}, the output is "'*' 'a'..'z'".</p>

</div>
</div>
<a class="anchor" id="a429c45b8daf9f0adafa187bf4e27f211"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.Reset </td>
          <td>(</td>
          <td class="paramtype">CharSrc&#160;</td>
          <td class="paramname"><em>chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputPosition</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newSourceFile</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinitializes the object. This method is called by the constructor.</p>
<p>See the constructor for documentation of the parameters. </p>
<p>This method can be used to avoid memory allocations when you need to parse many small strings in a row. If that's your goal, you should set the <code>newSourceFile</code> parameter to false if possible.</p>

<p>Reimplemented in <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseILexer.html#aed0208c6e7680f95359a2f6688534080">Loyc.Syntax.Lexing.BaseILexer&lt; CharSrc, Token &gt;</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1LexerSource.html#a9bc7605801736eee683422aee1a79588">Loyc.Syntax.Lexing.LexerSource&lt; CharSrc &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae2ed46c1667602dbdfdab1f5fe49785a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.Skip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments InputPosition. Called by LLLPG when prediction already verified the input (and caller doesn't save LA(0))</p>

</div>
</div>
<a class="anchor" id="a79c4e1d9e02ed6f1bd69870ff2f44a99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.Spaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips past any spaces at the current position. Equivalent to <code>rule Spaces @[ (' '|'')* ]</code> in LLLPG.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2519061cb92a4df83891264cec3796f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly IMessageSink <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.FormatExceptionErrorSink</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= MessageSink.FromDelegate(</div><div class="line">            (sev, location, fmt, args) =&gt; { </div><div class="line">                <span class="keywordflow">if</span> (sev &gt;= Severity.Error)</div><div class="line">                    <span class="keywordflow">throw</span> <span class="keyword">new</span> FormatException(MessageSink.ContextToString(location) + <span class="stringliteral">&quot;: &quot;</span> + Localize.Localized(fmt, args));</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                    MessageSink.Default.Write(sev, location, fmt, args);</div><div class="line">            })</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1fbcd1f42ea2ebe33b7ee53481fd73e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly IMessageSink <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.LogExceptionErrorSink</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= MessageSink.FromDelegate(</div><div class="line">            (sev, location, fmt, args) =&gt; {</div><div class="line">                LogMessage msg = <span class="keyword">new</span> LogMessage(sev, location, fmt, args);</div><div class="line">                <span class="keywordflow">if</span> (sev &gt;= Severity.Error)</div><div class="line">                    <span class="keywordflow">throw</span> <span class="keyword">new</span> LogException(msg);</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                    msg.WriteTo(MessageSink.Default);</div><div class="line">            })</div></div><!-- fragment -->
<p>Throws <a class="el" href="classLoyc_1_1LogException.html" title="An exception that includes a &quot;context&quot; object as part of a LogMessage structure, typically used to in...">LogException</a> when it receives an error. Non-errors are sent to MessageSink.Default.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a2e052d761c53ba883b58b03cb7f8e4ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IMessageSink <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.ErrorSink</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the object to which error messages are sent. The default object is <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html#a1fbcd1f42ea2ebe33b7ee53481fd73e6" title="Throws LogException when it receives an error. Non-errors are sent to MessageSink.Default.">LogExceptionErrorSink</a>, which throws an exception if an error occurs.</p>

</div>
</div>
<a class="anchor" id="a10aa65ed2e21ad7fa8e4ef86bc4b35af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.LineNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current line number. Starts at 1 for the first line, unless derived class changes it.</p>

</div>
</div>
<a class="anchor" id="a195bafdad5c6bc2d0dce2354f2debce2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLoyc_1_1Syntax_1_1Lexing_1_1BaseLexer.html">Loyc.Syntax.Lexing.BaseLexer</a>&lt; CharSrc &gt;.LineStartAt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index at which the current line started.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 17 2020 19:38:15 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
