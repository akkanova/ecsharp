<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Enhanced C#: Loyc.Collections.Impl.AListIndexer&lt; K, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections_1_1Impl.html">Impl</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">AListIndexer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-attribs">Protected static fields</a> &#124;
<a href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.Impl.AListIndexer&lt; K, T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Observes changes and builds a table of items in the tree. 
 <a href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Collections/ALists/AListIndexer.cs'>/Core/Loyc.Collections/ALists/AListIndexer.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.png" usemap="#Loyc.Collections.Impl.AListIndexer_3C_20K_2C_20T_20_3E_map" alt=""/>
  <map id="Loyc.Collections.Impl.AListIndexer_3C_20K_2C_20T_20_3E_map" name="Loyc.Collections.Impl.AListIndexer&lt; K, T &gt;_map">
<area href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver.html" title="An interface that is called to notify observers when items or nodes in the tree of a class derived fr..." alt="Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;" shape="rect" coords="0,0,301,24"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>Observes changes and builds a table of items in the tree.</p>
<p>The IndexedAList&lt;T&gt; class uses one of these objects to speed up methods that search for items in an AList&lt;T&gt; (IndexOf, Contains, and Remove). The amount of speedup is limited by the size of the nodes in the list being indexed; see <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a7e33aee6db7ab05844c7d15b0322c2b3" title="Returns an index at which the specified item can be found.">IndexOfAny</a>. </p>
<p>It is wasteful to use an <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html" title="Observes changes and builds a table of items in the tree.">AListIndexer</a> if the list is small. <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html" title="Observes changes and builds a table of items in the tree.">AListIndexer</a> is designed to accelerate searches in very large lists, and it offers no performance benefit to small lists; to the contrary, it just wastes time and memory in small lists. </p>
<p>It is recommended to use <a class="el" href="classLoyc_1_1Collections_1_1IndexedAList.html" title="A simple wrapper around AList that includes an AListIndexer&lt;K,T&gt; that can be used to find items relat...">IndexedAList</a> instead of instantiating this class directly. </p>
<p>In general, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html" title="Observes changes and builds a table of items in the tree.">AListIndexer</a> requires more memory than the list that is being indexed. Specifically, if pointers use P bytes, then <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html" title="Observes changes and builds a table of items in the tree.">AListIndexer</a> itself consumes moderately MORE than X+P*N bytes of memory, where X is the size of the list being indexed, and N is the number of items in the list. Thus, for example, an indexed list of AList&lt;Object&gt; requires approximately three times as much memory as an <a class="el" href="classLoyc_1_1Collections_1_1AList.html" title="An all-purpose list structure with the following additional features beyond what&#39;s offered by List&lt;T&gt;...">AList</a> that is not indexed. </p>
<p>Moreover, changing an indexed list takes at least twice as much time, since the indexer must be notified of each change and updates to the index take O(log N) time per update. Batch operations involving X items that take O(log N) time without an indexer (e.g. RemoveRange(i, X)) will take O(X log N) time instead, because the indexer must be notified about each item changed. </p>
<p>Still, these costs are worthwhile in applications that frequently search for items in the list. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a21af8e0b0eaf38ee8dbbe22f55348dcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21af8e0b0eaf38ee8dbbe22f55348dcb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ItemCount</b><code> [get]</code></td></tr>
<tr class="separator:a21af8e0b0eaf38ee8dbbe22f55348dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5ba4226f293b65d6e1a69384a1b09a16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a5ba4226f293b65d6e1a69384a1b09a16">Attach</a> (<a class="el" href="classLoyc_1_1Collections_1_1AListBase.html">AListBase</a>&lt; K, T &gt; list)</td></tr>
<tr class="memdesc:a5ba4226f293b65d6e1a69384a1b09a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the observer is being attached to an <a class="el" href="classLoyc_1_1Collections_1_1AList.html" title="An all-purpose list structure with the following additional features beyond what&#39;s offered by List&lt;T&gt;...">AList</a>. <a href="#a5ba4226f293b65d6e1a69384a1b09a16">More...</a><br /></td></tr>
<tr class="separator:a5ba4226f293b65d6e1a69384a1b09a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3892007948198657d3ef001b280372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#acc3892007948198657d3ef001b280372">Detach</a> (<a class="el" href="classLoyc_1_1Collections_1_1AListBase.html">AListBase</a>&lt; K, T &gt; list, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt; root)</td></tr>
<tr class="memdesc:acc3892007948198657d3ef001b280372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the observer is being detached from an <a class="el" href="classLoyc_1_1Collections_1_1AList.html" title="An all-purpose list structure with the following additional features beyond what&#39;s offered by List&lt;T&gt;...">AList</a>. <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#acc3892007948198657d3ef001b280372" title="Called when the observer is being detached from an AList. Detach(), unlike Attach(), is not paired with a call to RootChanged.">Detach()</a>, unlike <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a5ba4226f293b65d6e1a69384a1b09a16" title="Called when the observer is being attached to an AList.">Attach()</a>, is not paired with a call to RootChanged. <a href="#acc3892007948198657d3ef001b280372">More...</a><br /></td></tr>
<tr class="separator:acc3892007948198657d3ef001b280372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1722336197cb2dfb1d8152b635dfa84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#ab1722336197cb2dfb1d8152b635dfa84">RootChanged</a> (<a class="el" href="classLoyc_1_1Collections_1_1AListBase.html">AListBase</a>&lt; K, T &gt; list, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt; newRoot, bool clear)</td></tr>
<tr class="memdesc:ab1722336197cb2dfb1d8152b635dfa84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the root of the tree changes, or when the list is cleared. Also called after <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a5ba4226f293b65d6e1a69384a1b09a16" title="Called when the observer is being attached to an AList.">Attach()</a>, but not after <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#acc3892007948198657d3ef001b280372" title="Called when the observer is being detached from an AList. Detach(), unlike Attach(), is not paired with a call to RootChanged.">Detach()</a>. <a href="#ab1722336197cb2dfb1d8152b635dfa84">More...</a><br /></td></tr>
<tr class="separator:ab1722336197cb2dfb1d8152b635dfa84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781652b1058d822ca77507fe922b10b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a781652b1058d822ca77507fe922b10b7">ItemAdded</a> (T item, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListLeafBase.html">AListLeafBase</a>&lt; K, T &gt; parent)</td></tr>
<tr class="memdesc:a781652b1058d822ca77507fe922b10b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an item is added to a leaf node. <a href="#a781652b1058d822ca77507fe922b10b7">More...</a><br /></td></tr>
<tr class="separator:a781652b1058d822ca77507fe922b10b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f6bd7a757f9778c73477fc36159dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#ae8f6bd7a757f9778c73477fc36159dff">ItemRemoved</a> (T item, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListLeafBase.html">AListLeafBase</a>&lt; K, T &gt; parent)</td></tr>
<tr class="memdesc:ae8f6bd7a757f9778c73477fc36159dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an item is removed from a leaf node. <a href="#ae8f6bd7a757f9778c73477fc36159dff">More...</a><br /></td></tr>
<tr class="separator:ae8f6bd7a757f9778c73477fc36159dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fbe8c917f1192577b8822d94ebbab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a48fbe8c917f1192577b8822d94ebbab9">NodeAdded</a> (<a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt; child, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase.html">AListInnerBase</a>&lt; K, T &gt; parent)</td></tr>
<tr class="memdesc:a48fbe8c917f1192577b8822d94ebbab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a child node is added to an inner node. <a href="#a48fbe8c917f1192577b8822d94ebbab9">More...</a><br /></td></tr>
<tr class="separator:a48fbe8c917f1192577b8822d94ebbab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485240c333c0246e5b2ebea9b672759a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a485240c333c0246e5b2ebea9b672759a">NodeRemoved</a> (<a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt; child, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase.html">AListInnerBase</a>&lt; K, T &gt; parent)</td></tr>
<tr class="memdesc:a485240c333c0246e5b2ebea9b672759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a child node is removed from an inner node. <a href="#a485240c333c0246e5b2ebea9b672759a">More...</a><br /></td></tr>
<tr class="separator:a485240c333c0246e5b2ebea9b672759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d088065dd3b9f3c641880278cdb0c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a83d088065dd3b9f3c641880278cdb0c1">RemoveAll</a> (<a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt; node)</td></tr>
<tr class="memdesc:a83d088065dd3b9f3c641880278cdb0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when all children are being removed from a node (leaf or inner) because the node is being split (AddAll will be called afterward for the two replacement nodes). Notifications are not sent for individual children. <a href="#a83d088065dd3b9f3c641880278cdb0c1">More...</a><br /></td></tr>
<tr class="separator:a83d088065dd3b9f3c641880278cdb0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea987f20a54a971acfff33b38a41965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a9ea987f20a54a971acfff33b38a41965">AddAll</a> (<a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt; node)</td></tr>
<tr class="memdesc:a9ea987f20a54a971acfff33b38a41965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when all children are being added to a node (leaf or inner). Notifications are not sent for individual children. <a href="#a9ea987f20a54a971acfff33b38a41965">More...</a><br /></td></tr>
<tr class="separator:a9ea987f20a54a971acfff33b38a41965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda2c5306cc230494d78426a60ae5463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#abda2c5306cc230494d78426a60ae5463">CheckPoint</a> ()</td></tr>
<tr class="memdesc:abda2c5306cc230494d78426a60ae5463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a tree modification operation is completed. <a href="#abda2c5306cc230494d78426a60ae5463">More...</a><br /></td></tr>
<tr class="separator:abda2c5306cc230494d78426a60ae5463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e33aee6db7ab05844c7d15b0322c2b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a7e33aee6db7ab05844c7d15b0322c2b3">IndexOfAny</a> (T item)</td></tr>
<tr class="memdesc:a7e33aee6db7ab05844c7d15b0322c2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an index at which the specified item can be found. <a href="#a7e33aee6db7ab05844c7d15b0322c2b3">More...</a><br /></td></tr>
<tr class="separator:a7e33aee6db7ab05844c7d15b0322c2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a79679a0c1f50d542e8fac0f091c1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53a79679a0c1f50d542e8fac0f091c1f"></a>
List&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexesOf</b> (T item)</td></tr>
<tr class="separator:a53a79679a0c1f50d542e8fac0f091c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9b93b9ec85b02a3df15a2afffdae77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a9c9b93b9ec85b02a3df15a2afffdae77">VerifyCorrectness</a> ()</td></tr>
<tr class="memdesc:a9c9b93b9ec85b02a3df15a2afffdae77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the index to verify that it matches the tree that is being indexed. The scan takes O(N log N + N M) time for a list of length N with maximum node size M. <a href="#a9c9b93b9ec85b02a3df15a2afffdae77">More...</a><br /></td></tr>
<tr class="separator:a9c9b93b9ec85b02a3df15a2afffdae77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7649fe9d6adf04933d11d50b368b32"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a3d7649fe9d6adf04933d11d50b368b32">CountMemory</a> (int sizeOfElement)</td></tr>
<tr class="memdesc:a3d7649fe9d6adf04933d11d50b368b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts memory used by the index itself (not including the <a class="el" href="classLoyc_1_1Collections_1_1AList.html" title="An all-purpose list structure with the following additional features beyond what&#39;s offered by List&lt;T&gt;...">AList</a> nodes) <a href="#a3d7649fe9d6adf04933d11d50b368b32">More...</a><br /></td></tr>
<tr class="separator:a3d7649fe9d6adf04933d11d50b368b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6dd249cf2084b454d1f8c273f174c95c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a6dd249cf2084b454d1f8c273f174c95c">ReconstructIndex</a> (T item, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListLeafBase.html">AListLeafBase</a>&lt; K, T &gt; leaf)</td></tr>
<tr class="memdesc:a6dd249cf2084b454d1f8c273f174c95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an item and a leaf that is known to contain a copy of the item, this method returns the index of the item in the tree as a whole. Requires O(M ) <a href="#a6dd249cf2084b454d1f8c273f174c95c">More...</a><br /></td></tr>
<tr class="separator:a6dd249cf2084b454d1f8c273f174c95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Protected static fields</h2></td></tr>
<tr class="memitem:ac6aefd00aff43eabf032dc33925fec5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6aefd00aff43eabf032dc33925fec5e"></a>
static Func&lt; T, T, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CompareTHashCodes</b> = CompareHashCodes&lt;T&gt;</td></tr>
<tr class="separator:ac6aefd00aff43eabf032dc33925fec5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24031327cca5463a8f96de66ec8d56e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae24031327cca5463a8f96de66ec8d56e"></a>
static Func&lt; <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt;, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CompareNodeHashCodes</b> = CompareHashCodes&lt;<a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt;K, T&gt;&gt;</td></tr>
<tr class="separator:ae24031327cca5463a8f96de66ec8d56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace138a3b993c13b75ef318a3228879dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace138a3b993c13b75ef318a3228879dc"></a>
static Func&lt; <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListLeafBase.html">AListLeafBase</a>&lt; K, T &gt;, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListLeafBase.html">AListLeafBase</a>&lt; K, T &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CompareLeafHashCodes</b> = CompareHashCodes&lt;<a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt;K, T&gt;&gt;</td></tr>
<tr class="separator:ace138a3b993c13b75ef318a3228879dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc12e2be996c5b259fa283e96a350dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cc12e2be996c5b259fa283e96a350dd"></a>
static Func&lt; <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase.html">AListInnerBase</a>&lt; K, T &gt;, <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase.html">AListInnerBase</a>&lt; K, T &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CompareInnerHashCodes</b> = CompareHashCodes&lt;<a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase.html">AListInnerBase</a>&lt;K, T&gt;&gt;</td></tr>
<tr class="separator:a0cc12e2be996c5b259fa283e96a350dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9ea987f20a54a971acfff33b38a41965"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.AddAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when all children are being added to a node (leaf or inner). Notifications are not sent for individual children.</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver.html#a767a338b6f7dac6380210491cb125cd9">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5ba4226f293b65d6e1a69384a1b09a16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.Attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1AListBase.html">AListBase</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when the observer is being attached to an <a class="el" href="classLoyc_1_1Collections_1_1AList.html" title="An all-purpose list structure with the following additional features beyond what&#39;s offered by List&lt;T&gt;...">AList</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list that the observer is being attached to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true or false to cause notifications to be sent about all the nodes in the tree, via a depth-first search that calls <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a9ea987f20a54a971acfff33b38a41965" title="Called when all children are being added to a node (leaf or inner). Notifications are not sent for in...">AddAll</a> for each node in the tree. Return true if you want AddAll to be called for children before their parents (roughly, leaves first). Use False if you want AddAll to be called for inner nodes before their children. If you return null, no notifications are sent except for <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#ab1722336197cb2dfb1d8152b635dfa84" title="Called when the root of the tree changes, or when the list is cleared. Also called after Attach()...">RootChanged</a> which will be called unconditionally. </dd></dl>
<p>If <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a5ba4226f293b65d6e1a69384a1b09a16" title="Called when the observer is being attached to an AList.">Attach()</a> throws an exception, <a class="el" href="classLoyc_1_1Collections_1_1AListBase.html">AListBase&lt;K,T&gt;</a> will cancel the AddObserver() operation and it will not catch the exception. </p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver.html#ab3d546df46c02a2a55d920f2dea0383a">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abda2c5306cc230494d78426a60ae5463"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.CheckPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a tree modification operation is completed.</p>
<p>This is called after each modification operation (Add, Insert, Remove, Replace, etc.); the list will normally be in a read-only state ("frozen for concurrency") when this method is called, so do not initiate changes from here. </p>
<p>This method can safely throw an exception, and the list class will not swallow it. Note: if there are multiple observers, throwing an exception from one observers will prevent this notification from reaching other observers that have not been notified yet. </p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver.html#a07dcf4204ea5c803359b54d7fe1d4278">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3d7649fe9d6adf04933d11d50b368b32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.CountMemory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeOfElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts memory used by the index itself (not including the <a class="el" href="classLoyc_1_1Collections_1_1AList.html" title="An all-purpose list structure with the following additional features beyond what&#39;s offered by List&lt;T&gt;...">AList</a> nodes)</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1IndexedAList.html#a433a750f1ea6329c72012453c4db3082">Loyc.Collections.IndexedAList&lt; T &gt;.VerifyCorrectness()</a>.</p>

</div>
</div>
<a class="anchor" id="acc3892007948198657d3ef001b280372"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.Detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1AListBase.html">AListBase</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when the observer is being detached from an <a class="el" href="classLoyc_1_1Collections_1_1AList.html" title="An all-purpose list structure with the following additional features beyond what&#39;s offered by List&lt;T&gt;...">AList</a>. <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#acc3892007948198657d3ef001b280372" title="Called when the observer is being detached from an AList. Detach(), unlike Attach(), is not paired with a call to RootChanged.">Detach()</a>, unlike <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a5ba4226f293b65d6e1a69384a1b09a16" title="Called when the observer is being attached to an AList.">Attach()</a>, is not paired with a call to RootChanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>List that is being detached.</td></tr>
    <tr><td class="paramname">root</td><td>Root node that is being detached.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver.html#a17cdb93613427c6acabd9337ded7762f">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7e33aee6db7ab05844c7d15b0322c2b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.IndexOfAny </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an index at which the specified item can be found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the item in the list being indexed by this object, or -1 if the item does not exist in the list.</dd></dl>
<p>The search takes O(M log^2 N) time, where N is the size of the list and M is the maximum size of nodes in the list. Due to the "M" factor, A-lists with large nodes are searched more slowly than A-lists with small nodes; however, the "log N" part is a base-M logarithm, so you don't actually gain performance by using very small nodes. This is because very small nodes require deeply nested trees, and deep trees are slow. The <a class="el" href="classLoyc_1_1Collections_1_1AListBase.html">AListBase&lt;K,T&gt;</a> documentation discusses the effect of node size further. </p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1IndexedAList.html#af7652eb18e892b61c8fe7aacc042f0f8">Loyc.Collections.IndexedAList&lt; T &gt;.IndexOf()</a>.</p>

</div>
</div>
<a class="anchor" id="a781652b1058d822ca77507fe922b10b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.ItemAdded </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListLeafBase.html">AListLeafBase</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an item is added to a leaf node.</p>
<p>Note: this may be called as part of a move operation (remove+add)</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver.html#a1eee526adcaabd84d11b9804428a6d21">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae8f6bd7a757f9778c73477fc36159dff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.ItemRemoved </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListLeafBase.html">AListLeafBase</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an item is removed from a leaf node.</p>
<p>Note: this may be called as part of a move operation (remove+add)</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver.html#af1c70c321527704b3b8a68ceaefcfa9e">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a48fbe8c917f1192577b8822d94ebbab9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.NodeAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase.html">AListInnerBase</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a child node is added to an inner node.</p>
<p>Note: this may be called as part of a move operation (remove+add)</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver.html#a605c03aa32a7878e7453859022f61ebc">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a485240c333c0246e5b2ebea9b672759a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.NodeRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListInnerBase.html">AListInnerBase</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a child node is removed from an inner node.</p>
<p>Note: this may be called as part of a move operation (remove+add)</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver.html#a3efb469fbc2ccf1e5fad17b619887798">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6dd249cf2084b454d1f8c273f174c95c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.ReconstructIndex </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListLeafBase.html">AListLeafBase</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>leaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an item and a leaf that is known to contain a copy of the item, this method returns the index of the item in the tree as a whole. Requires O(M )</p>

</div>
</div>
<a class="anchor" id="a83d088065dd3b9f3c641880278cdb0c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.RemoveAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when all children are being removed from a node (leaf or inner) because the node is being split (AddAll will be called afterward for the two replacement nodes). Notifications are not sent for individual children.</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver.html#ad7488b485ec7c71903acf74cc8c028c2">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab1722336197cb2dfb1d8152b635dfa84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.RootChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1AListBase.html">AListBase</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListNode.html">AListNode</a>&lt; K, T &gt;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the root of the tree changes, or when the list is cleared. Also called after <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#a5ba4226f293b65d6e1a69384a1b09a16" title="Called when the observer is being attached to an AList.">Attach()</a>, but not after <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html#acc3892007948198657d3ef001b280372" title="Called when the observer is being detached from an AList. Detach(), unlike Attach(), is not paired with a call to RootChanged.">Detach()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear</td><td>true if the root is changing due to a Clear() operation. If this parameter is true, the observer should clear its own state. If this parameter is false but newRoot is null, it means that the list was cleared by removing all the items (rather than by calling Clear() on the list). In that case, if the observer still believes that any items exist in leaf nodes, it means that there is a bookkeeping error somewhere.</td></tr>
    <tr><td class="paramname">list</td><td>The list that changed.</td></tr>
    <tr><td class="paramname">newRoot</td><td>The new root (null if the tree is cleared).</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1Impl_1_1IAListTreeObserver.html#a62bd2513f9b6174aef35a0925781507b">Loyc.Collections.Impl.IAListTreeObserver&lt; K, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9c9b93b9ec85b02a3df15a2afffdae77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> <a class="el" href="classLoyc_1_1Collections_1_1Impl_1_1AListIndexer.html">Loyc.Collections.Impl.AListIndexer</a>&lt; K, T &gt;.VerifyCorrectness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans the index to verify that it matches the tree that is being indexed. The scan takes O(N log N + N M) time for a list of length N with maximum node size M.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidStateException</td><td>The index is out of sync with the tree. </td></tr>
  </table>
  </dd>
</dl>
<p>This could indicate a bug somewhere in the A-list code, but it could also be caused by other rogue code, such as items that change their sort order or hashcode after being added to the collection, an observer that has thrown exceptions when it's not allowed to, or buggy multithreading (modifying a list from two threads at once). </p>
<p>Tree observability is a difficult feature to implement correctly, so this method is called a lot in unit tests to help work out the bugs. </p>

<p>Referenced by <a class="el" href="classLoyc_1_1Collections_1_1IndexedAList.html#a433a750f1ea6329c72012453c4db3082">Loyc.Collections.IndexedAList&lt; T &gt;.VerifyCorrectness()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 17 2020 19:38:10 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
